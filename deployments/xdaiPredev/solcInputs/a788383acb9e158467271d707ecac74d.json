{
  "language": "Solidity",
  "sources": {
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/banners/BannerParts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title Default Banner parts nft\r\n/// @notice Acts as ERC1155 Nft token for banner parts\r\ncontract BannerParts is ERC1155, Ownable {\r\n    /// @notice Collection name\r\n    /// @dev Immutable, initialized on creation\r\n    string public name;\r\n\r\n    /// @notice Collection symbol\r\n    /// @dev Immutable, initialized on creation\r\n    string public symbol;\r\n\r\n    /// @notice Mapping containing if specified token id free or not\r\n    /// @dev Updated when #setFreeParts is called\r\n    /* @dev\r\n     * Id represents banner elements.\r\n     * 1 - 9999999999: first part\r\n     * 10000000000 - 19999999999: second part\r\n     * 20000000000 - 29999999999: third part\r\n     * 30000000000 - 39999999999: fourth part\r\n     * 40000000000 - 49999999999: fifth part\r\n     * 50000000000 - 59999999999: sixth part\r\n     * etc\r\n     */\r\n    mapping(uint256 => bool) public isFreePart;\r\n\r\n    /// @notice Trusted addresses map which can transfer without approve (For example: Opensea contract can be trusted so user can list its parts without approve)\r\n    /// @dev Updated when #setSafeApprovedAddress\r\n    mapping(address => bool) public isSafeApprovedAddress;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory uri_\r\n    ) public ERC1155(uri_) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /// @notice Marks provided address as trusted for transfers without approve\r\n    /// @dev Even though function is opened, it can only by contract owner\r\n    /// @param _address An address which will be marked as trusted or not\r\n    /// @param _status Is address trusted or not\r\n    function setSafeApprovedAddress(address _address, bool _status) public onlyOwner {\r\n        isSafeApprovedAddress[_address] = _status;\r\n    }\r\n\r\n    /// @notice Updates base token uri\r\n    /// @dev Only owner can modify base token uri\r\n    function updateURI(string memory uri_) public onlyOwner {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /// @notice Sets specified ids as free parts or not free parts\r\n    /// @dev Only owner can modify free parts\r\n    /// @param ids Token ids\r\n    /// @param statuses Is free parts or not\r\n    function setFreeParts(uint256[] calldata ids, bool[] calldata statuses) public onlyOwner {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            isFreePart[ids[i]] = statuses[i];\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function isApprovedForAll(address _owner, address _operator) public view override returns (bool isOperator) {\r\n        if (isSafeApprovedAddress[_operator]) {\r\n            return true;\r\n        }\r\n\r\n        return ERC1155.isApprovedForAll(_owner, _operator);\r\n    }\r\n\r\n    /// @notice Mints specified ids with specified amounts to specified address\r\n    /// @dev Only owner can mint new parts\r\n    /// @param account An address which will receive new parts\r\n    /// @param id New part id\r\n    /// @param amount Amount of nft that will be minted\r\n    /// @param data Custom data\r\n    function mint(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public onlyOwner {\r\n        // require(!isFreePart[id], \"cannot mint free banner\");\r\n        if (!isFreePart[id]) {\r\n            _mint(account, id, amount, data);\r\n        }\r\n    }\r\n\r\n    /// @notice Mints batch amount of ids with specified amounts to specified address\r\n    /// @dev Only owner can mint new parts\r\n    /// @param to An address which will receive new parts\r\n    /// @param ids New part ids\r\n    /// @param amounts Amounts of nfts that will be minted\r\n    /// @param data Custom data\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public onlyOwner {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (!isFreePart[ids[i]]) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory idsTrue = new uint256[](count);\r\n        uint256[] memory amountsTrue = new uint256[](count);\r\n\r\n        uint256 index;\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (!isFreePart[ids[i]]) {\r\n                idsTrue[index] = ids[i];\r\n                amountsTrue[index] = amounts[i];\r\n                index++;\r\n            }\r\n        }\r\n        _mintBatch(to, idsTrue, amountsTrue, data);\r\n    }\r\n\r\n    /// @notice Burns specified id with specified amount from specified address\r\n    /// @dev Only owner can burn parts\r\n    /// @param from An address from which tokens will be burned\r\n    /// @param id Token id\r\n    /// @param amount Amount of nft that will be burned\r\n    function burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        // require(!isFreePart[id], \"cannot burn free banner\");\r\n        if (!isFreePart[id]) {\r\n            _burn(from, id, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public override {\r\n        if (!isFreePart[id]) {\r\n            super.safeTransferFrom(from, to, id, amount, data);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        if (isFreePart[id]) {\r\n            return 1e6;\r\n        }\r\n\r\n        return super.balanceOf(account, id);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/banners/Banners.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\n\r\n/// @title Banners Nft\r\n/// @notice Acts as ERC721 Nft token, which supports ERC721 and ERC1155 parts as properties of every banner nft\r\ncontract Banners is ERC721Enumerable, Ownable, ERC1155Receiver {\r\n    struct Part {\r\n        address addr;\r\n        uint256 id;\r\n    }\r\n\r\n    struct BannerData {\r\n        string name;\r\n        Part[16] parts;\r\n        bytes data;\r\n    }\r\n\r\n    /// @notice Mapping containing banner data by provided token id\r\n    /// @dev Updated when #updateBanner or #mint is called\r\n    mapping(uint256 => BannerData) public bannerData;\r\n\r\n    /// @notice Base URI for computing token uri\r\n    /// @dev Updated on creation or when #updateURI is called\r\n    string public baseURI;\r\n\r\n    /// @notice Last created token id\r\n    /// @dev Updated when #mint is called\r\n    uint256 public lastTokenId = 0;\r\n\r\n    /// @notice Emitted when #mint is called\r\n    /// @param tokenIndex Newly created token id\r\n    /// @param name Banner name\r\n    /// @param parts Parts struct\r\n    /// @param data Banner custom parameters\r\n    event NewBanner(uint256 tokenIndex, string name, Part[16] parts, bytes data);\r\n\r\n    /// @notice Emitted when #updateBanner is called\r\n    /// @param tokenIndex Token id which was updated\r\n    /// @param name New banner name\r\n    /// @param parts New parts struct\r\n    /// @param data New banner custom parameters\r\n    event BannerUpdated(uint256 tokenIndex, string name, Part[16] parts, bytes data);\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory uri_\r\n    ) ERC721(name_, symbol_) {\r\n        baseURI = uri_;\r\n    }\r\n\r\n    /// @inheritdoc IERC165\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721Enumerable, ERC1155Receiver)\r\n        returns (bool)\r\n    {\r\n        return ERC721Enumerable.supportsInterface(interfaceId) || ERC1155Receiver.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @dev Overridden value from ERC721\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    /// @notice Returns banner data with parts\r\n    /// @dev Default mapping read method does not return all data\r\n    /// @param tokenIndex Token index\r\n    /// @return name Banner name\r\n    /// @return parts Banner parts\r\n    /// @return data Banner data\r\n    function getBannerData(uint256 tokenIndex)\r\n        public\r\n        view\r\n        returns (\r\n            string memory name,\r\n            Part[16] memory parts,\r\n            bytes memory data\r\n        )\r\n    {\r\n        return (bannerData[tokenIndex].name, bannerData[tokenIndex].parts, bannerData[tokenIndex].data);\r\n    }\r\n\r\n    /// @notice Returns all nfts with their banner data for specified holder address\r\n    /// @dev Used to query all nfts with their data without asking them one by one (may not work for holder with very large amount of nfts)\r\n    /// @param holderAddress Holder address\r\n    /// @return tokenIds Token ids holder owns\r\n    /// @return bannersData Banner data for every token id\r\n    function getBannerDataByUserBatch(address holderAddress)\r\n        public\r\n        view\r\n        returns (uint256[] memory tokenIds, BannerData[] memory bannersData)\r\n    {\r\n        uint256 userBalance = balanceOf(holderAddress);\r\n\r\n        bannersData = new BannerData[](userBalance);\r\n        tokenIds = new uint256[](userBalance);\r\n\r\n        for (uint256 i = 0; i < userBalance; i++) {\r\n            uint256 tokenId = tokenOfOwnerByIndex(holderAddress, i);\r\n            tokenIds[i] = tokenId;\r\n            bannersData[i] = bannerData[tokenId];\r\n        }\r\n    }\r\n\r\n    /// @notice Updates base token uri\r\n    /// @dev Only owner can modify base token uri\r\n    function updateURI(string memory _uri) public onlyOwner {\r\n        baseURI = _uri;\r\n    }\r\n\r\n    /// @notice Mints banner with specified parameters\r\n    /// @dev Specified banner parts will be taken from msg.sender\r\n    /// @param name Banner name\r\n    /// @param parts Banner parts\r\n    /// @param data Banner custom parameters\r\n    function mint(\r\n        string calldata name,\r\n        Part[16] memory parts,\r\n        bytes memory data\r\n    ) public {\r\n        lastTokenId++;\r\n\r\n        bannerData[lastTokenId].name = name;\r\n        bannerData[lastTokenId].data = data;\r\n        addParts(lastTokenId, parts);\r\n\r\n        _safeMint(msg.sender, lastTokenId, data);\r\n\r\n        emit NewBanner(lastTokenId, name, parts, data);\r\n    }\r\n\r\n    /// @dev Transfers specified banner parts from msg.sender to this contract\r\n    function addParts(uint256 tokenId, Part[16] memory parts) internal {\r\n        for (uint256 i = 0; i < parts.length; i++) {\r\n            if (parts[i].addr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            //try 721\r\n\r\n            try IERC721(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id) {} catch (\r\n                bytes memory /*lowLevelData*/\r\n            ) {\r\n                IERC1155(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id, 1, \"0x\");\r\n            }\r\n\r\n            bannerData[tokenId].parts[i] = parts[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Updates banner with specified parameters\r\n    /// @param tokenId banner token id which will be updated, old banner parts, if replaced, will be refunded to the owner\r\n    /// @param name New banner name\r\n    /// @param parts New banner parts\r\n    /// @param data Banner custom parameters\r\n    function updateBanner(\r\n        uint256 tokenId,\r\n        string calldata name,\r\n        Part[16] memory parts,\r\n        bytes memory data\r\n    ) public {\r\n        require(msg.sender == ownerOf(tokenId), \"token is not belongs to caller\");\r\n\r\n        for (uint256 i = 0; i < parts.length; i++) {\r\n            if (parts[i].addr == bannerData[tokenId].parts[i].addr && parts[i].id == bannerData[tokenId].parts[i].id) {\r\n                continue;\r\n            }\r\n\r\n            //try 721\r\n            if (parts[i].addr != address(0)) {\r\n                try IERC721(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id) {} catch (\r\n                    bytes memory /*lowLevelData*/\r\n                ) {\r\n                    IERC1155(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id, 1, \"0x\");\r\n                }\r\n            }\r\n\r\n            //withdraw previous nft\r\n            if (bannerData[tokenId].parts[i].addr != address(0)) {\r\n                try\r\n                    IERC721(bannerData[tokenId].parts[i].addr).safeTransferFrom(\r\n                        address(this),\r\n                        msg.sender,\r\n                        bannerData[tokenId].parts[i].id\r\n                    )\r\n                {} catch (\r\n                    bytes memory /*lowLevelData*/\r\n                ) {\r\n                    IERC1155(bannerData[tokenId].parts[i].addr).safeTransferFrom(\r\n                        address(this),\r\n                        msg.sender,\r\n                        bannerData[tokenId].parts[i].id,\r\n                        1,\r\n                        \"0x\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            bannerData[tokenId].parts[i] = parts[i];\r\n        }\r\n\r\n        bannerData[tokenId].name = name;\r\n        bannerData[tokenId].data = data;\r\n        emit BannerUpdated(tokenId, name, parts, data);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/token/IERC20Int.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC20Int is IERC20 {\r\n    function realBalanceOf(address account) external view returns (int256);\r\n\r\n    function realTotalSupply() external view returns (int256);\r\n}\r\n"
    },
    "contracts/token/ERC20Int.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"./IERC20Int.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20Int is Context, IERC20Int, IERC20Metadata {\r\n    mapping(address => int256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    int256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        if (_totalSupply < 0) {\r\n            return 0;\r\n        }\r\n        return uint256(_totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Int-realTotalSupply}.\r\n     */\r\n    function realTotalSupply() public view virtual returns (int256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Int-realBalanceOf}.\r\n     */\r\n    function realBalanceOf(address account) public view virtual returns (int256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        if (_balances[account] < 0) {\r\n            return 0;\r\n        }\r\n        return uint256(_balances[account]);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        int256 intAmount = int256(amount);\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        int256 fromBalance = _balances[from];\r\n        require(fromBalance >= intAmount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - intAmount;\r\n        }\r\n        _balances[to] += intAmount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += int256(amount);\r\n        _balances[account] += int256(amount);\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        int256 accountBalance = _balances[account];\r\n        unchecked {\r\n            _balances[account] = accountBalance - int256(amount);\r\n        }\r\n        _totalSupply -= int256(amount);\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/token/ERC20IntBurnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"./ERC20Int.sol\";\r\nimport \"./IERC20Burnable.sol\";\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20IntBurnable is Context, ERC20Int, IERC20Burnable {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/token/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IERC20Burnable {\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/tokens/workers/IWorkers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Workers interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IWorkers is IERC20Burnable, IERC20 {\r\n    /// @notice Mints workers to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive workers\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/World.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"./IWorld.sol\";\r\nimport \"./tokens/resources/IResourceFactory.sol\";\r\nimport \"./assets/building/IBuilding.sol\";\r\nimport \"./tokens/units/IUnitsFactory.sol\";\r\nimport \"./tokens/workers/IWorkersFactory.sol\";\r\nimport \"./tokens/prosperity/IProsperityFactory.sol\";\r\nimport \"./tokens/workers/IWorkers.sol\";\r\nimport \"./assets/epoch/IEpochFactory.sol\";\r\nimport \"./crossEpochsMemory/ICrossEpochsMemory.sol\";\r\n\r\ncontract World is IWorld, Initializable {\r\n    /// @inheritdoc IWorld\r\n    IRegistry public override registry;\r\n    /// @inheritdoc IWorld\r\n    IGeography public override geography;\r\n    /// @inheritdoc IWorld\r\n    IERC721 public override bannerContract;\r\n    /// @inheritdoc IWorld\r\n    IERC20 public override blessToken;\r\n    /// @inheritdoc IWorld\r\n    IDistributions public override distributions;\r\n    /// @inheritdoc IWorld\r\n    ICrossEpochsMemory public override crossEpochsMemory;\r\n    /// @inheritdoc IWorld\r\n    IRewardPool public override rewardPool;\r\n\r\n    /// @inheritdoc IWorld\r\n    uint256 public override gameStartTime;\r\n    /// @inheritdoc IWorld\r\n    uint256 public override gameFinishTime;\r\n\r\n    /// @inheritdoc IWorld\r\n    uint256 public override currentEpochNumber;\r\n    /// @inheritdoc IWorld\r\n    mapping(uint256 => IEpoch) public override epochs;\r\n    /// @inheritdoc IWorld\r\n    mapping(uint256 => mapping(address => bytes32)) public override worldAssets;\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    modifier onlyActiveGame() {\r\n        uint256 finishTime = gameFinishTime;\r\n        require(finishTime == 0 || block.timestamp < finishTime, \"onlyActiveGame\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator or reward pool\r\n    modifier onlyMightyCreatorOrRewardPool() {\r\n        require(msg.sender == registry.mightyCreator() || msg.sender == address(rewardPool), \"onlyMightyCreatorOrRewardPool\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    modifier onlyMightyCreator() {\r\n        require(msg.sender == registry.mightyCreator(), \"onlyMightyCreator\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only factory contract\r\n    modifier onlyFactory() {\r\n        require(registry.isFactoryContract(msg.sender), \"onlyFactory\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function init(\r\n        address registryContractAddress,\r\n        address crossEpochsMemoryAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address blessTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    ) public override initializer {\r\n        registry = IRegistry(registryContractAddress);\r\n        crossEpochsMemory = ICrossEpochsMemory(crossEpochsMemoryAddress);\r\n        geography = IGeography(geographyAddress);\r\n        bannerContract = IERC721(bannersAddress);\r\n        blessToken = IERC20(blessTokenAddress);\r\n        distributions = IDistributions(distributionsAddress);\r\n        rewardPool = IRewardPool(rewardPoolAddress);\r\n\r\n        emit WorldInitialized(\r\n            registryContractAddress,\r\n            geographyAddress,\r\n            bannersAddress,\r\n            blessTokenAddress,\r\n            distributionsAddress,\r\n            rewardPoolAddress\r\n        );\r\n\r\n        createAndAssignEpoch(currentEpochNumber);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function addWorldAsset(\r\n        uint256 epochNumber,\r\n        address worldAsset,\r\n        bytes32 assetType\r\n    ) public override onlyFactory {\r\n        worldAssets[epochNumber][worldAsset] = assetType;\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function setGameStartTime(uint256 value) public override onlyMightyCreator {\r\n        gameStartTime = value;\r\n        emit GameStartTimeUpdated(value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function setGameFinishTime(uint256 value) public override onlyMightyCreatorOrRewardPool {\r\n        gameFinishTime = value;\r\n        emit GameFinishTimeUpdated(value);\r\n    }\r\n\r\n    /// @dev Creates epoch\r\n    function createEpoch(uint256 epochNumber) internal returns (IEpoch) {\r\n        IEpochFactory epochFactory = IEpochFactory(\r\n            registry.factoryContracts(keccak256(bytes((\"epoch\"))))\r\n        );\r\n\r\n        return IEpoch(epochFactory.create(address(this), epochNumber, \"BASIC\"));\r\n    }\r\n\r\n    /// @dev Create and assign epoch\r\n    function createAndAssignEpoch(uint256 epochNumber) internal {\r\n        epochs[epochNumber] = createEpoch(epochNumber);\r\n        emit NewWorldEpoch(address(epochs[epochNumber]), epochNumber);\r\n\r\n        setCurrentEpochNumber(epochNumber);\r\n    }\r\n\r\n    /// @dev Sets current epoch number\r\n    function setCurrentEpochNumber(uint256 newEpochNumber) internal {\r\n        currentEpochNumber = newEpochNumber;\r\n        emit CurrentEpochNumberUpdated(newEpochNumber);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintWorkers(\r\n        uint256 epochNumber,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override onlyMightyCreator {\r\n        epochs[epochNumber].workers().mint(_to, _value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintUnits(\r\n        uint256 epochNumber,\r\n        string memory _unitName,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override onlyMightyCreator {\r\n        epochs[epochNumber].units(_unitName).mint(_to, _value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintResources(\r\n        uint256 epochNumber,\r\n        string memory _resourceName,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override onlyMightyCreator {\r\n        epochs[epochNumber].resources(_resourceName).mint(_to, _value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function batchTransferResources(\r\n        uint256 epochNumber,\r\n        address to,\r\n        string[] calldata resourcesNames,\r\n        uint256[] calldata amounts\r\n    ) public override {\r\n        for (uint256 i = 0; i < resourcesNames.length; i++) {\r\n            epochs[epochNumber].resources(resourcesNames[i]).transferFrom(msg.sender, to, amounts[i]);\r\n        }\r\n    }\r\n\r\n    //    /// @inheritdoc IWorld\r\n    //    function batchTransferBuildingTokens(\r\n    //        address[] calldata buildingAddresses,\r\n    //        address[] calldata senders,\r\n    //        address[] calldata recipients,\r\n    //        uint256[] calldata amounts\r\n    //    ) public override {\r\n    //        for (uint256 i = 0; i < buildingAddresses.length; i++) {\r\n    //            IBuilding(buildingAddresses[i]).buildingTokenTransferFrom(\r\n    //                msg.sender,\r\n    //                senders[i],\r\n    //                recipients[i],\r\n    //                amounts[i]\r\n    //            );\r\n    //        }\r\n    //    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function destroyCurrentEpoch() public override onlyActiveGame {\r\n        IEpoch epoch = epochs[currentEpochNumber];\r\n\r\n        uint256 noDestructionDelay = registry.getCultistsNoDestructionDelay() / registry.getGlobalMultiplier();\r\n        uint256 destructionAvailabilityTime = epoch.mostRecentCultistsSummonTime() + noDestructionDelay;\r\n        require(block.timestamp > destructionAvailabilityTime, \"destruction not available yet\");\r\n\r\n        uint256 maxAllowedCultists = geography.getZonesLength() * registry.getCultistsPerZoneMultiplier();\r\n        require(epoch.totalCultists() > maxAllowedCultists, \"cultists limit not reached\");\r\n\r\n        uint256 newEpochNumber = currentEpochNumber + 1;\r\n        createAndAssignEpoch(newEpochNumber);\r\n        rewardPool.handleEpochDestroyed();\r\n    }\r\n\r\n    function destroyCurrentEpochWithoutCondition() public onlyMightyCreator {\r\n        createAndAssignEpoch(currentEpochNumber + 1);\r\n        rewardPool.handleEpochDestroyed();\r\n    }\r\n}\r\n"
    },
    "contracts/core/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Registry interface\r\n/// @notice Functions related to current game configuration\r\ninterface IRegistry {\r\n    struct GameResource {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        string worldResourceName;\r\n    }\r\n\r\n    struct GameUnit {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        string worldUnitName;\r\n    }\r\n\r\n    struct ExtraResource {\r\n        string resourceName;\r\n        uint256 value;\r\n    }\r\n\r\n    struct UnitStats {\r\n        uint256 weaponPowerStage1;\r\n        uint256 armourPowerStage1;\r\n        uint256 weaponPowerStage2;\r\n        uint256 armourPowerStage2;\r\n        uint256 siegePower;\r\n        uint256 siegeMaxSupply;\r\n        uint256 siegeSupport;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice An address which can configure/reconfigure current game\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function mightyCreator() external view returns (address);\r\n\r\n    /// @notice Mapping containing is provided address a factory contract or not\r\n    /// @dev Updated when #setFactoryContract is called\r\n    function isFactoryContract(address factoryAddress) external view returns (bool);\r\n\r\n    /// @notice Mapping containing factory contracts addresses by provided asset types\r\n    /// @dev Updated when #setFactoryContract is called\r\n    /// @dev During new world asset creation process registry is asked for factory contract for exact world asset type, which will contain creation method for new world asset\r\n    function factoryContracts(bytes32 scriptId) external view returns (address);\r\n\r\n    /// @notice Mapping containing assets implementations addresses by provided asset types\r\n    /// @dev Updated when #setScriptContractName is called\r\n    /// @dev Every worlds assets implementation (code, not data) will be defined by value from this mapping\r\n    function scriptContracts(bytes32 scriptId) external view returns (address);\r\n\r\n    /// @notice Mapping containing units stats by provided unit types\r\n    /// @dev Updated when #setUnitStats is called\r\n    function unitsStats(string memory unitName)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 weaponPowerStage1,\r\n            uint256 armourPowerStage1,\r\n            uint256 weaponPowerStage2,\r\n            uint256 armourPowerStage2,\r\n            uint256 siegePower,\r\n            uint256 siegeMaxSupply,\r\n            uint256 siegeSupport\r\n        );\r\n\r\n    /// @notice Global multiplier\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function globalMultiplier() external view returns (uint256);\r\n\r\n    /// @notice Settlement starting price\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function settlementStartingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param globalMultiplier Global multiplier\r\n    /// @param settlementStartingPrice Settlement starting price\r\n    function init(\r\n        uint256 globalMultiplier,\r\n        uint256 settlementStartingPrice\r\n    ) external;\r\n\r\n    /// @notice Sets provided address as factory contract for provided asset type\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param assetType Type of the asset\r\n    /// @param factoryAddress Factory address\r\n    function setFactoryContract(bytes32 assetType, address factoryAddress) external;\r\n\r\n    /// @notice Sets provided address as implementation for provided asset group and asset type (for ex. group - \"settlement\", type - \"CULTISTS\")\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param assetGroup Asset group\r\n    /// @param assetType Type of the asset\r\n    /// @param implementationAddress Implementation address\r\n    function setScriptContractName(\r\n        string memory assetGroup,\r\n        string memory assetType,\r\n        address implementationAddress\r\n    ) external;\r\n\r\n    /// @notice Sets units stats for provided unit type\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param unitName Unit type\r\n    /// @param unitStats Unit stats struct\r\n    function setUnitStats(string calldata unitName, UnitStats memory unitStats) external;\r\n\r\n    /// @notice Calculates worker capacity coefficient for provided building type\r\n    /// @dev Used for internal calculation of max workers for each building\r\n    /// @param buildingName Building type\r\n    /// @return workerCapacityCoefficient Worker capacity coefficient\r\n    function getWorkerCapacityCoefficient(string memory buildingName) external pure returns (uint256 workerCapacityCoefficient);\r\n\r\n    /// @notice Calculates basic production building coefficient\r\n    /// @dev used for internal calculation of production result\r\n    /// @param buildingName Building type\r\n    /// @return basicProductionBuildingCoefficient Basic production building coefficient\r\n    function getBasicProductionBuildingCoefficient(string memory buildingName) external pure returns (uint256 basicProductionBuildingCoefficient);\r\n\r\n    /// @notice Calculates if provided building has starting treasury on creation\r\n    /// @dev Used for determination if treasury should be filled on settlement creation\r\n    /// @param buildingName Building type\r\n    /// @return hasStartingTreasury If treasury should be filled\r\n    function hasStartingTreasury(string memory buildingName) external pure returns (bool hasStartingTreasury);\r\n\r\n    /// @notice Calculates toxicity by resource ratio\r\n    /// @dev Used for minting/burning toxicity\r\n    /// @param resourceName Resource name\r\n    /// @return toxicity Amount of toxicity per 1 resource (both are in 1e18 precision)\r\n    function getToxicityByResource(string memory resourceName) external pure returns (uint256 toxicity);\r\n\r\n    /// @notice Calculates resource weight\r\n    /// @dev Used for calculation how much prosperity will be produced by resource in treasury\r\n    /// @param resourceName Resource name\r\n    /// @return resourceWeight Resource weight (in 1e0 precision)\r\n    function getResourceWeight(string memory resourceName) external pure returns (uint256 resourceWeight);\r\n\r\n    /// @notice Returns siege power to siege siege points multiplier\r\n    /// @dev Used for determination how much siege points will be given\r\n    /// @return siegePowerToSiegePointsMultiplier Siege power to siege siege points multiplier (in 1e18 precision)\r\n    function getSiegePowerToSiegePointsMultiplier() external pure returns (uint256 siegePowerToSiegePointsMultiplier);\r\n\r\n    /// @notice Returns siege point multiplier by provided resource\r\n    /// @dev Used in calculation how many resources can be exchanged for siege points\r\n    /// @param resourceName Resource name\r\n    /// @return siegePointsToResourceMultiplier Siege point multiplier (in 1e18 precision)\r\n    function getSiegePointsToResourceMultiplier(string memory resourceName) external view returns (uint256 siegePointsToResourceMultiplier);\r\n\r\n    /// @notice Returns robbery fee\r\n    /// @dev Used in determination how much of resource will be burned during robbery\r\n    /// @return robberyFee Robbery fee (in 1e18 precision, where 1e18 is 100%)\r\n    function getRobberyFee() external view returns (uint256 robberyFee);\r\n\r\n    /// @notice Returns global multiplier\r\n    /// @dev Used everywhere, where time is involved. Essentially determines game speed\r\n    /// @return globalMultiplier Global multiplier\r\n    function getGlobalMultiplier() external view returns (uint256 globalMultiplier);\r\n\r\n    /// @notice Returns production to treasury percent\r\n    /// @dev Determines how much of buildings production will go to treasury (if not full)\r\n    /// @param toTreasuryPercent Production to treasury percent (in 1e18 precision, where 1e18 is 100%)\r\n    function getToTreasuryPercent() external pure returns (uint256 toTreasuryPercent);\r\n\r\n    /// @notice Returns base battle duration\r\n    /// @dev Used internally to determine how long battle will last\r\n    /// @return baseBattleDuration Base battle duration\r\n    function getBaseBattleDuration() external view returns (uint256 baseBattleDuration);\r\n\r\n    /// @notice Returns battle lobby phase duration percent (in 1e18 precision)\r\n    /// @dev Used internally to determine how long lobby phase will last\r\n    /// @return battleLobbyDurationPercent Battle lobby phase duration percent\r\n    function getBattleLobbyDurationPercent() external view returns (uint256 battleLobbyDurationPercent);\r\n\r\n    /// @notice Returns battle duration stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after army lost battle\r\n    /// @return battleDurationStunMultiplier Battle duration stun multiplier\r\n    function getBattleDurationStunMultiplier() external pure returns (uint256 battleDurationStunMultiplier);\r\n\r\n    /// @notice Returns movement duration stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after armies' movement\r\n    /// @return movementDurationStunMultiplier Movement duration stun multiplier\r\n    function getMovementDurationStunMultiplier() external pure returns (uint256 movementDurationStunMultiplier);\r\n\r\n    /// @notice Returns game buildings\r\n    /// @dev Used internally to determine which buildings will be created on placing settlement\r\n    /// @return buildings Buildings\r\n    function getBuildings() external view returns (string[] memory buildings);\r\n\r\n    /// @notice Returns game resources\r\n    /// @dev Used internally to determine upgrade costs and providing initial resources for settlement owner based on his tier\r\n    /// @param resources Game resources\r\n    function getResources() external view returns (string[] memory resources);\r\n\r\n    /// @notice Returns game units\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return units Game units\r\n    function getUnits() external view returns (string[] memory units);\r\n\r\n    /// @notice Returns game resources\r\n    /// @dev Used internally to determine upgrade costs and providing initial resources for settlement owner based on his tier\r\n    /// @param resources Game resources\r\n    function getGameResources() external view returns (GameResource[] memory resources);\r\n\r\n    /// @notice Returns game units\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return units Game units\r\n    function getGameUnits() external view returns (GameUnit[] memory units);\r\n\r\n    /// @notice Returns unit hiring fort hp multiplier\r\n    /// @dev Used to determine how much units in army can be presented based on its current fort hp and this parameter\r\n    /// @return unitHiringFortHpMultiplier Unit hiring fort hp multiplier\r\n    function getUnitHiringFortHpMultiplier() external pure returns (uint256 unitHiringFortHpMultiplier);\r\n\r\n    /// @notice Returns how much food unit can take from treasury to increase its army movement speed\r\n    /// @dev Used internally to calculate army's movement speed\r\n    /// @param unitType Unit type\r\n    /// @return unitMaxFoodToSpendOnMove Maximum amount of food to spend on move (in 1e18 precision)\r\n    function getUnitMaxFoodToSpendOnMove(string memory unitType) external pure returns (uint256 unitMaxFoodToSpendOnMove);\r\n\r\n    /// @notice Returns how much prosperity will be given for provided unit type\r\n    /// @dev Used internally to calculate how much prosperity will be given\r\n    /// @return prosperityPerUnit Prosperity amount per one unit (in 1e18 precision)\r\n    function getProsperityForDemilitarization(string memory unitType) external pure returns (uint256 prosperityPerUnit);\r\n\r\n    /// @notice Returns cultists summon delay\r\n    /// @dev Used to determine is cultists can be re-summoned\r\n    /// @return cultistsSummonDelay Cultists summon delay (in seconds)\r\n    function getCultistsSummonDelay() external pure returns (uint256 cultistsSummonDelay);\r\n\r\n    /// @notice Returns max settlement that can be placed in one zone\r\n    /// @dev Cultists does not count (so +1 with cultists)\r\n    /// @return maxSettlementPerZone Max settlement that can be placed in one zone\r\n    function getMaxSettlementPerZone() external pure returns (uint256 maxSettlementPerZone);\r\n\r\n    /// @notice Returns interval duration where world is not destructible after recent cultists summon\r\n    /// @dev Used to determine if destruction is available or not\r\n    /// @return cultistsNoDestructionDelay No destruction interval duration (in seconds)\r\n    function getCultistsNoDestructionDelay() external pure returns (uint256 cultistsNoDestructionDelay);\r\n\r\n    /// @notice Returns value of cultists per zone which determines cultists threshold for world destruction\r\n    /// @dev Used to determine amount of cultists that have to be present for world destruction\r\n    /// @return cultistsPerZoneMultiplier Value of cultists per zone\r\n    function getCultistsPerZoneMultiplier() external pure returns (uint256 cultistsPerZoneMultiplier);\r\n\r\n    /// @notice Returns maximum amount of cultists that can be present in zone\r\n    /// @dev Used to determine how many cultists will be summoned\r\n    /// @return maxCultistsPerZone Maximum amount of cultists\r\n    function getMaxCultistsPerZone() external pure returns (uint256 maxCultistsPerZone);\r\n\r\n    /// @notice Returns unit type of cultists army\r\n    /// @dev Determines type of unit in cultists army\r\n    /// @return cultistUnitType Cultists unit type\r\n    function getCultistUnitType() external pure returns (string memory cultistUnitType);\r\n\r\n    /// @notice Returns building token transfer threshold percent\r\n    /// @dev Used to determine is building token transfer allowed based on treasury percent\r\n    /// @return buildingTokenTransferThresholdPercent Building token transfer threshold percent\r\n    function getBuildingTokenTransferThresholdPercent() external pure returns (uint256 buildingTokenTransferThresholdPercent);\r\n\r\n    /// @notice Returns extra resources which will be minted to user when new settlement is placed\r\n    /// @dev During settlement creation continent contract uses output from this function to determine how much extra resources to mint\r\n    /// @return extraResources Extra resources which will be minted to user when new settlement is placed\r\n    function getNewSettlementExtraResources() external view returns (ExtraResource[] memory extraResources);\r\n\r\n    /// @notice Returns new settlement starting price in settlements market\r\n    /// @dev Used to determine how much base price for first settlement will be\r\n    /// @return newSettlementStartingPrice New settlement starting price\r\n    function getNewSettlementStartingPrice() external view returns (uint256 newSettlementStartingPrice);\r\n\r\n    /// @notice Returns amount of production ticks\r\n    /// @dev Used for production calculation\r\n    /// @return ticks Amount of production ticks\r\n    function getProductionTicksInSecond() external view returns (uint256 ticks);\r\n\r\n    /// @notice Returns army demilitarization cooldown in seconds\r\n    /// @dev Used for army demilitarization restriction\r\n    /// @return cooldown Demilitarization cooldown in seconds\r\n    function getDemilitarizationCooldown() external pure returns (uint256 cooldown);\r\n\r\n    /// @notice Returns unit pool price drop per second for provided unit type, provided as numerator and denominator\r\n    /// @dev Used for determination of current unit pool price\r\n    /// @param unitType Unit type\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getUnitPriceDropByUnitType(string memory unitType) external pure returns (uint256 numerator, uint256 denominator);\r\n}\r\n"
    },
    "contracts/core/IWorld.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"./tokens/resources/IResource.sol\";\r\nimport \"./assets/epoch/IEpoch.sol\";\r\nimport \"./tokens/prosperity/IProsperity.sol\";\r\nimport \"./tokens/units/IUnits.sol\";\r\nimport \"./tokens/workers/IWorkers.sol\";\r\nimport \"./geography/IGeography.sol\";\r\nimport \"./crossEpochsMemory/ICrossEpochsMemory.sol\";\r\nimport \"./rewardPool/IRewardPool.sol\";\r\nimport \"./distributions/IDistributions.sol\";\r\n\r\n/// @title World interface\r\n/// @notice Functions to read state/modify state of game world\r\ninterface IWorld {\r\n    /// @notice Emitted when world initialized\r\n    /// @param registryContractAddress Registry contract address\r\n    /// @param geographyAddress Geography contract address\r\n    /// @param bannersAddress Mithraeum banners contract address\r\n    /// @param blessTokenAddress Bless token address\r\n    /// @param distributionsAddress Distributions token address\r\n    /// @param rewardPoolAddress Reward pool address\r\n    event WorldInitialized(\r\n        address registryContractAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address blessTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    );\r\n\r\n    /// @notice Emitted when #setGameStartTime is called\r\n    /// @param timestamp New game start time\r\n    event GameStartTimeUpdated(uint timestamp);\r\n\r\n    /// @notice Emitted when #setGameFinishTime is called\r\n    /// @param timestamp New game finish time\r\n    event GameFinishTimeUpdated(uint timestamp);\r\n\r\n    /// @notice Emitted when world initialized or #destroyCurrentEpoch is called\r\n    /// @param epochAddress New epoch address\r\n    /// @param epochNumber New epoch number\r\n    event NewWorldEpoch(address epochAddress, uint256 epochNumber);\r\n\r\n    /// @notice Emitted after new epoch initialization\r\n    /// @param epochNumber New epoch number\r\n    event CurrentEpochNumberUpdated(uint256 epochNumber);\r\n\r\n    // State variables\r\n\r\n    /// @notice Registry\r\n    /// @dev Immutable, initialized on creation\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Banners token\r\n    /// @dev Immutable, initialized on creation\r\n    function bannerContract() external view returns (IERC721);\r\n\r\n    /// @notice Bless token\r\n    /// @dev Immutable, initialized on creation\r\n    function blessToken() external view returns (IERC20);\r\n\r\n    /// @notice Distributions token\r\n    /// @dev Immutable, initialized on creation\r\n    function distributions() external view returns (IDistributions);\r\n\r\n    /// @notice Cross epochs memory\r\n    /// @dev Immutable, initialized on creation\r\n    function crossEpochsMemory() external view returns (ICrossEpochsMemory);\r\n\r\n    /// @notice Reward pool\r\n    /// @dev Immutable, initialized on creation\r\n    function rewardPool() external view returns (IRewardPool);\r\n\r\n    /// @notice Game start time\r\n    /// @dev Updated when #setGameStartTime is called\r\n    function gameStartTime() external view returns (uint256);\r\n\r\n    /// @notice Game finish time\r\n    /// @dev Updated when #setGameFinishTime is called\r\n    function gameFinishTime() external view returns (uint256);\r\n\r\n    /// @notice Geography\r\n    /// @dev Immutable, initialized on creation\r\n    function geography() external view returns (IGeography);\r\n\r\n    /// @notice Current world epoch\r\n    /// @dev Updated when #destroy is called\r\n    function currentEpochNumber() external view returns (uint256);\r\n\r\n    /// @notice World epochs\r\n    /// @dev Updated when world initialized or #destroy is called\r\n    function epochs(uint256 epochNumber) external view returns (IEpoch);\r\n\r\n    /// @notice Mapping containing world asset type by provided epoch number and address\r\n    /// @dev Updated when #addWorldAsset is called\r\n    function worldAssets(uint256 epochNumber, address worldAsset) external view returns (bytes32);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param registryContractAddress Registry contract address\r\n    /// @param crossEpochsMemoryAddress Cross epochs memory address\r\n    /// @param geographyAddress Geography contract address\r\n    /// @param bannersAddress Banners token address\r\n    /// @param blessTokenAddress Bless token address\r\n    /// @param distributionsAddress Distributions token address\r\n    /// @param rewardPoolAddress Reward pool address\r\n    function init(\r\n        address registryContractAddress,\r\n        address crossEpochsMemoryAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address blessTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    ) external;\r\n\r\n    /// @notice Adds an address as world asset\r\n    /// @dev Even though function is opened, it can only be called by factory contract\r\n    /// @param epochNumber Epoch number\r\n    /// @param worldAssetAddress World asset address\r\n    /// @param assetType Asset type\r\n    function addWorldAsset(\r\n        uint256 epochNumber,\r\n        address worldAssetAddress,\r\n        bytes32 assetType\r\n    ) external;\r\n\r\n    /// @notice Mints workers to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param to Address which will receive workers\r\n    /// @param value Amount of workers to mint\r\n    function mintWorkers(\r\n        uint256 epochNumber,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints units to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param unitName Type of unit to mint\r\n    /// @param to Address which will receive units\r\n    /// @param value Amount of units to mint\r\n    function mintUnits(\r\n        uint256 epochNumber,\r\n        string memory unitName,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints resource to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param resourceName Resource name\r\n    /// @param to Address which will receive resources\r\n    /// @param value Amount of resources to mint\r\n    function mintResources(\r\n        uint256 epochNumber,\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Transfers multiple resources to provided address\r\n    /// @dev Uses msg.sender as resources sender\r\n    /// @param epochNumber Epoch number\r\n    /// @param to An address which will receive resources\r\n    /// @param resourcesNames Resources names\r\n    /// @param amounts Amount of each resources to transfer\r\n    function batchTransferResources(\r\n        uint256 epochNumber,\r\n        address to,\r\n        string[] calldata resourcesNames,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n//    /// @notice Transfers multiple buildings tokens to provided addresses\r\n//    /// @dev Uses msg.sender to verify is buildings tokens address transfer allowed from specified senders (for ex. settlement owner can recall its buildings tokens in certain conditions)\r\n//    /// @param buildingAddresses Addresses of buildings\r\n//    /// @param senders Addresses from which buildings tokens will be transferred\r\n//    /// @param recipients Addresses which will receive buildings tokens\r\n//    /// @param amounts Amount of each building token to transfer\r\n//    function batchTransferBuildingTokens(\r\n//        address[] calldata buildingAddresses,\r\n//        address[] calldata senders,\r\n//        address[] calldata recipients,\r\n//        uint256[] calldata amounts\r\n//    ) external;\r\n\r\n    /// @notice Sets game finish time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator or reward pool\r\n    /// @param gameFinishTime Game finish time\r\n    function setGameFinishTime(uint256 gameFinishTime) external;\r\n\r\n    /// @notice Sets game start time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param gameStartTime Game start time\r\n    function setGameStartTime(uint256 gameStartTime) external;\r\n\r\n    /// @notice Destroys current epoch if conditions are met\r\n    /// @dev Anyone can call this function\r\n    function destroyCurrentEpoch() external;\r\n}\r\n"
    },
    "contracts/core/tokens/resources/IResourceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Resource factory interface\r\n/// @notice Contains instance creator function\r\ninterface IResourceFactory {\r\n    /// @notice Creates Resource instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param tokenName Name of the token\r\n    /// @param tokenSymbol Symbol of the token\r\n    /// @param worldResourceName Resource name in world configuration (FOOD/WOOD/ORE/WEAPON)\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        string memory worldResourceName\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/building/IBuilding.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Building interface\r\n/// @notice Functions to read state/modify state in order to get current building parameters and/or interact with it\r\ninterface IBuilding {\r\n    struct BasicProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    struct AdvancedProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    struct Production {\r\n        uint256 lastUpdateStateTime;\r\n        uint256 lastUpdateStateZoneTime;\r\n        uint256 extraTicksAfterFinish;\r\n        uint256 productionFinishZoneTime;\r\n        uint256 readyToBeDistributed;\r\n    }\r\n\r\n    struct ProductionResultItem {\r\n        string resourceName;\r\n        uint256 balanceChanges;\r\n        bool isProducing;\r\n    }\r\n\r\n    struct InitialResourceBlock {\r\n        string resourceName;\r\n        uint256 perTick;\r\n        bool isProducing;\r\n    }\r\n\r\n    /// @notice Emitted when #startBasicUpgrade or #startAdvancedUpgrade is called\r\n    /// @param stateLevel New building level\r\n    event UpgradeFinish(uint256 stateLevel);\r\n\r\n    /// @notice Emitted when #distribute is called. When resources from production are distributed to building token holders. Will be deprecated in favor of ERC20 transfer event.\r\n    /// @param resourceName Name of resource distributed\r\n    /// @param holder Receiver address\r\n    /// @param amount Amount of distributed resources\r\n    event DistributedToShareHolder(string resourceName, address holder, uint256 amount);\r\n\r\n    /// @notice Emitted when #setDefaultDistribution is called\r\n    /// @param distributionId Newly created distribution id\r\n    /// @param previousReceivers Previous distribution receivers\r\n    event NewDistribution(uint256 distributionId, address[] previousReceivers);\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this building belongs\r\n    /// @dev Immutable, initialized on the building creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Basic production\r\n    /// @dev Contains basic production upgrade data\r\n    /// @return level Basic production level\r\n    /// @return coefficient Basic production coefficient\r\n    function basicProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient\r\n    );\r\n\r\n    /// @notice Advanced production\r\n    /// @dev Contains advanced production upgrade data\r\n    /// @return level Advanced production level\r\n    /// @return coefficient Advanced production coefficient\r\n    function advancedProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient\r\n    );\r\n\r\n    /// @notice Upgrade cooldown finish time\r\n    /// @dev Updated when #startBasicUpgrade or #startAdvancedUpgrade is called\r\n    /// @return upgradeCooldownFinishTime Upgrade cooldown finish time\r\n    function upgradeCooldownFinishTime() external view returns (uint256 upgradeCooldownFinishTime);\r\n\r\n    /// @notice Buildings prosperity\r\n    /// @dev Contains last written prosperity amount in building\r\n    /// @return prosperity Current building prosperity\r\n    function prosperity() external view returns (uint256 prosperity);\r\n\r\n    /// @notice Contains current production state of the building\r\n    /// @dev Contains information related to how production is calculated\r\n    /// @return lastUpdateStateTime Time at which last #updateState is called\r\n    /// @return lastUpdateStateZoneTime Zone time at which last #updateState is called\r\n    /// @return extraTicksAfterFinish Amount of extra resource ticks will be performed after 'productionFinishZoneTime'. Implication of this parameter is special case when there are resources for production however they are produced in less than a second.\r\n    /// @return productionFinishZoneTime Zone time at which production will stop\r\n    /// @return readyToBeDistributed Amount of produced resource ready to be distributed\r\n    function production()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 lastUpdateStateTime,\r\n            uint256 lastUpdateStateZoneTime,\r\n            uint256 extraTicksAfterFinish,\r\n            uint256 productionFinishZoneTime,\r\n            uint256 readyToBeDistributed\r\n        );\r\n\r\n    /// @notice Distribution id\r\n    /// @dev Initialized on creation and updated on #resetDistribution\r\n    function distributionId() external view returns (uint256);\r\n\r\n    /// @notice Produced resource debt\r\n    /// @dev Updated when #distributeToSingleHolder or #distributeToAllShareholders is called\r\n    function producedResourceDebt(address holder) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Resets current building distribution\r\n    /// @dev Creates new distribution Nft and mints it to current settlement owner\r\n    function resetDistribution() external;\r\n\r\n    /// @notice Callback which recalculates production. Called when workers or resources, which related to production of this building, is transferred from/to this building\r\n    /// @dev Even though function is opened, it is auto-called by transfer method. Standalone calls provide 0 impact.\r\n    function productionChanged() external;\r\n\r\n    /// @notice Updates state of this building up to block.timestamp\r\n    /// @dev Updates building production minting treasury and increasing #production.readyToBeDistributed\r\n    function updateState() external;\r\n\r\n    /// @notice Fixes debt from shareholder whenever its share part changes\r\n    /// @dev Even though function is opened, it can be called only by distributions\r\n    /// @param from From address\r\n    /// @param to To address\r\n    /// @param amount Amount\r\n    function fixDebtAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Distributes produced resource to single shareholder\r\n    /// @dev Useful to taking part of the resource from the building for single shareholder (to not pay gas for minting for all shareholders)\r\n    /// @param holder Holder\r\n    function distributeToSingleShareholder(address holder) external;\r\n\r\n    /// @notice Distributes produces resource to all shareholders\r\n    /// @dev Useful to get full produced resources to all shareholders\r\n    function distributeToAllShareholders() external;\r\n\r\n    /// @notice Calculates amount of workers currently sitting in this building\r\n    /// @dev Same as workers.balanceOf(buildingAddress)\r\n    /// @return workersAmount Amount of workers currently sitting in this building\r\n    function getWorkers() external view returns (uint256 workersAmount);\r\n\r\n    /// @notice Calculates real amount of provided resource in building related to its production at provided time\r\n    /// @dev Useful for determination how much of production resource (either producing and spending) at the specific time\r\n    /// @param resourceName Name of resource related to production\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return resourcesAmount Real amount of provided resource in building related to its production at provided time\r\n    function getResourcesAmount(string memory resourceName, uint256 timestamp) external view returns (uint256 resourcesAmount);\r\n\r\n    /// @notice Calculates production resources changes at provided time\r\n    /// @dev Useful for determination how much of all production will be burned/produced at the specific time\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return productionResult Production resources changes at provided time\r\n    function getProductionResult(uint256 timestamp) external view returns (ProductionResultItem[] memory productionResult);\r\n\r\n    /// @notice Calculates upgrade price by provided level\r\n    /// @dev Useful for determination how much upgrade will cost at any level\r\n    /// @param level Level at which calculate price\r\n    /// @return price Amount of resources needed for upgrade\r\n    function getUpgradePrice(uint256 level) external view returns (uint256 price);\r\n\r\n    /// @notice Calculates basic upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getBasicUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Calculates advanced upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Starts basic building upgrade\r\n    /// @dev Resources required for upgrade will be taken from msg.sender\r\n    function startBasicUpgrade() external;\r\n\r\n    /// @notice Starts advanced building upgrade\r\n    /// @dev Resources required for upgrade will be taken from msg.sender\r\n    function startAdvancedUpgrade() external;\r\n\r\n    /// @notice Calculates current level\r\n    /// @dev Takes into an account if upgrades are finished or not\r\n    /// @return level Current building level\r\n    function getBuildingLevel() external view returns (uint256 level);\r\n\r\n    /// @notice Returns production config for current building\r\n    /// @dev Main config that determines which resources is produced/spend by production of this building\r\n    /// @dev InitialResourceBlock.perTick is value how much of resource is spend/produced by 1 worker in 1 second of production\r\n    /// @return initialResourceBlocks Production config for current building\r\n    function getConfig() external view returns (InitialResourceBlock[] memory initialResourceBlocks);\r\n\r\n    /// @notice Transfers workers from current building to specified address\r\n    /// @dev Currently workers can be transferred from building only to its settlement\r\n    /// @param to An address transfer workers to\r\n    /// @param amount Amount of workers to transfer\r\n    function transferWorkers(\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Transfer specified resource from current building\r\n    /// @dev Used for withdrawing resources from production or overcapped treasury resources\r\n    /// @param resourceName Name of resource to transfer\r\n    /// @param to An address transfer resources to\r\n    /// @param amount Amount of resources to transfer\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Batch resource transfer\r\n    /// @dev Same as #transferResources but for many resources at once\r\n    /// @param resourcesNames Names of resources to transfer\r\n    /// @param to An address transfer resources to\r\n    /// @param amounts Amounts of resources to transfer\r\n    function batchTransferResources(\r\n        string[] calldata resourcesNames,\r\n        address to,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n    /// @notice Calculates maximum amount of treasury by provided level\r\n    /// @dev Can be used to determine maximum amount of treasury by any level\r\n    /// @param level Building level\r\n    /// @param maxTreasury Maximum amount of treasury\r\n    function getMaxTreasuryByLevel(uint256 level) external view returns (uint256 maxTreasury);\r\n\r\n    /// @notice Steals resources from treasury\r\n    /// @dev Called by siege or building owner, in either case part of resources will be burned according to #registry.getRobberyFee\r\n    /// @param to An address which will get resources\r\n    /// @param amount Amount of resources to steal, 'to' will get only part of specified 'amount', some percent of specified 'amount' will be burned\r\n    /// @return realAmount Real amount of resources from which stealing occurred (min(amount, treasury))\r\n    function stealTreasury(\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (uint256 realAmount);\r\n\r\n    /// @notice Burns building treasury\r\n    /// @dev Can be called by world asset or building owner\r\n    /// @param amount Amount of resources to burn from treasury\r\n    function burnTreasury(\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Calculates maximum amount of workers\r\n    /// @dev Useful to determinate maximum amount of workers\r\n    /// @return workersAmount Maximum amount of workers\r\n    function getMaxWorkers() external view returns (uint256 workersAmount);\r\n\r\n    /// @notice Calculates producing resource name for this building\r\n    /// @dev Return value is value from #getConfig where 'isProduced'=true\r\n    /// @return resourceName Name of producing resource\r\n    function getProducingResourceName() external view returns (string memory resourceName);\r\n\r\n    /// @notice Calculates treasury amount at specified time\r\n    /// @dev Useful for determination how much treasury will be at specific time\r\n    /// @param timestamp Time at which calculate amount of treasury in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return treasury Treasury amount at specified time\r\n    function getTreasury(uint256 timestamp) external view returns (uint256 treasury);\r\n\r\n    /// @notice Calculates if building is capable to accept resource\r\n    /// @dev Return value based on #getConfig\r\n    /// @param resourceName Name of resource\r\n    /// @return isResourceAcceptable Is building can accept resource\r\n    function isResourceAcceptable(string memory resourceName) external view returns (bool isResourceAcceptable);\r\n\r\n    /// @notice Returns building name\r\n    /// @dev Same value as #assetName\r\n    /// @return buildingName Building name\r\n    function buildingName() external view returns (string memory buildingName);\r\n}\r\n"
    },
    "contracts/core/tokens/units/IUnitsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Units factory interface\r\n/// @notice Contains instance creator function\r\ninterface IUnitsFactory {\r\n    /// @notice Creates Unit instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param tokenName Name of the token\r\n    /// @param tokenSymbol Symbol of the token\r\n    /// @param worldUnitName Resource name in world configuration (WARRIOR/ARCHER/HORSEMAN)\r\n    /// @param epoch World epoch at which units will be created\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        string memory worldUnitName,\r\n        uint256 epoch\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/tokens/workers/IWorkersFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Worker factory interface\r\n/// @notice Contains instance creator function\r\ninterface IWorkersFactory {\r\n    /// @notice Creates Unit instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epoch World epoch at which workers will be created\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epoch\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/tokens/prosperity/IProsperityFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Prosperity factory interface\r\n/// @notice Contains instance creator function\r\ninterface IProsperityFactory {\r\n    /// @notice Creates Resource instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epoch World epoch at which prosperity will be created\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epoch\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/epoch/IEpochFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Epoch factory interface\r\n/// @notice Contains instance creator function\r\ninterface IEpochFactory {\r\n    /// @notice Creates Epoch instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the army type (Currently only 'BASIC')\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/crossEpochsMemory/ICrossEpochsMemory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\n/// @title Cross epoch memory interface\r\n/// @notice Functions to read state/modify state in order to get cross epoch memory parameters and/or interact with it\r\ninterface ICrossEpochsMemory {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing settlement by provided x and y coordinates\r\n    /// @dev Updated when #handleNewSettlement is called\r\n    function settlements(uint32 position) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #handleNewUserSettlement or #handleSettlementRestored is called\r\n    function userSettlements(uint256 val) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing count of user settlement by provided zone index\r\n    /// @dev Updated when #handleNewUserSettlement is called\r\n    function zoneUserSettlementsCount(uint256 zoneIndex) external view returns (uint256);\r\n\r\n    /// @notice Mapping containing settlement starting price by provided zone index\r\n    /// @dev Updated when #handleNewUserSettlement is called\r\n    function zoneSettlementStartingPrice(uint256 zoneIndex) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Settlement restoration handler\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param position Position at which restoration occurred\r\n    /// @param settlementAddress New settlement address\r\n    function handleUserSettlementRestored(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) external;\r\n\r\n    /// @notice New user settlement handler\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param zoneIndex Zone index\r\n    /// @param settlementAddress New settlement address\r\n    function handleNewUserSettlement(\r\n        uint256 ownerTokenId,\r\n        uint256 zoneIndex,\r\n        address settlementAddress,\r\n        uint256 newSettlementStartingPrice\r\n    ) external;\r\n\r\n    /// @notice New user settlement handler (including system ones, like CULTISTS)\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param position Position\r\n    /// @param settlementAddress New settlement address\r\n    function handleNewSettlement(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/core/tokens/resources/IResource.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current resource parameters and/or interact with it\r\ninterface IResource is IERC20Burnable, IERC20 {\r\n    /// @notice Returns state balance for specified token owner\r\n    /// @dev Current function returns value of balances 'as is', without recalculation (same as 'balanceOf' you would expect)\r\n    /// @param tokensOwner Tokens owner\r\n    /// @return balance Balance for token owner\r\n    function stateBalanceOf(address tokensOwner) external view returns (uint256 balance);\r\n\r\n    /// @notice Mints resource to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive resources\r\n    /// @param amount Amount of resources to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/assets/epoch/IEpoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Epoch interface\r\n/// @notice Functions to read state/modify state in order to get current epoch parameters and/or interact with it\r\ninterface IEpoch {\r\n    /// @notice Emitted when epoch resource is created\r\n    /// @param resourceAddress Resource address\r\n    /// @param resourceName Resource name\r\n    event NewResource(\r\n        address resourceAddress,\r\n        string resourceName\r\n    );\r\n\r\n    /// @notice Emitted when epoch units is created\r\n    /// @param unitsAddress Units address\r\n    /// @param unitsName Units name\r\n    event NewUnits(\r\n        address unitsAddress,\r\n        string unitsName\r\n    );\r\n\r\n    /// @notice Emitted when epoch workers is created\r\n    /// @param workersAddress Workers address\r\n    event NewWorkers(\r\n        address workersAddress\r\n    );\r\n\r\n    /// @notice Emitted when epoch prosperity is created\r\n    /// @param prosperityAddress Prosperity address\r\n    event NewProsperity(\r\n        address prosperityAddress\r\n    );\r\n\r\n    /// @notice Emitted when #activateZone is called\r\n    /// @param zoneAddress Zone address\r\n    /// @param zoneIndex Zone index\r\n    event NewZoneActivated(\r\n        address zoneAddress,\r\n        uint256 zoneIndex\r\n    );\r\n\r\n    /// @notice Emitted when #newAssetSettlement is called\r\n    /// @param contractAddress Created settlement address\r\n    /// @param scriptName Settlement type (BASIC/CULTISTS)\r\n    /// @param zoneAddress Address of the zone where settlement is created\r\n    /// @param position Position\r\n    event NewSettlement(\r\n        address indexed contractAddress,\r\n        string scriptName,\r\n        address zoneAddress,\r\n        uint32 position\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice An array of attached zones to the continent\r\n    /// @dev Updated when #attachZoneToTheContinent is called\r\n    function zones(uint256 index) external view returns (IZone);\r\n\r\n    /// @notice Mapping containing settlement by provided x and y coordinates\r\n    /// @dev Updated when new settlement is created\r\n    function settlements(uint32 position) external view returns (ISettlement);\r\n\r\n    /// @notice Most recent cultists summon time\r\n    /// @dev Updated when #increaseTotalCultists is called\r\n    function mostRecentCultistsSummonTime() external view returns (uint256);\r\n\r\n    /// @notice Total cultists\r\n    /// @dev Updated when #increaseTotalCultists or #decreaseTotalCultists is called\r\n    function totalCultists() external view returns (uint256);\r\n\r\n    /// @notice Workers token\r\n    /// @dev Updated when #setWorkersContract is called\r\n    function workers() external view returns (IWorkers);\r\n\r\n    /// @notice Prosperity token\r\n    /// @dev Updated when #setProsperityContract is called\r\n    function prosperity() external view returns (IProsperity);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #addUserSettlement is called\r\n    function userSettlements(uint256 val) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing game resources by name\r\n    /// @dev Updated when #addResource is called\r\n    function resources(string memory name) external view returns (IResource);\r\n\r\n    /// @notice Mapping containing units by name\r\n    /// @dev Updated when #addUnit is called\r\n    function units(string memory name) external view returns (IUnits);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param epochNumber Epoch number\r\n    function init(uint256 epochNumber) external;\r\n\r\n    /// @notice Creates zone with provided positions and tile types\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param zoneId Zone id\r\n    function activateZone(uint256 zoneId) external;\r\n\r\n    /// @notice Restores settlement from previous epoch by provided position\r\n    /// @dev Any address can restore user settlement\r\n    /// @param position Position\r\n    function restoreSettlement(\r\n        uint32 position\r\n    ) external;\r\n\r\n    /// @notice Creates new user settlement\r\n    /// @dev Bless tokens will be deducted from msg.sender\r\n    /// @param position Position\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param newSettlementStartingPrice New settlement starting price\r\n    /// @return settlementAddress Settlement address\r\n    function newSettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 newSettlementStartingPrice\r\n    ) external returns (address settlementAddress);\r\n\r\n    /// @notice Creates settlement by type\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param position Position\r\n    /// @param assetName Settlement type (BASIC/CULTISTS)\r\n    /// @param performAttachmentValidation Whether is to perform attachment validation or not (CULTISTS or restored BASIC may not be attached to anything)\r\n    function newAssetSettlement(\r\n        uint256 ownerTokenId,\r\n        uint32 position,\r\n        string memory assetName,\r\n        bool performAttachmentValidation\r\n    ) external returns (address);\r\n\r\n    /// @notice Summons cultists in specified zones\r\n    /// @dev Batch cultists summon\r\n    /// @param zoneIndices Zone indices\r\n    function summonCultistsBatch(\r\n        uint256[] memory zoneIndices\r\n    ) external;\r\n\r\n    /// @notice Increases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists minted\r\n    function increaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists burned\r\n    function decreaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/tokens/prosperity/IProsperity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../../token/IERC20Burnable.sol\";\r\nimport \"../../../token/IERC20Int.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current prosperity parameters and/or interact with it\r\ninterface IProsperity is IERC20Int, IERC20Burnable {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing amount of prosperity spend for workers buying\r\n    /// @dev Only settlements can spend prosperity for workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @return amount Amount of prosperity spend for workers buying\r\n    function prosperitySpent(address settlementAddress) external view returns (uint256 amount);\r\n\r\n    // Functions\r\n\r\n    /// @notice Spends prosperity for specified settlement address\r\n    /// @dev Called for settlement when settlement is buying workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @param amount Amount of prosperity spend for workers buying\r\n    function spend(address settlementAddress, uint256 amount) external;\r\n\r\n    /// @notice Mints prosperity to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive prosperity\r\n    /// @param amount Amount of prosperity to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/tokens/units/IUnits.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Units interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IUnits is IERC20Burnable, IERC20 {\r\n    // State variables\r\n\r\n    /// @notice Epoch number\r\n    /// @dev Immutable, initialized on creation\r\n    function epochNumber() external returns (uint256);\r\n\r\n    /// @notice Name of the unit inside epoch.units\r\n    /// @dev Immutable, initialized on creation\r\n    function worldUnitName() external returns (string memory);\r\n\r\n    // Functions\r\n\r\n    /// @notice Mints units to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive units\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/geography/IGeography.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\ninterface IGeography {\r\n    enum TileType {\r\n        VOID, //0\r\n        SAND, //1\r\n        ROAD, //2\r\n        GRASS, //3\r\n        SWAMP, //4\r\n        WATER //5\r\n    }\r\n\r\n    struct GameTile {\r\n        uint16 zoneId;\r\n        uint16 tileType;\r\n    }\r\n\r\n    struct ZoneActivationParams {\r\n        uint32 cultistsPosition;\r\n    }\r\n\r\n    /// @notice Emitted when #_createZone is called\r\n    /// @param zoneIndex Zone index\r\n    /// @param positions Positions\r\n    /// @param tileTypes Tile types\r\n    /// @param cultistsPosition Cultists position\r\n    event NewZoneCreated(\r\n        uint256 zoneIndex,\r\n        uint32[] positions,\r\n        uint16[] tileTypes,\r\n        uint256 cultistsPosition\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Mapping containing packed tiles by specified slot number\r\n    /// @dev Each returned element is is packed GameTile structures (8 per slot). Updated when zone is created\r\n    function packedGameTileMap(uint32 slotNumber) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Returns created zones length\r\n    /// @dev Updated when #createZone is called\r\n    /// @return zonesLength Zones length\r\n    function getZonesLength() external view returns (uint256 zonesLength);\r\n\r\n    /// @notice Validates provided path\r\n    /// @dev Useful for determining positions path according to current hex grid\r\n    /// @param path Path\r\n    /// @return isValid Is path valid\r\n    function isPathValid(uint32[] memory path) external view returns (bool isValid);\r\n\r\n    /// @notice Calculates if provided position are neighbor to other position\r\n    /// @param position Provided position\r\n    /// @param neighbor Other position\r\n    /// @param isNeighbor Is other position neighbor to provided position\r\n    function isNeighborTo(uint32 position, uint32 neighbor) external pure returns (bool isNeighbor);\r\n\r\n    /// @notice Calculates gameTile structure from provided position\r\n    /// @param position Provided position\r\n    /// @return gameTile Game tile struct\r\n    function getGameTile(uint32 position) external view returns (GameTile memory gameTile);\r\n\r\n    /// @notice Calculates all ring positions by provided position and radius\r\n    /// @param position Position\r\n    /// @param radius Ring radius\r\n    /// @return ringPositions Ring positions\r\n    /// @return ringPositionsLength Ring positions length (array is initialized 6 * radius, however not all values should be used)\r\n    function getRingPositions(uint32 position, uint256 radius) external pure returns (uint32[] memory ringPositions, uint256 ringPositionsLength);\r\n\r\n    /// @notice Creates zone with provided positions and tile types\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param positions Zone positions\r\n    /// @param tileTypes Zone tile types\r\n    /// @param cultistsCoordinateIndex Coordinate index inside 'positions', where cultists will be placed\r\n    function createZone(\r\n        uint32[] memory positions,\r\n        uint16[] memory tileTypes,\r\n        uint256 cultistsCoordinateIndex\r\n    ) external;\r\n\r\n    /// @notice Returns zone activation params for provided zone index\r\n    /// @dev New values are accessible when #createZone is called\r\n    /// @param zoneIndex Zone index\r\n    /// @return params Zone activation params struct\r\n    function getZoneActivationParams(uint256 zoneIndex) external view returns (ZoneActivationParams memory params);\r\n}\r\n"
    },
    "contracts/core/rewardPool/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IRewardPool {\r\n    // State variables\r\n\r\n    /// @notice Represents how much of weapons must be given for one unit of token\r\n    /// @dev Updated when #handleEpochDestroyed is called\r\n    function ratio() external view returns (int256);\r\n\r\n    /// @notice Represents how much bless tokens must be repaid first to the mighty creator\r\n    /// @dev Updated when #investIntoPrizePool is called\r\n    function invested() external view returns (uint256);\r\n\r\n    /// @notice Represents last reward pool total balance after repayment and function(s) are done\r\n    /// @dev Updated when #investIntoPrizePool or #handleEpochDestroyed or #swapWeaponsForTokens or #withdrawRepayment are called\r\n    function lastBalance() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Handler of epoch destruction\r\n    /// @dev Must be called when epoch is destroyed\r\n    function handleEpochDestroyed() external;\r\n\r\n    /// @notice Swap provided amount of weapons\r\n    /// @dev Weapons will be deducted from msg.sender\r\n    /// @param weaponsAmount Amount of weapons to swap\r\n    function swapWeaponsForTokens(uint256 weaponsAmount) external;\r\n\r\n    /// @notice Invests specified amount of tokens into prize pool\r\n    /// @dev Bless tokens must be sent to this function (if its type=eth) or will be deducted from msg.sender (if its type=erc20)\r\n    /// @param amountToInvest Amount of tokens to invest\r\n    function investIntoPrizePool(uint256 amountToInvest) external payable;\r\n\r\n    /// @notice Withdraws potential bless token added balance to the mighty creator\r\n    /// @dev Triggers withdraw of potential added balance\r\n    function withdrawRepayment() external;\r\n}\r\n"
    },
    "contracts/core/distributions/IDistributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"../IWorld.sol\";\r\n\r\ninterface IDistributions is IERC1155 {\r\n    // State variables\r\n\r\n    /// @notice World\r\n    /// @dev Immutable, initialized on creation\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Mapping containing distribution id to assigned building address\r\n    /// @dev Updated when #mint is called\r\n    function distributionIdToBuildingAddress(uint256 distributionId) external view returns (address);\r\n\r\n    /// @notice Last nft token id\r\n    /// @dev Updated when #mint is called\r\n    function lastDistributionId() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Returns set of receivers as an array\r\n    /// @dev\r\n    /// @param distributionId Distribution id\r\n    /// @return receivers An array of receivers\r\n    function getDistributionReceivers(uint256 distributionId) external view returns (address[] memory receivers);\r\n\r\n    /// @notice Mints new distribution Nft to specified address\r\n    /// @dev Can be called only by world asset from active epoch\r\n    /// @param to An address which will receive new nft\r\n    /// @return newDistributionId Newly minted distribution id\r\n    function mint(address to) external returns (uint256 newDistributionId);\r\n\r\n    /// @notice Returns items per nft\r\n    /// @dev Used to determine percent holdings\r\n    /// @return itemsPerNft Items per nft\r\n    function getItemsPerNft() external pure returns (uint256 itemsPerNft);\r\n}\r\n"
    },
    "contracts/core/assets/settlement/ISettlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../building/IBuilding.sol\";\r\nimport \"../army/IArmy.sol\";\r\nimport \"../siege/ISiege.sol\";\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Settlement interface\r\n/// @notice Functions to read state/modify state in order to get current settlement parameters and/or interact with it\r\ninterface ISettlement {\r\n    /// @notice Emitted when new building is placed, all building are placed on settlement creation\r\n    /// @param contractAddress New building address\r\n    /// @param scriptName Building name\r\n    event NewBuilding(address contractAddress, string scriptName);\r\n\r\n    /// @notice Emitted when settlements army is created, is it created on settlement creation\r\n    /// @param armyAddress New army address\r\n    /// @param position Position\r\n    event NewArmy(address armyAddress, uint32 position);\r\n\r\n    /// @notice Emitted when siege is created on settlement if not present. During settlements lifetime multiple sieges can be created (one after another, not multiple simultaneously)\r\n    /// @param siegeAddress New siege address\r\n    event SiegeCreated(address indexed siegeAddress);\r\n\r\n    /// @notice Emitted when #addGovernor or #removeGovernor is called\r\n    /// @param currentEpoch Current governor epoch\r\n    /// @param governorAddress Address of the governor event is applicable\r\n    /// @param status Is governor became active/inactive\r\n    event GovernorChanged(uint256 indexed currentEpoch, address indexed governorAddress, bool status);\r\n\r\n    /// @notice Emitted when #removeGovernors is called\r\n    /// @param currentEpoch New governor epoch\r\n    event NewSettlementEpoch(uint256 currentEpoch);\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Banner token id to which current settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function ownerTokenId() external view returns (uint256);\r\n\r\n    /// @notice Siege of the settlement\r\n    /// @dev If any army is sieging settlement not address(0), otherwise address(0)\r\n    function siege() external view returns (ISiege);\r\n\r\n    /// @notice Mapping containing settlements buildings\r\n    /// @dev Types of buildings supported can be queried from registry\r\n    function buildings(string memory buildingName) external view returns (IBuilding);\r\n\r\n    /// @notice Current governors epoch\r\n    /// @dev Modified when #removeGovernors is called\r\n    function currentGovernorsEpoch() external view returns (uint256);\r\n\r\n    /// @notice Current settlements governors\r\n    /// @dev Modified when #addGovernor or #removeGovernor is called\r\n    function governors(uint256 epoch, address isGovernor) external view returns (bool);\r\n\r\n    /// @notice Settlements army\r\n    /// Immutable, initialized on the settlement creation\r\n    function army() external view returns (IArmy);\r\n\r\n    /// @notice Extra prosperity amount gained from demilitarization of any army on this settlement\r\n    /// @dev Used for determination amount of real prosperity this settlement has\r\n    function extraProsperity() external view returns (uint256);\r\n\r\n    /// @notice Position on which settlement is created\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function position() external view returns (uint32);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param createdWithOwnerTokenId Banner token id to which current settlement belongs\r\n    /// @param zoneAddress Zone address to which this settlement belongs\r\n    /// @param settlementPosition Position on which settlement is created\r\n    function init(\r\n        uint256 createdWithOwnerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) external;\r\n\r\n    /// @notice Transfers workers from settlement to building\r\n    /// @dev Amount of workers to transfer is in 1e18 precision, however only integer amount can be transferred\r\n    /// @param buildingAddress Address of the building transfer workers to\r\n    /// @param amount Amount of workers to transfer\r\n    function transferWorkers(address buildingAddress, uint256 amount) external;\r\n\r\n    /// @notice Transfers game resource from settlement to specified address\r\n    /// @dev In case if someone accidentally transfers game resource to the settlement\r\n    /// @param resourceName Game resource name\r\n    /// @param to Address that will receive resources\r\n    /// @param amount Amount to transfer\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Creates new building\r\n    /// @dev All buildings are created on settlement creation\r\n    /// @param buildingName Building name\r\n    /// @return buildingAddress Address of created building\r\n    function newBuilding(string memory buildingName) external returns (address buildingAddress);\r\n\r\n    /// @notice Calculates current fort health and damage dealt at specified timestamp\r\n    /// @dev Uses fort production and siege parameters to forecast health and damage will be dealt at specified time\r\n    /// @param timestamp Time at which calculate parameters\r\n    /// @return currentHealth Health value at specified time\r\n    /// @return damage Amount of damage dealt from fort.production.lastUpdateState to specified timestamp\r\n    function calculateCurrentHealthAndDamage(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (uint256 currentHealth, uint256 damage);\r\n\r\n    /// @notice Updates settlement health to current block\r\n    /// @dev Can be called by everyone\r\n    function updateCurrentHealth() external;\r\n\r\n    /// @notice Creates empty siege\r\n    /// @dev Can be called by everyone\r\n    function createSiege() external;\r\n\r\n    /// @notice Updates fort health\r\n    /// @dev Even though function is opened it can be called only by world or world asset\r\n    /// @param healthDiff Health delta between current value and new value\r\n    /// @param isProduced Banner, whether health is produced or removed\r\n    function updateFortHealth(uint256 healthDiff, bool isProduced) external;\r\n\r\n    /// @notice Harvests all buildings\r\n    /// @dev Can be used by everyone\r\n    function massUpdate() external;\r\n\r\n    /// @notice Calculates current prosperity at specified timestamp\r\n    /// @dev Uses buildings productions to forecast amount of prosperity will settlement will have at specified time\r\n    /// @param timestamp Time at which calculate current prosperity\r\n    /// @return currentProsperity Amount of prosperity at specified time\r\n    function accumulatedCurrentProsperity(uint256 timestamp) external view returns (int256 currentProsperity);\r\n\r\n    /// @notice Calculates total siege power presented at current time\r\n    /// @dev Updated when army add/remove units from siege\r\n    /// @return currentSiegePower Amount of total siege power at current time\r\n    function getCurrentSiegePower() external view returns (uint256 currentSiegePower);\r\n\r\n    /// @notice Calculates current settlement owner\r\n    /// @dev Settlements owner is considered an address, which holds ownerTokenId NFT\r\n    /// @return settlementOwner Settlement owner\r\n    function getSettlementOwner() external view returns (address settlementOwner);\r\n\r\n    /// @notice Calculates whether provided address is settlement ruler or not\r\n    /// @dev Settlements ruler is an address which owns settlement or an address(es) by which settlement is/are governed\r\n    /// @param potentialRuler Address to check\r\n    /// @return isRuler Banner, whether specified address is ruler or not\r\n    function isRuler(address potentialRuler) external view returns (bool isRuler);\r\n\r\n    /// @notice Extends current settlement prosperity by specified amount\r\n    /// @dev Even though function is opened it can be called only by world or world asset\r\n    /// @param prosperityAmount Amount of prosperity to which extend current prosperity\r\n    function extendProsperity(uint256 prosperityAmount) external;\r\n}\r\n"
    },
    "contracts/core/assets/army/IArmy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../siege/ISiege.sol\";\r\n\r\n/// @title Army interface\r\n/// @notice Functions to read state/modify state in order to get current army parameters and/or interact with it\r\ninterface IArmy {\r\n    struct MovementTiming {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n    }\r\n\r\n    struct StunTiming {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n    }\r\n\r\n    /// @notice Emitted when #burnUnits is called (#demilitarize or #exitBattle)\r\n    /// @param unitName Name of the unit type\r\n    /// @param value New amount of unit type presented in army\r\n    event UnitsChanged(string unitName, uint256 value);\r\n\r\n    /// @notice Emitted when #updatePosition is called (even though event can be emitted only on the next action related to the current army, de-facto army will update position based on 'movementTiming.endTime'\r\n    /// @param settlementAddress Address of the settlement where army currently staying on\r\n    /// @param position Position\r\n    event UpdatedPosition(address settlementAddress, uint32 position);\r\n\r\n    /// @notice Emitted when #newBattle is called. Army which attacks another army will emit this event.\r\n    /// @param battleAddress Created battle address\r\n    /// @param targetArmyAddress Address of the attacked army\r\n    event NewBattle(address battleAddress, address targetArmyAddress);\r\n\r\n    /// @notice Emitted when army joins battle. At the battle creation both armies (attacker and attacked) will emit this event. Attacker army will be side A and at attacked army will be sideB\r\n    /// @param battleAddress Address of the battle army joined in\r\n    /// @param side Side to which army joined (sideA = 1, sideB = 2)\r\n    event JoinedBattle(address indexed battleAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #updateState is called (even though event can be emitted only on the next action related to the current army, de-facto army will exit battle when battle is finished)\r\n    /// @param battleAddress Address of the battle army was in\r\n    event ExitedFromBattle(address battleAddress);\r\n\r\n    /// @notice Emitted when #move is called\r\n    /// @param destinationSettlement Address of the settlement army is moving to\r\n    /// @param movementStartTime Time at which movement began\r\n    /// @param movementFinishTime Time at which movement will end\r\n    /// @param path The path army is taken from starting position to destination position\r\n    event MovingTo(\r\n        address indexed destinationSettlement,\r\n        uint256 indexed movementStartTime,\r\n        uint256 indexed movementFinishTime,\r\n        uint32[] path\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this army belongs\r\n    /// @dev Immutable, initialized on the army creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Position where army currently stands on\r\n    /// @dev Updated when army updates position. It does not take into account if army is moving\r\n    /// @dev To proper query current position use #getCurrentPosition\r\n    function currentPosition() external view returns (uint32);\r\n\r\n    /// @notice Position to which are is moving to\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    /// @dev To proper calculate destination position you need to check if army finished movement by comparing current time and movementTiming.endTime\r\n    function destinationPosition() external view returns (uint32);\r\n\r\n    /// @notice Battle in which army is on\r\n    /// @dev If army is not in battle returns address(0). It does not take into account if battle is finished but army is not left the battle\r\n    function battle() external view returns (IBattle);\r\n\r\n    /// @notice Siege in which are army is on\r\n    /// @dev If army is not in siege returns address(0)\r\n    function siege() external view returns (ISiege);\r\n\r\n    /// @notice Movement timings\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    function movementTiming() external view returns (uint64 startTime, uint64 endTime);\r\n\r\n    /// @notice Stun timings\r\n    /// @dev Updated when army finishes move or when army loses battle\r\n    function stunTiming() external view returns (uint64 startTime, uint64 endTime);\r\n\r\n    /// @notice Path army is taken during movement\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    /// @dev To proper query entire movementPath use #getMovementPath\r\n    function movementPath(uint256 index) external view returns (uint32);\r\n\r\n    /// @notice Time at which last demilitarization occured\r\n    /// @dev Updated when #demilitarize is called\r\n    function lastDemilitarizationTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Path army is taken during movement\r\n    /// @dev Useful to get entire movement path rather than querying each path item by index. It does not take into account if army is finished move by time\r\n    /// @return path Entire path army is taken during movement\r\n    function getMovementPath() external view returns (uint32[] memory path);\r\n\r\n    /// @notice Updates army state to the current block\r\n    /// @dev Called on every action which are based on army state and time\r\n    function updateState() external;\r\n\r\n    /// @notice Initiates army movement to the settlement\r\n    /// @dev Even though path can be provided artificial only allowed movement to a settlement\r\n    /// @param path Path army will take to the settlement\r\n    /// @param foodToSpendOnFeeding Amount of food army will take from current position settlements FARM in order to decrease total time army will take to get to destination position\r\n    function move(uint32[] memory path, uint256 foodToSpendOnFeeding) external;\r\n\r\n    /// @notice Demilitarizes part of the army. Demilitarization provides prosperity to the settlement army is currently staying on\r\n    /// @dev Even though demilitarization of 0 units may seem reasonable, it is disabled\r\n    /// @param unitNames Names of the unit types for demilitarization\r\n    /// @param unitsCount Amount of units for demilitarization for every unit type\r\n    function demilitarize(string[] memory unitNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Sets battle\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param battleAddress Battle address\r\n    function setBattle(address battleAddress) external;\r\n\r\n    /// @notice Initiates battle with another army is both are not in battle\r\n    /// @dev Creates IBattle and sets both armies in created battle\r\n    /// @param armyAddress Address of the army this army will attack\r\n    /// @param maxUnitTypesToAttack Max units types to attack\r\n    /// @param maxUnitsToAttack Max units to attack\r\n    function newBattle(\r\n        address armyAddress,\r\n        string[] calldata maxUnitTypesToAttack,\r\n        uint256[] calldata maxUnitsToAttack\r\n    ) external;\r\n\r\n    /// @notice Joins current army in battle to the provided side\r\n    /// @dev Moving army is able to join battle only if caller is another army (drags it into battle)\r\n    /// @param battleAddress Battle address army will join\r\n    /// @param side Side of the battle army will join (sideA = 1, sideB = 2)\r\n    function joinBattle(address battleAddress, uint256 side) external;\r\n\r\n    /// @notice Burns units from the army\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypes Unit types for burning\r\n    /// @param unitAmounts Amount of units for burning for every unit type\r\n    function burnUnits(string[] memory unitTypes, uint256[] memory unitAmounts) external;\r\n\r\n    /// @notice Calculates current position taking to the account #movementTimings\r\n    /// @dev This method should be used to determine real army position\r\n    /// @return position Position\r\n    function getCurrentPosition() external view returns (uint32 position);\r\n\r\n    /// @notice Sets and withdraw units to/from siege\r\n    /// @dev Provides ability to atomically setup/re-setup siege\r\n    /// @param addUnitsNames Names of the unit types to put in siege\r\n    /// @param addUnitsCount Amount of units to put in siege for every unit type\r\n    /// @param removeUnitsNames Names of the unit types to withdraw from siege\r\n    /// @param removeUnitsCount Amount of units to withdraw from siege for every unit type\r\n    function setUnitsInSiege(\r\n        string[] memory addUnitsNames,\r\n        uint256[] memory addUnitsCount,\r\n        string[] memory removeUnitsNames,\r\n        uint256[] memory removeUnitsCount\r\n    ) external;\r\n\r\n    /// @notice Swaps accumulated robbery tokens in siege for resource\r\n    /// @dev Amount of points will be taken may be lesser if building does not have resources in its treasury\r\n    /// @param buildingAddress Address of the building treasury of which will be robbed\r\n    /// @param points Amount of points to spend for resources\r\n    function claimResources(address buildingAddress, uint256 points) external;\r\n\r\n    /// @notice Calculates total siege support of the army\r\n    /// @dev For every unit type placed in siege calculates sum of all of them\r\n    /// @return totalSiegeSupport Total siege support of the army\r\n    function getTotalSiegeSupport() external view returns (uint256 totalSiegeSupport);\r\n\r\n    /// @notice Sets siege\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param siegeAddress Siege address\r\n    function setSiege(address siegeAddress) external;\r\n\r\n    /// @notice Return owner of the army\r\n    /// @dev Same as owner of the settlement to which this army belongs\r\n    /// @return ownerAddress Address of the owner of the army\r\n    function getOwner() external view returns (address ownerAddress);\r\n\r\n    /// @notice Calculates is army on its home position\r\n    /// @dev Takes into account if army movement is finished\r\n    /// @return isHomePosition Is army on home position\r\n    function isHomePosition() external view returns (bool isHomePosition);\r\n}\r\n"
    },
    "contracts/core/assets/siege/ISiege.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Siege interface\r\n/// @notice Functions to read state/modify state in order to get current siege parameters and/or interact with it\r\ninterface ISiege {\r\n    struct ArmyInfo {\r\n        uint256 rewardDebt;\r\n        uint256 points;\r\n    }\r\n\r\n    /// @notice Emitted when #addUnits is called\r\n    /// @param from Army address which adds units\r\n    /// @param settlement Settlement address of related siege\r\n    /// @param unitsNames Unit types which were added\r\n    /// @param unitsCount Counts of units which were added\r\n    event UnitsAdded(address indexed from, address indexed settlement, string[] unitsNames, uint256[] unitsCount);\r\n\r\n    /// @notice Emitted when #withdrawUnits is called\r\n    /// @param to Army address which receives back its units\r\n    /// @param settlement Settlement address of related siege\r\n    /// @param unitsNames Unit types which were withdrawn\r\n    /// @param unitsCount Counts of units which were withdrawn\r\n    event UnitsWithdrawn(address indexed to, address indexed settlement, string[] unitsNames, uint256[] unitsCount);\r\n\r\n    /// @notice Emitted when #addUnits or #withdrawUnits is called in order to preserve previous amount of points were farmed by the army with previous speed\r\n    /// @param armyAddress Army address which received siege points\r\n    /// @param pointsReceived Amount of points received\r\n    event PointsReceived(address indexed armyAddress, uint256 pointsReceived);\r\n\r\n    /// @notice Emitted when #claimResources is called\r\n    /// @param armyAddress Army address which spent siege points\r\n    /// @param pointsSpent Amount of points spent\r\n    event PointsSpent(address indexed armyAddress, uint256 pointsSpent);\r\n\r\n    /// @notice Emitted when #liquidate is called, emitted for every unit type that was liquidated\r\n    /// @param armyAddress Army address which was liquidated\r\n    /// @param unitName Unit type\r\n    /// @param unitsLiquidated Amount of units liquidated\r\n    event Liquidated(address armyAddress, string unitName, uint256 unitsLiquidated);\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this siege belongs\r\n    /// @dev Immutable, initialized on the siege creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing army information related to current siege\r\n    /// @dev Updated when #addUnits, #withdrawUnits, #claimResource, #liqudate is called\r\n    function armyInfo(address armyAddress) external view returns (uint256 rewardDebt, uint256 points);\r\n\r\n    /// @notice Mapping containing amount of stored units in siege for specified army\r\n    /// @dev Updated when #addUnits, #withdrawUnits, #liqudate is called\r\n    function storedUnits(address armyAddress, string memory unitName) external view returns (uint256);\r\n\r\n    /// @notice Last time at which siege was updated\r\n    /// @dev Updated when siege parameters related to pointsPerShare were changed\r\n    function lastUpdate() external view returns (uint256);\r\n\r\n    /// @notice Amount of point per share\r\n    /// @dev Updated when siege parameters related to armies were changed\r\n    function pointsPerShare() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Updates current siege to the current state\r\n    /// @dev Synchronizes health up to current state, produces points for besieging armies\r\n    function update() external;\r\n\r\n    /// @notice Claims resources for specified points from building related to siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param buildingAddress Address of building to rob\r\n    /// @param points Amount of points to spend for robbing\r\n    function claimResources(address buildingAddress, uint256 points) external;\r\n\r\n    /// @notice Calculates total damage for provided period of time\r\n    /// @param period Time period to use to calculate damage\r\n    /// @return damage Total damage for provided period of time\r\n    function getTotalDamageByPeriod(uint256 period) external view returns (uint256 damage);\r\n\r\n    /// @notice Calculates total damage for period from lastUpdate and block.timestamp\r\n    /// @return damage Total damage for last period\r\n    function getTotalDamageLastPeriod() external view returns (uint256 damage);\r\n\r\n    /// @notice Updates siege with new amount of damage fort taken\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    function systemUpdate(uint256 totalDamage) external;\r\n\r\n    /// @notice Adds units to siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param unitsNames Unit types which will be added to siege\r\n    /// @param unitsCount Amounts of units will be added to siege\r\n    function addUnits(string[] memory unitsNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Withdraws units from siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param unitsNames Unit types which will be withdrawn to siege\r\n    /// @param unitsCount Amounts of units will be withdrawn to siege\r\n    function withdrawUnits(string[] memory unitsNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Calculates if provided army address can be liquidated from current siege\r\n    /// @dev Does not take into an account if army's battle is finished and army isn't left the battle\r\n    /// @param armyAddress Address of the army\r\n    /// @return canLiquidate Can army be liquidated from current siege\r\n    function canLiquidate(address armyAddress) external view returns (bool canLiquidate);\r\n\r\n    /// @notice Calculates amount of points army will have at specified time\r\n    /// @dev If timestamp=0, returns value as if timestamp=block.timestamp\r\n    /// @param armyAddress Address of the army\r\n    /// @param timestamp Time at which calculate points\r\n    /// @return points Amount of points army will have at specified time\r\n    function getUserPointsOnTime(address armyAddress, uint256 timestamp) external view returns (uint256 points);\r\n\r\n    /// @notice Returns amount of stored units for specified army in siege\r\n    /// @dev Function returns only amounts without types, index in returned array for each unit type is same as in 'registry.getUnits'\r\n    /// @param armyAddress Address of the army\r\n    /// @return units Amount of units that army has in siege\r\n    function getStoredUnits(address armyAddress) external view returns (uint256[] memory units);\r\n\r\n    /// @notice Calculates total siege stats\r\n    /// @dev Values are calculated for all armies that are present in siege\r\n    /// @return power Total power that placed into siege\r\n    /// @return supply Total supply that siege has\r\n    function calculateTotalSiegeStats() external view returns (uint256 power, uint256 supply);\r\n\r\n    /// @notice Liquidates army\r\n    /// @dev Can be called by anyone, caller will receive a reward\r\n    /// @param armyAddress Address of army to liquidate\r\n    function liquidate(address armyAddress) external;\r\n\r\n    /// @notice Calculates amount of points army has\r\n    /// @dev Uses block.timestamp at #getUserPointsOnTime\r\n    /// @param armyAddress Address of army\r\n    /// @return points Amount of points army has\r\n    function getUserPoints(address armyAddress) external returns (uint256 points);\r\n\r\n    /// @notice Calculates army siege stats\r\n    /// @dev Values are calculated for specified army that is present in siege\r\n    /// @param armyAddress Address of army\r\n    /// @return power Total power that army has\r\n    /// @return supply Total supply that army has\r\n    function calculateArmySiegeStats(address armyAddress) external returns (uint256 power, uint256 supply);\r\n}\r\n"
    },
    "contracts/core/assets/zone/IZone.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../workersPool/IWorkersPool.sol\";\r\nimport \"../epoch/IEpoch.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../settlementsMarket/ISettlementMarket.sol\";\r\n\r\n/// @title Zone interface\r\n/// @notice Functions to read state/modify state in order to get current zone parameters and/or interact with it\r\ninterface IZone {\r\n    /// @notice Emitted when zone initialized\r\n    /// @param workersPoolAddress Workers pool address\r\n    event WorkersPoolCreated(address workersPoolAddress);\r\n\r\n    /// @notice Emitted when zone initialized\r\n    /// @param settlementsMarketAddress Settlements market address\r\n    event SettlementsMarketCreated(address settlementsMarketAddress);\r\n\r\n    /// @notice Emitted when zone initialized\r\n    /// @param unitsPoolAddress Units pool address\r\n    /// @param unitType Unit type\r\n    event UnitsPoolCreated(address unitsPoolAddress, string unitType);\r\n\r\n    /// @notice Emitted when #increaseToxicity is called\r\n    /// @param settlementAddress An address of settlement which triggered toxicity increase\r\n    /// @param value Amount of added toxicity\r\n    event ToxicityIncreased(address settlementAddress, uint256 value);\r\n\r\n    /// @notice Emitted when #decreaseToxicity is called\r\n    /// @param settlementAddress An address of settlement which triggered toxicity decrease\r\n    /// @param value Amount of subtracted toxicity\r\n    event ToxicityDecreased(address settlementAddress, uint256 value);\r\n\r\n    /// @notice Emitted when #updateState is called\r\n    /// @param lastUpdateStateTime Time at which zone time changed\r\n    /// @param lastUpdateStateZoneTime Current zone time\r\n    event ZoneTimeChanged(uint256 lastUpdateStateTime, uint256 lastUpdateStateZoneTime);\r\n\r\n    // State variables\r\n\r\n    /// @notice Workers pool\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function workersPool() external view returns (IWorkersPool);\r\n\r\n    /// @notice Mapping containing units pool for provided unit type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function unitsPools(string memory unitName) external view returns (IUnitsPool);\r\n\r\n    /// @notice Mapping containing units market for provided unit type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function settlementsMarket() external view returns (ISettlementsMarket);\r\n\r\n    /// @notice Cultists settlement of this zone\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function cultistsSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Last time cultists were summoned in this zone\r\n    /// @dev Updated when #summonCultists is called\r\n    function cultistsSummonTime() external view returns (uint256);\r\n\r\n    /// @notice Amount of toxicity in this zone\r\n    /// @dev Updated when #increaseToxicity or #decreaseToxicity is called\r\n    function toxicity() external view returns (int256);\r\n\r\n    /// @notice Zone index\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function zoneIndex() external view returns (uint256);\r\n\r\n    /// @notice Last apply state time\r\n    /// @dev Updated when #updateState is called\r\n    function lastUpdateStateTime() external view returns (uint256);\r\n\r\n    /// @notice Last apply state zone time\r\n    /// @dev Updated when #updateState is called\r\n    function lastUpdateStateZoneTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneIndex Zone index\r\n    function init(uint256 zoneIndex) external;\r\n\r\n    /// @notice Creates cultists settlement\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsPosition Cultists position\r\n    function createCultists(uint32 cultistsPosition) external;\r\n\r\n    /// @notice Buys specified units for specified amount of weapons in current zone\r\n    /// @dev msg.sender will be used as weapons payer\r\n    /// @param settlementAddress Settlement's address army of which will receive units\r\n    /// @param unitNames Unit types\r\n    /// @param unitsCounts Units counts\r\n    /// @param maxWeaponsToSell Maximum amounts of weapons to sell for each unit types\r\n    function buyUnitsBatch(\r\n        address settlementAddress,\r\n        string[] memory unitNames,\r\n        uint256[] memory unitsCounts,\r\n        uint256[] memory maxWeaponsToSell\r\n    ) external;\r\n\r\n    /// @notice Summons cultists if conditions are met\r\n    /// @dev Anyone can call this function\r\n    function summonCultists() external;\r\n\r\n    /// @notice Increases toxicity relative to specified resources amount\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered toxicity increase\r\n    /// @param resourceName Resource name\r\n    /// @param value Amount of resource\r\n    function increaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases toxicity relative to specified resources amount\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered toxicity decrease\r\n    /// @param resourceName Resource name\r\n    /// @param value Amount of resource\r\n    function decreaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Zone cultists summon handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists minted\r\n    function handleCultistsSummoned(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Zone cultists defeat handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists burned\r\n    function handleCultistsDefeated(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Calculates penalty according to current cultists count\r\n    /// @dev Uses unit.balanceOf to determine penalty\r\n    /// @return penalty Penalty from cultists\r\n    function getPenaltyFromCultists() external view returns (uint256 penalty);\r\n\r\n    /// @notice Updates zone state\r\n    /// @dev This function is called every time when production should be modified\r\n    function updateState() external;\r\n\r\n    /// @notice Calculates zone time with provided timestamp\r\n    /// @dev Takes into an account previous value and current cultists penalty and extrapolates to value at provided timestamp\r\n    /// @param timestamp Timestamp\r\n    /// @return zoneTime Extrapolated zone time\r\n    function getZoneTime(uint256 timestamp) external view returns (uint256 zoneTime);\r\n}\r\n"
    },
    "contracts/core/assets/battle/IBattle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\n\r\n/// @title Battle interface\r\n/// @notice Functions to read state/modify state in order to get current battle parameters and/or interact with it\r\ninterface IBattle {\r\n    struct Timing {\r\n        uint64 creationTime;\r\n        uint64 lobbyDuration;\r\n        uint64 ongoingDuration;\r\n        uint64 finishTime;\r\n    }\r\n\r\n    /// @notice Emitted when army joined battle\r\n    /// @param armyAddress Address of the joined army\r\n    /// @param side Side to which army is joined (sideA = 1, sideB = 2)\r\n    event ArmyJoined(address armyAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #finishBattle is called\r\n    /// @param finishTime Time at which battle is finished\r\n    event BattleFinished(uint256 finishTime);\r\n\r\n    // State variables\r\n\r\n    /// @notice Position at which battle is being held\r\n    /// @dev Immutable, initialized on the battle creation\r\n    function position() external view returns (uint32);\r\n\r\n    /// @notice An array of armies joined to side A\r\n    /// @dev Updated when army joins side A\r\n    /// @param index Index inside the array\r\n    /// @return armyAddress Army address at the specified index\r\n    function sideA(uint256 index) external view returns (address armyAddress);\r\n\r\n    /// @notice An array of armies joined to side B\r\n    /// @dev Updated when army joins side B\r\n    /// @param index Index inside the array\r\n    /// @return armyAddress Army address at the specified index\r\n    function sideB(uint256 index) external view returns (address armyAddress);\r\n\r\n    /// @notice Mapping that contains units amount by side and unit type\r\n    /// @dev Updated when army joins side\r\n    /// @param side Side of which query units amount (sideA = 1, sideB = 2)\r\n    /// @param unitName Unit type to query\r\n    /// @return unitsCount Amount of units by specified side and unit type\r\n    function sideUnitsCount(uint256 side, string memory unitName) external view returns (uint256 unitsCount);\r\n\r\n    /// @notice Mapping that contains amount of units by army address and unit type\r\n    /// @dev Updated when army joins battle\r\n    /// @param armyAddress Address of the army\r\n    /// @param unitName Unit type to query\r\n    /// @return unitsCount Amount of units by army address and unit type\r\n    function armyUnitsCount(address armyAddress, string memory unitName) external view returns (uint256 unitsCount);\r\n\r\n    /// @notice Mapping that contains amount of casualties after battle is finished\r\n    /// @dev Updated when #startBattle is called\r\n    /// @param side Side of which query casualties amount (sideA = 1, sideB = 2)\r\n    /// @param unitName Unit type to query\r\n    /// @return casualtiesCount Amount of casualties by side and unit type\r\n    function casualties(uint256 side, string memory unitName) external view returns (uint256 casualtiesCount);\r\n\r\n    /// @notice Mapping that contains side at which joined army is on\r\n    /// @dev Updated when #acceptArmyInBattle is called\r\n    /// @param armyAddress Address of the army\r\n    /// @return armySide Side of specified army (sideA = 1, sideB = 2)\r\n    function armySide(address armyAddress) external view returns (uint256 armySide);\r\n\r\n    /// @notice Battle time parameters\r\n    /// @dev Updated when battle initialized, first armies joined and finished (#initBattle, #acceptArmyInBattle, #startBattle)\r\n    /// @return creationTime Time when battle is created\r\n    /// @return lobbyDuration Lobby duration, initialized when first two armies joined\r\n    /// @return ongoingDuration Ongoing duration, initialized when first two armies joined\r\n    /// @return finishTime Time when battle is finished\r\n    function timing()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 creationTime,\r\n            uint64 lobbyDuration,\r\n            uint64 ongoingDuration,\r\n            uint64 finishTime\r\n        );\r\n\r\n    /// @notice Winning side\r\n    /// @dev Updated when #finishBattle is called\r\n    /// @return winningSide Winning side (no winner = 0, sideA = 1, sideB = 2)\r\n    function winningSide() external view returns (uint256 winningSide);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param attackerArmyAddress Attacker army address\r\n    /// @param attackedArmyAddress Attacked army address\r\n    function init(address attackerArmyAddress, address attackedArmyAddress) external;\r\n\r\n    /// @notice Calculates amount of armies joined to side A\r\n    /// @dev Basically returns length of sideA array\r\n    /// @return armiesCount Amount of armies joined to side A\r\n    function getSideALength() external view returns (uint256 armiesCount);\r\n\r\n    /// @notice Calculates amount of armies joined to side B\r\n    /// @dev Basically returns length of sideA array\r\n    /// @return armiesCount Amount of armies joined to side B\r\n    function getSideBLength() external view returns (uint256 armiesCount);\r\n\r\n    /// @notice Accepts army in battle\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param armyAddress Army address\r\n    /// @param side Side to which army will join\r\n    function acceptArmyInBattle(address armyAddress, uint256 side) external;\r\n\r\n    /// @notice Removes army from battle\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param armyAddress Army address\r\n    function removeArmyFromBattle(address armyAddress) external;\r\n\r\n    /// @notice Finishes battle\r\n    /// @dev Sets finish time\r\n    function finishBattle() external;\r\n\r\n    /// @notice Calculates casualties for first battle stage\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage1Casualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for second battle stage (based on casualties from first battle stage)\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @param stage1SideACasualties Stage 1 side A casualties\r\n    /// @param stage1SideBCasualties Stage 1 side B casualties\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage2Casualties(\r\n        uint256[] memory stage1SideACasualties,\r\n        uint256[] memory stage1SideBCasualties\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for all battle stages\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side A casualties\r\n    /// @return winningSide Winning side (0 - both sides lost, 1 - side A Won, 2 - side B Won\r\n    function calculateAllCasualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            uint256 winningSide\r\n        );\r\n\r\n    /// @notice Calculates lobby and ongoing duration\r\n    /// @dev Returns same value as #calculateTimings but without the need to provide all parameters\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @param sideAUnitsCount Side A units count\r\n    /// @param sideBUnitsCount Side B units count\r\n    /// @return lobbyDuration Lobby duration\r\n    /// @return ongoingDuration Ongoing duration\r\n    function getTimings(\r\n        bool isCultistsAttacked,\r\n        uint256 maxBattleDuration,\r\n        uint256 sideAUnitsCount,\r\n        uint256 sideBUnitsCount\r\n    ) external view returns (uint64 lobbyDuration, uint64 ongoingDuration);\r\n\r\n    /// @notice Calculates if battle can be finished\r\n    /// @dev Checks if finishTime is set and current block.timestamp > creationTime + lobbyDuration + ongoingDuration\r\n    /// @return canFinishBattle Can battle be finished\r\n    function canFinishBattle() external view returns (bool canFinishBattle);\r\n\r\n    /// @notice Calculates if battle is finished\r\n    /// @dev Checks if finishTime is not zero\r\n    /// @return isFinishedBattle Is finished battle\r\n    function isFinishedBattle() external view returns (bool isFinishedBattle);\r\n\r\n    /// @notice Calculates casualties for specified army\r\n    /// @dev Provides valid results only for finished battle\r\n    /// @param armyAddress Address of army presented in battle\r\n    /// @return isArmyWon Is army won\r\n    /// @return unitAmounts Amount of casualties for related unit types\r\n    function calculateArmyCasualties(address armyAddress)\r\n        external\r\n        view\r\n        returns (\r\n            bool isArmyWon,\r\n            uint256[] memory unitAmounts\r\n        );\r\n\r\n    /// @notice Calculates if lobby is opened\r\n    /// @dev Calculates if lobby is opened\r\n    /// @return isLobbyTime Is lobby is opened\r\n    function isLobbyTime() external view returns (bool isLobbyTime);\r\n\r\n    /// @notice Calculates lobby duration and ongoing duration based on specified parameters\r\n    /// @dev globalMultiplier, baseLobbyDuration, baseOngoingDuration parameters from registry\r\n    /// @param globalMultiplier Global multiplier (from registry)\r\n    /// @param baseBattleDuration Base battle duration (from registry)\r\n    /// @param battleLobbyDurationPercent Battle lobby duration percent (from registry)\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param units1 Amount of units from attacker army\r\n    /// @param units2 Amount of units from attacked army\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @return lobbyDuration Lobby duration\r\n    /// @return ongoingDuration Ongoing duration\r\n    function calculateTimings(\r\n        uint256 globalMultiplier,\r\n        uint256 baseBattleDuration,\r\n        uint256 battleLobbyDurationPercent,\r\n        bool isCultistsAttacked,\r\n        uint256 units1,\r\n        uint256 units2,\r\n        uint256 maxBattleDuration\r\n    ) external view returns (uint64 lobbyDuration, uint64 ongoingDuration);\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/IWorkersPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../zone/IZone.sol\";\r\nimport \"../../tokens/workers/IWorkers.sol\";\r\nimport \"../../tokens/prosperity/IProsperity.sol\";\r\n\r\n/// @title Zone workers pool interface\r\n/// @notice Functions to read state/modify state in order to mint workers/swap prosperity for workers\r\ninterface IWorkersPool {\r\n    /// @notice Emitted when #swapProsperityForExactWorkers or #swapExactProsperityForWorkers is called\r\n    /// @param buyer The address of settlement which bought workers\r\n    /// @param workersBought Amount of workers bought\r\n    /// @param prosperitySpent Amount of prosperity spent\r\n    event WorkersBought(\r\n        address buyer,\r\n        uint256 workersBought,\r\n        uint256 prosperitySpent\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this pool belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Starting unit price\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function startingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    function init(\r\n        address zoneAddress\r\n    ) external;\r\n\r\n    /// @notice Swaps prosperity() for exact workers()\r\n    /// @dev Even though function is opened, it can be executed only by ISettlement because only ISettlement can have prosperity\r\n    /// @param workersToBuy Exact amount of workers\r\n    /// @param maxProsperityToSell Maximum amount of prosperity to be taken for exact amount of workers\r\n    /// @return workersCount Amount of workers bought by prosperity\r\n    function swapProsperityForExactWorkers(uint256 workersToBuy, uint256 maxProsperityToSell) external returns (uint256 workersCount);\r\n\r\n    /// @notice Calculates input of prosperity based on output whole amount of workers\r\n    /// @dev Returns valid output only for integer workersToBuy value\r\n    /// @param workersToBuy Amount of workers to buy\r\n    /// @return prosperityToSell Amount of prosperity needed for workersToBuy\r\n    /// @return newStartingPrice New starting price\r\n    function getAmountIn(uint256 workersToBuy) external returns (uint256 prosperityToSell, uint256 newStartingPrice);\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/IUnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../tokens/units/IUnits.sol\";\r\nimport \"../../tokens/resources/IResource.sol\";\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Zone units pool interface\r\n/// @notice Functions to read state/modify state in order to mint units/swap weapons for units\r\ninterface IUnitsPool {\r\n    /// @notice Emitted when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    /// @param buyer The address which payed weapons\r\n    /// @param armyAddress The address of the army which received units\r\n    /// @param unitsBought Amount of units bought\r\n    /// @param weaponsSpent Amount of weapons spent\r\n    event UnitsBought(\r\n        address buyer,\r\n        address armyAddress,\r\n        uint256 unitsBought,\r\n        uint256 weaponsSpent\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this pool belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Units type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function unitsType() external view returns (string memory);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Starting unit price\r\n    /// @dev Updated every time when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    function startingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    /// @param unitsType Units type\r\n    function init(\r\n        address zoneAddress,\r\n        string memory unitsType\r\n    ) external;\r\n\r\n    /// @notice Swaps weapons() for exact units()\r\n    /// @dev msg.sender will be used as weapons payer\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxWeaponsToSell Maximum amount of weapons to be taken for exact amount of units\r\n    /// @return unitsCount Amount of units bought by weapons\r\n    function swapWeaponsForExactUnits(\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) external returns (uint256 unitsCount);\r\n\r\n    /// @notice Swaps weapons() for exact units()\r\n    /// @dev Even though function is opened it can be called only by zone\r\n    /// @param weaponsPayer Address from which weapons will be taken\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxWeaponsToSell Maximum amount of weapons to be taken for exact amount of units\r\n    /// @return unitsCount Amount of units bought by weapons\r\n    function swapWeaponsForExactUnitsByZone(\r\n        address weaponsPayer,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) external returns (uint256 unitsCount);\r\n\r\n    /// @notice Calculates input of weapons based on output whole amount of units\r\n    /// @dev Returns valid output only for integer unitsToBuy value (not in 1e18 precision)\r\n    /// @param unitsToBuy Amount of workers to buy\r\n    /// @return weaponsToSell Amount of weapons needed for unitsToBuy\r\n    /// @return newStartingPrice New starting price\r\n    function getAmountIn(uint256 unitsToBuy) external returns (uint256 weaponsToSell, uint256 newStartingPrice);\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/ISettlementMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Zone settlements market interface\r\n/// @notice Functions to read state/modify state in order to buy settlement\r\ninterface ISettlementsMarket {\r\n    /// @notice Emitted when #buySettlement is called\r\n    /// @param settlementAddress Settlement address\r\n    /// @param settlementCost Settlement cost\r\n    event SettlementBought(address settlementAddress, uint256 settlementCost);\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this market belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Time at which last purchase occurred\r\n    /// @dev Updated when #buySettlement is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    function init(\r\n        address zoneAddress\r\n    ) external;\r\n\r\n    /// @notice Buys settlement in zone\r\n    /// @dev Tokens will be deducted from msg.sender\r\n    /// @param position Position\r\n    /// @param ownerTokenId MithraeumBanners token id which will represent to which settlement will be attached to\r\n    /// @param maxTokensToUse Maximum amount of tokens to be withdrawn for settlement\r\n    function buySettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 maxTokensToUse\r\n    ) external payable;\r\n\r\n    /// @notice Returns amount of tokens new settlement will cost\r\n    /// @dev Calculates cost of placing new settlement in tokens\r\n    /// @return cost Amount of tokens new settlement will cost\r\n    function getNewSettlementCost() external view returns (uint256 cost);\r\n}\r\n"
    },
    "contracts/external/SettlementsListings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"../core/IWorld.sol\";\r\n\r\n/// @title Settlements listings\r\n/// @notice Functions related to selling settlements for specific amount of tokens\r\ncontract SettlementsListings is ReentrancyGuard {\r\n\r\n    /// @notice Emitted when #createOrder is called\r\n    /// @param orderId Newly created order id\r\n    /// @param bannerId Banner id\r\n    /// @param sellingTokenAddress Selling token address (address(0) if native eth currency is used)\r\n    /// @param price Price\r\n    event OrderCreated(uint256 orderId, uint256 bannerId, address sellingTokenAddress, uint256 price);\r\n\r\n    /// @notice Emitted when #cancelOrder is called (can be emitted when #createOrder is called once again after banner owner is changed)\r\n    /// @param orderId Order id\r\n    event OrderCancelled(uint256 orderId);\r\n\r\n    /// @notice Emitted when #acceptOrder is called\r\n    /// @param orderId Order id\r\n    event OrderAccepted(uint256 orderId);\r\n\r\n    /// @notice Emitted when #modifyOrder is called\r\n    /// @param orderId Order id\r\n    /// @param sellingTokenAddress New selling token address (address(0) if native eth currency is used)\r\n    /// @param price New price\r\n    event OrderModified(uint256 orderId, address sellingTokenAddress, uint256 price);\r\n\r\n    enum OrderStatus {\r\n        NOT_EXIST,// This status is necessary because of enum-uint cast (0 if empty storage)\r\n        NEW,\r\n        CANCELLED,\r\n        ACCEPTED\r\n    }\r\n\r\n    struct SharesInfo {\r\n        string buildingType;\r\n        uint256 minSharesAmount;\r\n    }\r\n\r\n    struct OrderDetails {\r\n        address orderOwner;\r\n        address sellingTokenAddress;\r\n        uint256 price;\r\n        uint256 bannerId;\r\n        OrderStatus status;\r\n    }\r\n\r\n    /// @notice Banners contract\r\n    /// @dev Immutable, initialized in constructor\r\n    IERC721Enumerable public banners;\r\n\r\n    /// @notice World contract\r\n    /// @dev Immutable, initialized in constructor\r\n    IWorld public world;\r\n\r\n    /// @notice Mapping containing order id to related OrderDetails struct\r\n    /// @dev Modified when #createOrder or #acceptOrder or #cancelOrder is called\r\n    mapping(uint256 => OrderDetails) public orders;\r\n\r\n    /// @notice Mapping containing link from banner id to order id\r\n    /// @dev Modified when #createOrder or #createOrder is called\r\n    mapping(uint256 => uint256) public bannersOrders;\r\n\r\n    /// @notice Lastly created order id (0 if no orders is created)\r\n    /// @dev Modified when #createOrder is called\r\n    uint256 public lastOrderId = 0;\r\n\r\n    constructor(\r\n        address bannersAddress,\r\n        address worldAddress\r\n    ) public {\r\n        banners = IERC721Enumerable(bannersAddress);\r\n        world = IWorld(worldAddress);\r\n    }\r\n\r\n    /// @notice Creates settlement order\r\n    /// @dev Creates order for specified amount of tokens\r\n    /// @param bannerId Banner id\r\n    /// @param sellingTokenAddress Selling token address (address(0) if native eth currency is used)\r\n    /// @param price Price\r\n    function createOrder(\r\n        uint256 bannerId,\r\n        address sellingTokenAddress,\r\n        uint256 price\r\n    ) public {\r\n        address bannerOwner = banners.ownerOf(bannerId);\r\n\r\n        uint256 orderId = bannersOrders[bannerId];\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        if (orderDetails.status == OrderStatus.NEW && orderDetails.orderOwner != bannerOwner) {\r\n            cancelOrder(orderId);\r\n        }\r\n\r\n        require(bannerOwner == msg.sender, \"only owner can create order for provided banner id\");\r\n        require(bannersOrders[bannerId] == 0, \"order for this banner already exist\");\r\n\r\n        lastOrderId = lastOrderId + 1;\r\n        bannersOrders[bannerId] = lastOrderId;\r\n\r\n        OrderDetails storage newOrderDetails = orders[lastOrderId];\r\n\r\n        newOrderDetails.bannerId = bannerId;\r\n        newOrderDetails.orderOwner = msg.sender;\r\n        newOrderDetails.sellingTokenAddress = sellingTokenAddress;\r\n        newOrderDetails.price = price;\r\n        newOrderDetails.status = OrderStatus.NEW;\r\n\r\n        emit OrderCreated(lastOrderId, bannerId, sellingTokenAddress, price);\r\n    }\r\n\r\n    /// @notice Accepts order\r\n    /// @dev Transfers banner id to msg.sender for provided amount of tokens (if ERC20 - they need to be approved beforehand, if native - they have to be sent to this function)\r\n    /// @param orderId Order id\r\n    /// @param minBuildingsSharesToReceive Minimum amount of building shares to receive with orders' banner\r\n    function acceptOrder(\r\n        uint256 orderId,\r\n        SharesInfo[] memory minBuildingsSharesToReceive\r\n    ) public payable nonReentrant {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        require(orderDetails.status == OrderStatus.NEW, \"not new order\");\r\n\r\n        bool isNativeCurrency = orderDetails.sellingTokenAddress == address(0);\r\n        if (isNativeCurrency) {\r\n            require(msg.value == orderDetails.price, \"not enough tokens sent\");\r\n            Address.sendValue(payable(orderDetails.orderOwner), orderDetails.price);\r\n        } else {\r\n            IERC20(orderDetails.sellingTokenAddress).transferFrom(msg.sender, orderDetails.orderOwner, orderDetails.price);\r\n        }\r\n\r\n        banners.safeTransferFrom(orderDetails.orderOwner, msg.sender, orderDetails.bannerId);\r\n\r\n        IDistributions distributions = world.distributions();\r\n        IEpoch currentEpoch = world.epochs(world.currentEpochNumber());\r\n        ISettlement settlement = currentEpoch.userSettlements(orderDetails.bannerId);\r\n\r\n        uint256[] memory distributionIds = new uint256[](minBuildingsSharesToReceive.length);\r\n        uint256[] memory amounts = new uint256[](minBuildingsSharesToReceive.length);\r\n\r\n        for (uint256 i = 0; i < minBuildingsSharesToReceive.length; i++) {\r\n            SharesInfo memory minSharesInfo = minBuildingsSharesToReceive[i];\r\n            uint256 distributionId = settlement.buildings(minSharesInfo.buildingType).distributionId();\r\n            uint256 sharesAmountOnOwner = distributions.balanceOf(orderDetails.orderOwner, distributionId);\r\n\r\n            require(sharesAmountOnOwner >= minSharesInfo.minSharesAmount, \"not enough shares\");\r\n\r\n            distributionIds[i] = distributionId;\r\n            amounts[i] = sharesAmountOnOwner;\r\n        }\r\n\r\n        distributions.safeBatchTransferFrom(\r\n            orderDetails.orderOwner,\r\n            msg.sender,\r\n            distributionIds,\r\n            amounts,\r\n            new bytes(0)\r\n        );\r\n\r\n        orderDetails.status = OrderStatus.ACCEPTED;\r\n        bannersOrders[orderDetails.bannerId] = 0;\r\n\r\n        emit OrderAccepted(orderId);\r\n    }\r\n\r\n    /// @notice Cancels order\r\n    /// @dev Can be called by order owner OR order owner is not banner owner (anyone can cancel order if order is not valid)\r\n    /// @param orderId Order id\r\n    function cancelOrder(\r\n        uint256 orderId\r\n    ) public {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n        address bannerOwner = banners.ownerOf(orderDetails.bannerId);\r\n\r\n        require(orderDetails.status == OrderStatus.NEW, \"not new order\");\r\n\r\n        bool isOrderOwner = orderDetails.orderOwner == msg.sender;\r\n        bool isOrderOwnerOwnsBanner = orderDetails.orderOwner == bannerOwner;\r\n        require(isOrderOwner || !isOrderOwnerOwnsBanner, \"unable to cancel order\");\r\n\r\n        orderDetails.status = OrderStatus.CANCELLED;\r\n        bannersOrders[orderDetails.bannerId] = 0;\r\n\r\n        emit OrderCancelled(orderId);\r\n    }\r\n\r\n    /// @notice Modifies order\r\n    /// @dev Selling token address, price can be modified; banner id cannot be modified\r\n    /// @param orderId Order id\r\n    /// @param sellingTokenAddress New selling token address (address(0) if native eth currency is used)\r\n    /// @param price New price\r\n    function modifyOrder(\r\n        uint256 orderId,\r\n        address sellingTokenAddress,\r\n        uint256 price\r\n    ) public {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        require(orderDetails.status == OrderStatus.NEW, \"not new order\");\r\n        require(orderDetails.orderOwner == msg.sender, \"unable to modify order\");\r\n\r\n        orderDetails.sellingTokenAddress = sellingTokenAddress;\r\n        orderDetails.price = price;\r\n\r\n        emit OrderModified(orderId, sellingTokenAddress, price);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/periphery/EpochView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/IWorld.sol\";\r\nimport \"../core/assets/epoch/IEpoch.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\n\r\ncontract EpochView {\r\n    /// @notice Returns user settlements by provided banners ids\r\n    /// @dev Useful to batch query settlement addresses by banners ids\r\n    /// @param epochAddress Epoch address\r\n    /// @param ownerTokenIds Banners ids\r\n    /// @return userSettlements Settlement addresses\r\n    function getUserSettlements(\r\n        address epochAddress,\r\n        uint256[] memory ownerTokenIds\r\n    ) public view returns (address[] memory) {\r\n        IEpoch currentEpoch = IEpoch(epochAddress);\r\n\r\n        address[] memory result = new address[](ownerTokenIds.length);\r\n\r\n        for (uint256 i = 0; i < ownerTokenIds.length; i++) {\r\n            result[i] = address(currentEpoch.userSettlements(ownerTokenIds[i]));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @notice If necessary activates zone and restores settlement\r\n    /// @dev Restores settlement on position and activates zone if it is not activated yet\r\n    /// @param epochAddress Epoch address\r\n    /// @param position Position\r\n    function restoreSettlementWithZoneActivation(\r\n        address epochAddress,\r\n        uint32 position\r\n    ) public {\r\n        IEpoch epoch = IEpoch(epochAddress);\r\n        IWorldAsset epochWorldAsset = IWorldAsset(epochAddress);\r\n\r\n        IWorld world = epochWorldAsset.world();\r\n        IGeography.GameTile memory gameTile = world.geography().getGameTile(position);\r\n        uint256 zoneIndex = gameTile.zoneId;\r\n        if (address(epoch.zones(zoneIndex)) == address(0)) {\r\n            epoch.activateZone(zoneIndex);\r\n        }\r\n\r\n        epoch.restoreSettlement(position);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\n\r\ninterface IWorldAsset {\r\n    /// @notice World\r\n    /// @dev Value is dereferenced from proxy storage\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Registry\r\n    /// @dev Value is dereferenced from world\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Epoch\r\n    /// @dev Value is dereferenced from proxy storage and world\r\n    function epoch() external view returns (IEpoch);\r\n}\r\n"
    },
    "contracts/periphery/BattleView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/battle/IBattle.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\n\r\n/// @title Battle view contract\r\n/// @notice Contains helper functions to query battle in simple read requests\r\ncontract BattleView {\r\n    struct BattleCombinedData {\r\n        address id;\r\n        uint64 battleCreationDate;\r\n        uint64 battleLobbyDuration;\r\n        uint64 battleOngoingDuration;\r\n        uint64 battleFinishDate;\r\n        address battleSettlementId;\r\n        uint32 battleGamePosition;\r\n        uint256[] sideACasualties;\r\n        uint256[] sideBCasualties;\r\n        uint256[] sideAUnitsCount;\r\n        uint256[] sideBUnitsCount;\r\n    }\r\n\r\n    /// @notice Calculates combined battle data\r\n    /// @dev In case of very big battle, this function may not work due to array nature of battle sides\r\n    /// @param battleAddress Battle address\r\n    /// @return battleCombinedData Battle combined data\r\n    function getBattleCombinedData(address battleAddress) public view returns (BattleCombinedData memory battleCombinedData) {\r\n        IBattle battle = IBattle(battleAddress);\r\n        IWorld world = IWorldAsset(battleAddress).world();\r\n        IEpoch epoch = IWorldAsset(battleAddress).epoch();\r\n\r\n        string[] memory units = world.registry().getUnits();\r\n        uint256 totalUnitTypes = units.length;\r\n\r\n        uint256[] memory sideACasualties = new uint256[](totalUnitTypes);\r\n        uint256[] memory sideBCasualties = new uint256[](totalUnitTypes);\r\n\r\n        uint256[] memory sideAUnitsCount = new uint256[](totalUnitTypes);\r\n        uint256[] memory sideBUnitsCount = new uint256[](totalUnitTypes);\r\n\r\n        for (uint256 i = 0; i < totalUnitTypes; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            sideAUnitsCount[i] = battle.sideUnitsCount(1, unitName);\r\n            sideBUnitsCount[i] = battle.sideUnitsCount(2, unitName);\r\n\r\n            sideACasualties[i] = battle.casualties(1, unitName);\r\n            sideBCasualties[i] = battle.casualties(2, unitName);\r\n        }\r\n\r\n        IBattle.Timing memory timing = getBattleTiming(battleAddress);\r\n        uint32 position = IBattle(battleAddress).position();\r\n\r\n        return\r\n            BattleCombinedData({\r\n                id: battleAddress,\r\n                battleCreationDate: timing.creationTime,\r\n                battleLobbyDuration: timing.lobbyDuration,\r\n                battleOngoingDuration: timing.ongoingDuration,\r\n                battleFinishDate: timing.finishTime,\r\n                battleSettlementId: address(epoch.settlements(position)),\r\n                battleGamePosition: position,\r\n                sideAUnitsCount: sideAUnitsCount,\r\n                sideBUnitsCount: sideBUnitsCount,\r\n                sideACasualties: sideACasualties,\r\n                sideBCasualties: sideBCasualties\r\n            });\r\n    }\r\n\r\n    function getBattleTiming(address battleAddress) public view returns (IBattle.Timing memory timing) {\r\n        IBattle battle = IBattle(battleAddress);\r\n        (uint64 creationTime, uint64 lobbyDuration, uint64 ongoingDuration, uint64 finishTime) = battle.timing();\r\n\r\n        timing.creationTime = creationTime;\r\n        timing.lobbyDuration = lobbyDuration;\r\n        timing.ongoingDuration = ongoingDuration;\r\n        timing.finishTime = finishTime;\r\n    }\r\n\r\n    function getSideA(address battleAddress) public view returns (address[] memory) {\r\n        uint256 sideACount = IBattle(battleAddress).getSideALength();\r\n        address[] memory side = new address[](sideACount);\r\n        for (uint256 i = 0; i < sideACount; i++) {\r\n            side[i] = IBattle(battleAddress).sideA(i);\r\n        }\r\n\r\n        return side;\r\n    }\r\n\r\n    function getSideB(address battleAddress) public view returns (address[] memory) {\r\n        uint256 sideCount = IBattle(battleAddress).getSideBLength();\r\n        address[] memory side = new address[](sideCount);\r\n        for (uint256 i = 0; i < sideCount; i++) {\r\n            side[i] = IBattle(battleAddress).sideB(i);\r\n        }\r\n\r\n        return side;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/ArmyView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/army/IArmy.sol\";\r\nimport \"../core/assets/epoch/IEpoch.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\nimport \"../core/assets/battle/IBattle.sol\";\r\nimport \"../libraries/MathExtension.sol\";\r\n\r\n/// @title Army view contract\r\n/// @notice Contains helper functions to query army in simple read requests\r\ncontract ArmyView {\r\n    struct ArmyCombinedData {\r\n        address id;\r\n        address owner;\r\n        address ownerSettlementId;\r\n        uint32 currentPosition;\r\n        address currentPositionSettlementId;\r\n        address battleId;\r\n        uint256[] units;\r\n        uint256[] besiegingUnits;\r\n        uint256 robberyTokensCount;\r\n        uint32[] currentPath;\r\n        uint64 stunStartTime;\r\n        uint64 stunEndTime;\r\n        uint64 movementStartTime;\r\n        uint64 movementEndTime;\r\n        address destinationPositionSettlementId;\r\n        uint256 lastDemilitarizationTime;\r\n    }\r\n\r\n    /// @dev Calculates army owner\r\n    function getArmyOwner(IArmy army) internal view returns (address) {\r\n        bool isCultistArmy = address(army.currentSettlement()) == address(army.currentSettlement().currentZone().cultistsSettlement());\r\n        return !isCultistArmy ? army.currentSettlement().getSettlementOwner() : address(0);\r\n    }\r\n\r\n    /// @dev Calculates if battle can be finished at provided timestamp\r\n    function canFinishBattleAtProvidedTimestamp(\r\n        IBattle battle,\r\n        uint256 timestamp\r\n    ) internal view returns (bool) {\r\n        (uint64 creationTime, uint64 lobbyDuration, uint64 ongoingDuration, uint64 finishTime) = battle.timing();\r\n        return creationTime > 0 && timestamp >= creationTime + lobbyDuration + ongoingDuration;\r\n    }\r\n\r\n    /// @notice Calculates combined army data\r\n    /// @dev Provided timestamp takes into account only robberyTokensCount\r\n    /// @param armyAddress Army address\r\n    /// @param timestamp Timestamp at which robberyTokensCount will be calculated\r\n    /// @return armyCombinedData Army combined data\r\n    function getArmyCombinedData(address armyAddress, uint256 timestamp)\r\n        public\r\n        view\r\n        returns (ArmyCombinedData memory armyCombinedData)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n\r\n        IWorld world = IWorldAsset(armyAddress).world();\r\n        IEpoch epoch = IWorldAsset(armyAddress).epoch();\r\n\r\n        string[] memory units = world.registry().getUnits();\r\n\r\n        armyCombinedData.id = armyAddress;\r\n\r\n        armyCombinedData.currentPosition = army.currentPosition();\r\n        armyCombinedData.currentPositionSettlementId = address(epoch.settlements(armyCombinedData.currentPosition));\r\n        armyCombinedData.currentPath = army.getMovementPath();\r\n        armyCombinedData.destinationPositionSettlementId = armyCombinedData.currentPath.length > 0\r\n            ? address(epoch.settlements(armyCombinedData.currentPath[armyCombinedData.currentPath.length - 1]))\r\n            : address(0);\r\n\r\n        (armyCombinedData.stunStartTime, armyCombinedData.stunEndTime) = army.stunTiming();\r\n        (armyCombinedData.movementStartTime, armyCombinedData.movementEndTime) = army.movementTiming();\r\n\r\n        if (armyCombinedData.movementEndTime != 0 && timestamp >= armyCombinedData.movementEndTime) {\r\n            armyCombinedData.currentPosition = armyCombinedData.currentPath[armyCombinedData.currentPath.length - 1];\r\n            armyCombinedData.currentPositionSettlementId = armyCombinedData.destinationPositionSettlementId;\r\n            armyCombinedData.currentPath = new uint32[](0);\r\n            armyCombinedData.destinationPositionSettlementId = address(0);\r\n\r\n            uint64 movementDuration = armyCombinedData.movementEndTime - armyCombinedData.movementStartTime;\r\n            uint64 movementStunDuration = uint64(movementDuration * world.registry().getMovementDurationStunMultiplier() / 1e18);\r\n            uint64 movementStunStartTime = armyCombinedData.movementEndTime;\r\n            uint64 movementStunEndTime = movementStunStartTime + movementStunDuration;\r\n\r\n            if (movementStunEndTime > armyCombinedData.stunEndTime) {\r\n                armyCombinedData.stunStartTime = movementStunStartTime;\r\n                armyCombinedData.stunEndTime = movementStunEndTime;\r\n            }\r\n\r\n            armyCombinedData.movementStartTime = 0;\r\n            armyCombinedData.movementEndTime = 0;\r\n        }\r\n\r\n        armyCombinedData.owner = getArmyOwner(army);\r\n        armyCombinedData.ownerSettlementId = address(army.currentSettlement());\r\n\r\n        armyCombinedData.units = new uint256[](units.length);\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            armyCombinedData.units[i] = epoch.units(units[i]).balanceOf(armyAddress);\r\n        }\r\n\r\n        armyCombinedData.battleId = address(army.battle());\r\n        if (armyCombinedData.battleId != address(0)) {\r\n            IBattle battle = IBattle(armyCombinedData.battleId);\r\n            if (canFinishBattleAtProvidedTimestamp(battle, timestamp)) {\r\n                (bool isArmyWon, uint256[] memory casualties) = battle.calculateArmyCasualties(armyAddress);\r\n                for (uint256 i = 0; i < units.length; i++) {\r\n                    armyCombinedData.units[i] = armyCombinedData.units[i] - casualties[i];\r\n                }\r\n\r\n                if (!isArmyWon) {\r\n                    (uint64 battleCreationTime, uint64 lobbyDuration, uint64 ongoingDuration,) = battle.timing();\r\n                    uint64 battleDuration = lobbyDuration + ongoingDuration;\r\n                    uint64 stunDuration = uint64(battleDuration * world.registry().getBattleDurationStunMultiplier() / 1e18);\r\n                    uint64 battleStunStartTime = battleCreationTime + battleDuration;\r\n                    uint64 battleStunEndTime = battleStunStartTime + stunDuration;\r\n                    if (battleStunEndTime > armyCombinedData.stunEndTime) {\r\n                        armyCombinedData.stunStartTime = battleStunStartTime;\r\n                        armyCombinedData.stunEndTime = battleStunEndTime;\r\n                    }\r\n                }\r\n\r\n                armyCombinedData.battleId = address(0);\r\n            }\r\n        }\r\n\r\n        if (timestamp >= armyCombinedData.stunEndTime) {\r\n            armyCombinedData.stunStartTime = 0;\r\n            armyCombinedData.stunEndTime = 0;\r\n        }\r\n\r\n        armyCombinedData.besiegingUnits = new uint256[](units.length);\r\n\r\n        if (address(army.siege()) != address(0)) {\r\n            ISiege siege = army.siege();\r\n            armyCombinedData.robberyTokensCount = siege.getUserPointsOnTime(armyAddress, timestamp);\r\n            armyCombinedData.besiegingUnits = siege.getStoredUnits(armyAddress);\r\n        }\r\n\r\n        armyCombinedData.lastDemilitarizationTime = army.lastDemilitarizationTime();\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/MathExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Extension of math library\r\n/// @notice Contains helper functions for some math operations\r\nlibrary MathExtension {\r\n    /// @dev Calculates square root of uint256 using Babylonian Method\r\n    function sqrt(uint256 y) external pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding down\r\n    function roundDownWithPrecision(uint256 value, uint256 precision) public pure returns (uint256) {\r\n        return (value / precision) * precision;\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding up\r\n    function roundUpWithPrecision(uint256 value, uint256 precision) external pure returns (uint256) {\r\n        uint256 roundedValue = roundDownWithPrecision(value, precision);\r\n        if (value % precision != 0) {\r\n            roundedValue += precision;\r\n        }\r\n\r\n        return roundedValue;\r\n    }\r\n\r\n    /// @dev Check if uint256 value with provided precision integer value or not\r\n    function isIntegerWithPrecision(uint256 value, uint256 precision) external pure returns (bool) {\r\n        return value % precision == 0;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/zone/Zone.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./IZone.sol\";\r\nimport \"../workersPool/IWorkersPoolFactory.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../unitsPool/IUnitsPoolFactory.sol\";\r\nimport \"../settlement/ISettlementFactory.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../settlementsMarket/ISettlementMarketFactory.sol\";\r\n\r\ncontract Zone is WorldAsset, IZone {\r\n    /// @inheritdoc IZone\r\n    IWorkersPool public override workersPool;\r\n    /// @inheritdoc IZone\r\n    mapping(string => IUnitsPool) public override unitsPools;\r\n    /// @inheritdoc IZone\r\n    ISettlementsMarket public override settlementsMarket;\r\n    /// @inheritdoc IZone\r\n    ISettlement public override cultistsSettlement;\r\n    /// @inheritdoc IZone\r\n    uint256 public override cultistsSummonTime;\r\n    /// @inheritdoc IZone\r\n    int256 public override toxicity;\r\n    /// @inheritdoc IZone\r\n    uint256 public override zoneIndex;\r\n    /// @inheritdoc IZone\r\n    uint256 public override lastUpdateStateTime;\r\n    /// @inheritdoc IZone\r\n    uint256 public override lastUpdateStateZoneTime;\r\n\r\n    /// @dev Allows caller to be only current epoch's units\r\n    modifier onlyEpochUnits() {\r\n        string memory unitType = IUnits(msg.sender).worldUnitName();\r\n        require(address(epoch().units(unitType)) == msg.sender, \"onlyEpochUnits\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function init(uint256 _zoneIndex) public override initializer {\r\n        zoneIndex = _zoneIndex;\r\n        lastUpdateStateTime = block.timestamp;\r\n        lastUpdateStateZoneTime = getZoneTime(block.timestamp);\r\n\r\n        // 1. create workers pool\r\n        IWorkersPoolFactory workersPoolFactory = IWorkersPoolFactory(registry().factoryContracts(keccak256(bytes(\"workersPool\"))));\r\n        address workersPoolAddress = workersPoolFactory.create(\r\n            address(world()),\r\n            epochNumber(),\r\n            \"BASIC\",\r\n            address(this)\r\n        );\r\n\r\n        workersPool = IWorkersPool(workersPoolAddress);\r\n        emit WorkersPoolCreated(workersPoolAddress);\r\n\r\n        // 2. create settlements market\r\n        ISettlementsMarketFactory settlementsMarketFactory = ISettlementsMarketFactory(registry().factoryContracts(keccak256(bytes(\"settlementsMarket\"))));\r\n        address settlementsMarketAddress = settlementsMarketFactory.create(\r\n            address(world()),\r\n            epochNumber(),\r\n            \"BASIC\",\r\n            address(this)\r\n        );\r\n\r\n        settlementsMarket = ISettlementsMarket(settlementsMarketAddress);\r\n        emit SettlementsMarketCreated(settlementsMarketAddress);\r\n\r\n        // 3. create units pool\r\n        IUnitsPoolFactory unitsPoolFactory = IUnitsPoolFactory(\r\n            registry().factoryContracts(keccak256(bytes(\"unitsPool\")))\r\n        );\r\n\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            address unitsPoolAddress = unitsPoolFactory.create(\r\n                address(world()),\r\n                epochNumber(),\r\n                \"BASIC\",\r\n                address(this),\r\n                unitName\r\n            );\r\n\r\n            unitsPools[unitName] = IUnitsPool(unitsPoolAddress);\r\n            emit UnitsPoolCreated(unitsPoolAddress, unitName);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function getZoneTime(uint256 timestamp) public override view returns (uint256) {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime != 0) {\r\n            timestamp = Math.min(timestamp, gameFinishTime);\r\n        }\r\n\r\n        if (timestamp <= lastUpdateStateTime) {\r\n            return lastUpdateStateZoneTime;\r\n        }\r\n\r\n        uint256 timeDelta = timestamp - lastUpdateStateTime;\r\n        uint256 penalty = getPenaltyFromCultists();\r\n\r\n        return lastUpdateStateZoneTime + (timeDelta * (1e18 - penalty));\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function updateState() public override {\r\n        if (block.timestamp == lastUpdateStateTime) {\r\n            return;\r\n        }\r\n\r\n        IArmy cultistsArmy = cultistsSettlement.army();\r\n        IBattle cultistsBattle = cultistsArmy.battle();\r\n        if (address(cultistsBattle) != address(0) && !cultistsBattle.isFinishedBattle() && cultistsBattle.canFinishBattle()) {\r\n            cultistsBattle.finishBattle();\r\n            return;\r\n        }\r\n\r\n        if (address(cultistsBattle) != address(0) && cultistsBattle.isFinishedBattle()) {\r\n            (,,, uint64 battleFinishTime) = cultistsBattle.timing();\r\n            lastUpdateStateZoneTime = getZoneTime(battleFinishTime);\r\n            lastUpdateStateTime = battleFinishTime;\r\n        }\r\n\r\n        lastUpdateStateZoneTime = getZoneTime(block.timestamp);\r\n        lastUpdateStateTime = block.timestamp;\r\n        emit ZoneTimeChanged(lastUpdateStateTime, lastUpdateStateZoneTime);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function createCultists(\r\n        uint32 cultistsPosition\r\n    ) public override onlyWorldAssetFromSameEpoch {\r\n        require(address(cultistsSettlement) == address(0), \"Cultists already created\");\r\n\r\n        address cultistsSettlementAddress = epoch().newAssetSettlement(\r\n            0,\r\n            cultistsPosition,\r\n            \"CULTISTS\",\r\n            false\r\n        );\r\n\r\n        cultistsSettlement = ISettlement(cultistsSettlementAddress);\r\n        mintCultists(0);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function buyUnitsBatch(\r\n        address settlementAddress,\r\n        string[] memory unitNames,\r\n        uint256[] memory unitsCount,\r\n        uint256[] memory maxWeaponsToSell\r\n    ) public override {\r\n        for (uint256 i = 0; i < unitNames.length; i++) {\r\n            unitsPools[unitNames[i]].swapWeaponsForExactUnitsByZone(\r\n                msg.sender,\r\n                settlementAddress,\r\n                unitsCount[i],\r\n                maxWeaponsToSell[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function summonCultists() public override onlyActiveGame {\r\n        uint256 summonDelay = registry().getCultistsSummonDelay() / registry().getGlobalMultiplier();\r\n        require(block.timestamp > cultistsSummonTime + summonDelay, \"summon delay\");\r\n\r\n        if (toxicity <= 0) {\r\n            mintCultists(0);\r\n            return;\r\n        }\r\n\r\n        uint256 currentCultistsAmount = epoch().units(registry().getCultistUnitType()).balanceOf(address(cultistsSettlement.army()));\r\n        uint256 maxExtraCultists = registry().getMaxCultistsPerZone() - currentCultistsAmount;\r\n\r\n        if (currentCultistsAmount / 2 > uint256(toxicity) / 10) {\r\n            mintCultists(0);\r\n            return;\r\n        }\r\n\r\n        uint256 cultistsToSummon = Math.min(\r\n            MathExtension.roundDownWithPrecision(uint256(toxicity) / 10 - currentCultistsAmount / 2, 1e18),\r\n            maxExtraCultists\r\n        );\r\n\r\n        mintCultists(cultistsToSummon);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function increaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEpoch {\r\n        uint256 toxicityAmount = registry().getToxicityByResource(resourceName) * value / 1e18;\r\n        toxicity += int256(toxicityAmount);\r\n        emit ToxicityIncreased(settlementAddress, toxicityAmount);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function decreaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEpoch {\r\n        uint256 toxicityAmount = registry().getToxicityByResource(resourceName) * value / 1e18;\r\n        toxicity -= int256(toxicityAmount);\r\n        emit ToxicityDecreased(settlementAddress, toxicityAmount);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function handleCultistsSummoned(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) public override onlyEpochUnits {\r\n        cultistsSummonTime = block.timestamp;\r\n        epoch().increaseTotalCultists(cultistsArmyAddress, value);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function handleCultistsDefeated(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) public override onlyEpochUnits {\r\n        epoch().decreaseTotalCultists(cultistsArmyAddress, value);\r\n    }\r\n\r\n    /// @inheritdoc IZone\r\n    function getPenaltyFromCultists() public view returns (uint256) {\r\n        uint256 cultistsCount = epoch().units(registry().getCultistUnitType()).balanceOf(address(cultistsSettlement.army()));\r\n        uint256 penalty = cultistsCount * 1e18 / registry().getMaxCultistsPerZone();\r\n\r\n        if (penalty > 1e18) {\r\n            return 1e18;\r\n        }\r\n\r\n        return penalty;\r\n    }\r\n\r\n    /// @dev Mints cultists in current zone\r\n    function mintCultists(\r\n        uint256 value\r\n    ) internal {\r\n        address cultistsArmyAddress = address(cultistsSettlement.army());\r\n        epoch().units(registry().getCultistUnitType()).mint(cultistsArmyAddress, value);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/IWorkersPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Zone workers pool factory interface\r\n/// @notice Contains instance creator function\r\ninterface IWorkersPoolFactory {\r\n    /// @notice Creates Zone workers pool instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the pool type (Currently only 'BASIC')\r\n    /// @param zoneAddress Zone address\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/IUnitsPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Zone units pool factory interface\r\n/// @notice Contains instance creator function\r\ninterface IUnitsPoolFactory {\r\n    /// @notice Creates Zone units pool instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the pool type (Currently only 'BASIC')\r\n    /// @param zoneAddress Zone address\r\n    /// @param unitsType Units type\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress,\r\n        string memory unitsType\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/settlement/ISettlementFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Settlement factory interface\r\n/// @notice Contains instance creator function\r\ninterface ISettlementFactory {\r\n    /// @notice Creates Settlement instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the battle type (Currently only 'BASIC' and 'CULTISTS')\r\n    /// @param ownerTokenId Id of the banner settlement will attach to\r\n    /// @param zoneAddress Address of the zone where settlement will be created\r\n    /// @param settlementPosition Position on which settlement is created\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        uint256 ownerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/WorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\nimport \"./IWorldAsset.sol\";\r\nimport \"./WorldAssetStorageAccessor.sol\";\r\n\r\n/// @title Abstract world asset\r\n/// @notice World asset must inherit this basic contract\r\nabstract contract WorldAsset is IWorldAsset, WorldAssetStorageAccessor, Initializable {\r\n    /// Allows caller to be only mighty creator\r\n    modifier onlyMightyCreator() {\r\n        require(msg.sender == registry().mightyCreator(), \"onlyMightyCreator\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only world or world asset\r\n    modifier onlyWorldAssetFromSameEpoch() {\r\n        require(\r\n            msg.sender == address(world()) ||\r\n                world().worldAssets(WorldAssetStorageAccessor.epochNumber(), msg.sender) != bytes32(0),\r\n            \"onlyWorldAssetFromSameEpoch\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    modifier onlyActiveGame() {\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        require(gameFinishTime == 0 || block.timestamp < gameFinishTime, \"game closed\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function world() public view override(IWorldAsset, WorldAssetStorageAccessor) returns (IWorld) {\r\n        return WorldAssetStorageAccessor.world();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function registry() public view override returns (IRegistry) {\r\n        return world().registry();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function epoch() public view override returns (IEpoch) {\r\n        return world().epochs(WorldAssetStorageAccessor.epochNumber());\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/ISettlementMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Zone settlements market factory interface\r\n/// @notice Contains instance creator function\r\ninterface ISettlementsMarketFactory {\r\n    /// @notice Creates Zone settlements market instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the market type (Currently only 'BASIC')\r\n    /// @param zoneAddress Zone address\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/core/assets/WorldAssetStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nstruct WorldAssetStorage {\r\n    address worldAddress;\r\n    uint256 epochNumber;\r\n    bytes32 assetId;\r\n    string assetGroup;\r\n    string assetType;\r\n}\r\n\r\nfunction getWorldAssetStorage() pure returns (WorldAssetStorage storage ds) {\r\n    //keccak256(\"mithraeum.worldassetproxy\") is 6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6\r\n    bytes32 position = 0x6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6;\r\n    assembly {\r\n        ds.slot := position\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorageAccessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorldAssetStorageAccessor.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\n\r\n/// @title World asset storage accessor\r\n/// @notice Any world asset which requires to identify itself as a specific type should inherit this contract\r\nabstract contract WorldAssetStorageAccessor is IWorldAssetStorageAccessor {\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function world() public view virtual override returns (IWorld) {\r\n        return IWorld(getWorldAssetStorage().worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function epochNumber() public view override returns (uint256) {\r\n        return getWorldAssetStorage().epochNumber;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetGroup() public view override returns (string memory) {\r\n        return getWorldAssetStorage().assetGroup;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetType() public view override returns (string memory) {\r\n        return getWorldAssetStorage().assetType;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAssetStorageAccessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\n\r\n/// @title World asset storage accessor interface\r\n/// @notice Contains function to identify world asset group and type\r\ninterface IWorldAssetStorageAccessor {\r\n    // Functions\r\n\r\n    /// @notice Returns world\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return world World\r\n    function world() external view returns (IWorld world);\r\n\r\n    /// @notice Returns epoch number\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return epochNumber Epoch number\r\n    function epochNumber() external view returns (uint256 epochNumber);\r\n\r\n    /// @notice Returns world asset group\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetGroup World asset group\r\n    function assetGroup() external view returns (string memory assetGroup);\r\n\r\n    /// @notice Returns world asset type\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetType World asset type\r\n    function assetType() external view returns (string memory assetType);\r\n}\r\n"
    },
    "contracts/core/rewardPool/RewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"./IRewardPool.sol\";\r\nimport \"../WorldInitializable.sol\";\r\nimport \"../../periphery/ProxyReentrancyGuard.sol\";\r\n\r\ncontract RewardPool is IRewardPool, WorldInitializable, ProxyReentrancyGuard {\r\n    /// @inheritdoc IRewardPool\r\n    int256 public override ratio;\r\n    /// @inheritdoc IRewardPool\r\n    uint256 public override invested;\r\n    /// @inheritdoc IRewardPool\r\n    uint256 public override lastBalance;\r\n\r\n    event RewardPoolUpdated();\r\n\r\n    /// @dev Allows caller to be only world\r\n    modifier onlyWorld() {\r\n        require(msg.sender == address(world), \"onlyWorld\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Repays newly added balance to mighty creator\r\n    modifier syncBalances(uint256 msgValue) {\r\n        uint256 blessBalanceBefore = getBlessBalance() - msgValue;\r\n        uint256 addedBalance = blessBalanceBefore - lastBalance;\r\n        if (addedBalance > 0) {\r\n            uint256 toRepay = Math.min(invested, addedBalance);\r\n\r\n            if (toRepay > 0) {\r\n                sendTokens(world.registry().mightyCreator(), toRepay);\r\n                invested -= toRepay;\r\n            }\r\n        }\r\n        _;\r\n        lastBalance = getBlessBalance();\r\n        emit RewardPoolUpdated();\r\n    }\r\n\r\n    /// @dev Reads current bless balance\r\n    function getBlessBalance() internal returns (uint256) {\r\n        return\r\n            address(world.blessToken()) == address(0)\r\n                ? address(this).balance\r\n                : world.blessToken().balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Sends bless tokens from this contract to specified address (either eth or erc20)\r\n    function sendTokens(address to, uint256 amount) internal {\r\n        if (address(world.blessToken()) == address(0)) {\r\n            Address.sendValue(payable(to), amount);\r\n        } else {\r\n            world.blessToken().transfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Increases ratio\r\n    /// @dev At start it is positive -> user need to pay RATIO weapons for 1 bless token\r\n    /// @dev when it has become negative -> user need to pay 1 weapons for abs(RATIO) bless token\r\n    function increaseRatio() internal {\r\n        if (ratio > 0) {\r\n            ratio = ratio / 5;\r\n\r\n            if (ratio == 0) {\r\n                ratio = -5;\r\n            }\r\n        } else {\r\n            ratio = ratio * 5;\r\n        }\r\n    }\r\n\r\n    /// @dev Check if current bless balance is ok for current ratio\r\n    function hasBalanceForRatio() internal returns (bool) {\r\n        uint256 minBalanceRequired = ratio > 0 ? 1 : SignedMath.abs(ratio);\r\n        return getBlessBalance() >= minBalanceRequired;\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n        ratio = 50;\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function investIntoPrizePool(uint256 amountToInvest) public payable syncBalances(msg.value) {\r\n        if (address(world.blessToken()) != address(0)) {\r\n            require(msg.value == 0, \"eth invest is disabled\");\r\n        }\r\n\r\n        if (address(world.blessToken()) == address(0)) {\r\n            invested += msg.value;\r\n        } else {\r\n            world.blessToken().transferFrom(msg.sender, address(this), amountToInvest);\r\n            invested += amountToInvest;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function handleEpochDestroyed() public override onlyWorld syncBalances(0) {\r\n        increaseRatio();\r\n\r\n        if (!hasBalanceForRatio()) {\r\n            world.setGameFinishTime(block.timestamp);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function swapWeaponsForTokens(uint256 weaponsAmount) public override nonReentrant syncBalances(0) {\r\n        IResource weapons = world.epochs(world.currentEpochNumber()).resources(\"WEAPON\");\r\n\r\n        uint256 tokensToBeReceived = 0;\r\n        if (ratio > 0) {\r\n            weaponsAmount = weaponsAmount - (weaponsAmount % uint256(ratio));\r\n            tokensToBeReceived = weaponsAmount / uint256(ratio);\r\n        } else {\r\n            tokensToBeReceived = weaponsAmount * SignedMath.abs(ratio);\r\n        }\r\n\r\n        weapons.transferFrom(msg.sender, address(this), weaponsAmount);\r\n        sendTokens(msg.sender, tokensToBeReceived);\r\n\r\n        if (!hasBalanceForRatio()) {\r\n            world.setGameFinishTime(block.timestamp);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function withdrawRepayment() public syncBalances(0) {}\r\n\r\n    receive() external payable {\r\n        require(address(world.blessToken()) == address(0), \"unable to receive ether bless token\");\r\n        emit RewardPoolUpdated();\r\n    }\r\n}\r\n"
    },
    "contracts/core/WorldInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IWorldInitializable.sol\";\r\n\r\n/// @title Abstract World initializable contract\r\n/// @notice Any contract which should be initialized with world should inherit this contract\r\nabstract contract WorldInitializable is IWorldInitializable, Initializable {\r\n    /// @inheritdoc IWorldInitializable\r\n    IWorld public override world;\r\n\r\n    /// @dev Allows caller to be only world or world asset\r\n    modifier onlyWorldAssetForEpoch(uint256 epoch) {\r\n        require(msg.sender == address(world) || world.worldAssets(epoch, msg.sender) != bytes32(0), \"onlyWorldAsset\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    modifier onlyActiveGame() {\r\n        uint256 gameFinishTime = world.gameFinishTime();\r\n        require(gameFinishTime == 0 || block.timestamp < gameFinishTime, \"game closed\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Initializes world by specified address, can be called only once\r\n    function setWorld(address worldAddress) internal onlyInitializing {\r\n        world = IWorld(worldAddress);\r\n    }\r\n\r\n    /// @dev Extracts registry from the world\r\n    function registry() internal view returns (IRegistry) {\r\n        return world.registry();\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/ProxyReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract ProxyReentrancyGuard {\r\n    bool private _status;\r\n\r\n    modifier nonReentrant() {\r\n        require(_status == false, \"ProxyReentrancyGuard: reentrant call\");\r\n        _status = true;\r\n        _;\r\n        _status = false;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "contracts/core/IWorldInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorld.sol\";\r\n\r\n/// @title Interface of the contract which will be initialized with world\r\n/// @notice Contains access to world storage variable\r\ninterface IWorldInitializable {\r\n    // State variables\r\n\r\n    /// @notice World\r\n    /// @dev Should be immutable and initialized only once\r\n    function world() external view returns (IWorld);\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/SettlementMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"./ISettlementMarket.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\nimport \"../../../periphery/ProxyReentrancyGuard.sol\";\r\n\r\ncontract SettlementsMarket is WorldAsset, ISettlementsMarket, ProxyReentrancyGuard {\r\n    /// @inheritdoc ISettlementsMarket\r\n    IZone public override currentZone;\r\n    /// @inheritdoc ISettlementsMarket\r\n    uint256 public override lastPurchaseTime;\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function init(address zoneAddress) public override initializer {\r\n        currentZone = IZone(zoneAddress);\r\n        lastPurchaseTime = block.timestamp;\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function buySettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 maxTokensToUse\r\n    ) public payable override onlyActiveGame nonReentrant {\r\n        address owner = world().bannerContract().ownerOf(ownerTokenId);\r\n        require(msg.sender == owner, \"nft does not belongs to you\");\r\n\r\n        IGeography geography = world().geography();\r\n        IGeography.GameTile memory gameTile = geography.getGameTile(position);\r\n        require(gameTile.zoneId == currentZone.zoneIndex(), \"position is not part of zone\");\r\n\r\n        uint256 newSettlementCost = getNewSettlementCost();\r\n\r\n        require(maxTokensToUse >= newSettlementCost, \"maxTokensToUse < newSettlementCost\");\r\n\r\n        if (address(world().blessToken()) == address(0)) {\r\n            require(msg.value >= newSettlementCost, \"insufficient value sent\");\r\n            uint256 valueToSendBack = msg.value > newSettlementCost ? msg.value - newSettlementCost : 0;\r\n\r\n            if (valueToSendBack > 0) {\r\n                Address.sendValue(payable(msg.sender), valueToSendBack);\r\n            }\r\n\r\n            Address.sendValue(payable(address(world().rewardPool())), newSettlementCost);\r\n        } else {\r\n            require(msg.value == 0, \"unusable funds sent\");\r\n            world().blessToken().transferFrom(msg.sender, address(world().rewardPool()), newSettlementCost);\r\n        }\r\n\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        uint256 newSettlementStartingPrice = newSettlementCost + newSettlementCost / 5;\r\n\r\n        address settlementAddress = epoch().newSettlement(position, ownerTokenId, newSettlementStartingPrice);\r\n        emit SettlementBought(settlementAddress, newSettlementCost);\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function getNewSettlementCost() public view override returns (uint256) {\r\n        uint256 _lastPurchaseTime = Math.max(lastPurchaseTime, world().gameStartTime());\r\n        uint256 _zoneIndex = currentZone.zoneIndex();\r\n\r\n        uint256 userSettlementsCount = world().crossEpochsMemory().zoneUserSettlementsCount(_zoneIndex);\r\n        uint256 newSettlementStartingPrice = world().crossEpochsMemory().zoneSettlementStartingPrice(_zoneIndex);\r\n\r\n        if (userSettlementsCount == 0) {\r\n            newSettlementStartingPrice = registry().getNewSettlementStartingPrice();\r\n        }\r\n\r\n        if (_lastPurchaseTime >= block.timestamp) {\r\n            return newSettlementStartingPrice;\r\n        }\r\n\r\n        uint256 secondsPassed = block.timestamp - _lastPurchaseTime;\r\n        if (secondsPassed == 0) {\r\n            return newSettlementStartingPrice;\r\n        }\r\n\r\n        uint256 hoursPassed = secondsPassed / 3600;\r\n        uint256 nextHour = hoursPassed + 1;\r\n\r\n        int128 hourPriceDrop64 = ABDKMath64x64.sub(\r\n            ABDKMath64x64.fromUInt(1),\r\n            ABDKMath64x64.div(\r\n                ABDKMath64x64.divu(75, 100),\r\n                ABDKMath64x64.pow(ABDKMath64x64.divu(12, 10), userSettlementsCount)\r\n            )\r\n        );\r\n\r\n        int128 closestHourPriceDrop64 = ABDKMath64x64.pow(hourPriceDrop64, hoursPassed);\r\n        int128 nextHourPriceDrop64 = ABDKMath64x64.pow(hourPriceDrop64, nextHour);\r\n        int128 currentHourPercentPassed = ABDKMath64x64.divu(secondsPassed % 3600, 3600);\r\n\r\n        int128 priceDrop64 = ABDKMath64x64.sub(\r\n            closestHourPriceDrop64,\r\n            ABDKMath64x64.mul(ABDKMath64x64.sub(closestHourPriceDrop64, nextHourPriceDrop64), currentHourPercentPassed)\r\n        );\r\n\r\n        return uint256(ABDKMath64x64.muli(priceDrop64, int256(newSettlementStartingPrice)));\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ABDKMath64x64.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function fromInt (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n        return int128 (x << 64);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n    function toInt (int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n        return int64 (x >> 64);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function fromUInt (uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x <= 0x7FFFFFFFFFFFFFFF);\r\n        return int128 (int256 (x << 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n    function toUInt (int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n        require (x >= 0);\r\n        return uint64 (uint128 (x >> 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function from128x128 (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = x >> 64;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n    function to128x128 (int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n        return int256 (x) << 64;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function add (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) + y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) - y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) * y >> 64;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n    function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n        if (x == MIN_64x64) {\r\n            require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n            y <= 0x1000000000000000000000000000000000000000000000000);\r\n            return -y << 63;\r\n        } else {\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x;\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint256 absoluteResult = mulu (x, uint256 (y));\r\n            if (negativeResult) {\r\n                require (absoluteResult <=\r\n                    0x8000000000000000000000000000000000000000000000000000000000000000);\r\n                return -int256 (absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require (absoluteResult <=\r\n                    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int256 (absoluteResult);\r\n            }\r\n        }\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n    function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n        if (y == 0) return 0;\r\n\r\n        require (x >= 0);\r\n\r\n        uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n        uint256 hi = uint256 (int256 (x)) * (y >> 128);\r\n\r\n        require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        hi <<= 64;\r\n\r\n        require (hi <=\r\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n        return hi + lo;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function div (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n        int256 result = (int256 (x) << 64) / y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n\r\n        bool negativeResult = false;\r\n        if (x < 0) {\r\n            x = -x; // We rely on overflow behavior here\r\n            negativeResult = true;\r\n        }\r\n        if (y < 0) {\r\n            y = -y; // We rely on overflow behavior here\r\n            negativeResult = !negativeResult;\r\n        }\r\n        uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n        if (negativeResult) {\r\n            require (absoluteResult <= 0x80000000000000000000000000000000);\r\n            return -int128 (absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n            require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return int128 (absoluteResult); // We rely on overflow behavior here\r\n        }\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n        uint128 result = divuu (x, y);\r\n        require (result <= uint128 (MAX_64x64));\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function neg (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != MIN_64x64);\r\n        return -x;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function abs (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != MIN_64x64);\r\n        return x < 0 ? -x : x;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function inv (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != 0);\r\n        int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        return int128 ((int256 (x) + int256 (y)) >> 1);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 m = int256 (x) * int256 (y);\r\n        require (m >= 0);\r\n        require (m <\r\n            0x4000000000000000000000000000000000000000000000000000000000000000);\r\n        return int128 (sqrtu (uint256 (m)));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        bool negative = x < 0 && y & 1 == 1;\r\n\r\n        uint256 absX = uint128 (x < 0 ? -x : x);\r\n        uint256 absResult;\r\n        absResult = 0x100000000000000000000000000000000;\r\n\r\n        if (absX <= 0x10000000000000000) {\r\n            absX <<= 63;\r\n            while (y != 0) {\r\n                if (y & 0x1 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x2 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x4 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x8 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                y >>= 4;\r\n            }\r\n\r\n            absResult >>= 64;\r\n        } else {\r\n            uint256 absXShift = 63;\r\n            if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\r\n            if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\r\n            if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\r\n            if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\r\n            if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\r\n            if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\r\n\r\n            uint256 resultShift = 0;\r\n            while (y != 0) {\r\n                require (absXShift < 64);\r\n\r\n                if (y & 0x1 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                    resultShift += absXShift;\r\n                    if (absResult > 0x100000000000000000000000000000000) {\r\n                        absResult >>= 1;\r\n                        resultShift += 1;\r\n                    }\r\n                }\r\n                absX = absX * absX >> 127;\r\n                absXShift <<= 1;\r\n                if (absX >= 0x100000000000000000000000000000000) {\r\n                    absX >>= 1;\r\n                    absXShift += 1;\r\n                }\r\n\r\n                y >>= 1;\r\n            }\r\n\r\n            require (resultShift < 64);\r\n            absResult >>= 64 - resultShift;\r\n        }\r\n        int256 result = negative ? -int256 (absResult) : int256 (absResult);\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function sqrt (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x >= 0);\r\n        return int128 (sqrtu (uint256 (int256 (x)) << 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function log_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x > 0);\r\n\r\n        int256 msb = 0;\r\n        int256 xc = x;\r\n        if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n        int256 result = msb - 64 << 64;\r\n        uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\r\n        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n            ux *= ux;\r\n            uint256 b = ux >> 255;\r\n            ux >>= 127 + b;\r\n            result += bit * int256 (b);\r\n        }\r\n\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function ln (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x > 0);\r\n\r\n        return int128 (int256 (\r\n                uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function exp_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x < 0x400000000000000000); // Overflow\r\n\r\n        if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n        uint256 result = 0x80000000000000000000000000000000;\r\n\r\n        if (x & 0x8000000000000000 > 0)\r\n            result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n        if (x & 0x4000000000000000 > 0)\r\n            result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n        if (x & 0x2000000000000000 > 0)\r\n            result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n        if (x & 0x1000000000000000 > 0)\r\n            result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n        if (x & 0x800000000000000 > 0)\r\n            result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n        if (x & 0x400000000000000 > 0)\r\n            result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n        if (x & 0x200000000000000 > 0)\r\n            result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n        if (x & 0x100000000000000 > 0)\r\n            result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n        if (x & 0x80000000000000 > 0)\r\n            result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n        if (x & 0x40000000000000 > 0)\r\n            result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n        if (x & 0x20000000000000 > 0)\r\n            result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n        if (x & 0x10000000000000 > 0)\r\n            result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n        if (x & 0x8000000000000 > 0)\r\n            result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n        if (x & 0x4000000000000 > 0)\r\n            result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n        if (x & 0x2000000000000 > 0)\r\n            result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n        if (x & 0x1000000000000 > 0)\r\n            result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n        if (x & 0x800000000000 > 0)\r\n            result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n        if (x & 0x400000000000 > 0)\r\n            result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n        if (x & 0x200000000000 > 0)\r\n            result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n        if (x & 0x100000000000 > 0)\r\n            result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n        if (x & 0x80000000000 > 0)\r\n            result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n        if (x & 0x40000000000 > 0)\r\n            result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n        if (x & 0x20000000000 > 0)\r\n            result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n        if (x & 0x10000000000 > 0)\r\n            result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n        if (x & 0x8000000000 > 0)\r\n            result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n        if (x & 0x4000000000 > 0)\r\n            result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n        if (x & 0x2000000000 > 0)\r\n            result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n        if (x & 0x1000000000 > 0)\r\n            result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n        if (x & 0x800000000 > 0)\r\n            result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n        if (x & 0x400000000 > 0)\r\n            result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n        if (x & 0x200000000 > 0)\r\n            result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n        if (x & 0x100000000 > 0)\r\n            result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n        if (x & 0x80000000 > 0)\r\n            result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n        if (x & 0x40000000 > 0)\r\n            result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n        if (x & 0x20000000 > 0)\r\n            result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n        if (x & 0x10000000 > 0)\r\n            result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n        if (x & 0x8000000 > 0)\r\n            result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n        if (x & 0x4000000 > 0)\r\n            result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n        if (x & 0x2000000 > 0)\r\n            result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n        if (x & 0x1000000 > 0)\r\n            result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n        if (x & 0x800000 > 0)\r\n            result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n        if (x & 0x400000 > 0)\r\n            result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n        if (x & 0x200000 > 0)\r\n            result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n        if (x & 0x100000 > 0)\r\n            result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n        if (x & 0x80000 > 0)\r\n            result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n        if (x & 0x40000 > 0)\r\n            result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n        if (x & 0x20000 > 0)\r\n            result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n        if (x & 0x10000 > 0)\r\n            result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n        if (x & 0x8000 > 0)\r\n            result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n        if (x & 0x4000 > 0)\r\n            result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n        if (x & 0x2000 > 0)\r\n            result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n        if (x & 0x1000 > 0)\r\n            result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n        if (x & 0x800 > 0)\r\n            result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n        if (x & 0x400 > 0)\r\n            result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n        if (x & 0x200 > 0)\r\n            result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n        if (x & 0x100 > 0)\r\n            result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n        if (x & 0x80 > 0)\r\n            result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n        if (x & 0x40 > 0)\r\n            result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n        if (x & 0x20 > 0)\r\n            result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n        if (x & 0x10 > 0)\r\n            result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n        if (x & 0x8 > 0)\r\n            result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n        if (x & 0x4 > 0)\r\n            result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n        if (x & 0x2 > 0)\r\n            result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n        if (x & 0x1 > 0)\r\n            result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n        result >>= uint256 (int256 (63 - (x >> 64)));\r\n        require (result <= uint256 (int256 (MAX_64x64)));\r\n\r\n        return int128 (int256 (result));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function exp (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x < 0x400000000000000000); // Overflow\r\n\r\n        if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n        return exp_2 (\r\n            int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n    function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n        require (y != 0);\r\n\r\n        uint256 result;\r\n\r\n        if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            result = (x << 64) / y;\r\n        else {\r\n            uint256 msb = 192;\r\n            uint256 xc = x >> 192;\r\n            if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n            if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n            if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n            if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n            if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n            if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n            result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n            require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n            uint256 hi = result * (y >> 128);\r\n            uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n            uint256 xh = x >> 192;\r\n            uint256 xl = x << 64;\r\n\r\n            if (xl < lo) xh -= 1;\r\n            xl -= lo; // We rely on overflow behavior here\r\n            lo = hi << 128;\r\n            if (xl < lo) xh -= 1;\r\n            xl -= lo; // We rely on overflow behavior here\r\n\r\n            assert (xh == hi >> 128);\r\n\r\n            result += xl / y;\r\n        }\r\n\r\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return uint128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n    function sqrtu (uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n            if (xx >= 0x8) { r <<= 1; }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint128 (r < r1 ? r : r1);\r\n        }\r\n    }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/WorkersPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"./IWorkersPool.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../../IWorld.sol\";\r\nimport \"../zone/IZone.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\n\r\ncontract WorkersPool is WorldAsset, IWorkersPool {\r\n    /// @inheritdoc IWorkersPool\r\n    IZone public override currentZone;\r\n    /// @inheritdoc IWorkersPool\r\n    uint256 public override lastPurchaseTime;\r\n    /// @inheritdoc IWorkersPool\r\n    uint256 public override startingPrice;\r\n\r\n    /// @inheritdoc IWorkersPool\r\n    function init(\r\n        address zoneAddress\r\n    ) public override initializer {\r\n        currentZone = IZone(zoneAddress);\r\n        lastPurchaseTime = block.timestamp;\r\n        startingPrice = 20e18;\r\n    }\r\n\r\n    /// @dev Returns prosperity\r\n    function prosperity() internal view returns (IProsperity) {\r\n        return epoch().prosperity();\r\n    }\r\n\r\n    /// @dev Returns workers\r\n    function workers() internal view returns (IWorkers) {\r\n        return epoch().workers();\r\n    }\r\n\r\n    /// @dev Calculates dropped price after last purchase time\r\n    function getDroppedPrice() internal view returns (int128) {\r\n        uint256 secondsPassed = block.timestamp - Math.max(lastPurchaseTime, world().gameStartTime());\r\n        int128 startingPrice64 = ABDKMath64x64.divu(startingPrice, 1e18);\r\n\r\n        //33% drop in 1 day (67% leftover)\r\n        int128 priceDropPerSecond64 = ABDKMath64x64.divu(9999953648537215, 10000000000000000);\r\n        int128 priceDrop64 = ABDKMath64x64.pow(priceDropPerSecond64, secondsPassed);\r\n        return ABDKMath64x64.mul(startingPrice64, priceDrop64);\r\n    }\r\n\r\n    /// @dev Calculates amount of prosperity and new starting price according to amount of workers and price shift per worker interaction with the pool\r\n    function calculatePriceShiftForUnits(\r\n        uint256 amountOfWorkers,\r\n        int128 priceShiftPerWorker64\r\n    ) internal view returns (uint256, uint256) {\r\n        int128 droppedPrice = getDroppedPrice();\r\n        int128 lastWorkerPriceShift64 = ABDKMath64x64.pow(\r\n            priceShiftPerWorker64,\r\n            amountOfWorkers\r\n        );\r\n\r\n        int128 sumOfPriceShifts64 = ABDKMath64x64.div(\r\n            ABDKMath64x64.sub(\r\n                lastWorkerPriceShift64,\r\n                ABDKMath64x64.fromUInt(1)\r\n            ),\r\n            ABDKMath64x64.ln(priceShiftPerWorker64)\r\n        );\r\n\r\n        int128 prosperityForPriceShift64 = ABDKMath64x64.mul(droppedPrice, sumOfPriceShifts64);\r\n        int128 newStartingPrice64 = ABDKMath64x64.mul(droppedPrice, lastWorkerPriceShift64);\r\n\r\n        uint256 prosperityForPriceShift = uint256(ABDKMath64x64.muli(prosperityForPriceShift64, 1e18));\r\n        uint256 newStartingPrice = uint256(ABDKMath64x64.muli(newStartingPrice64, 1e18));\r\n\r\n        return (prosperityForPriceShift, newStartingPrice);\r\n    }\r\n\r\n    /// @inheritdoc IWorkersPool\r\n    function getAmountIn(uint256 unitsToBuy) public view override returns (uint256, uint256) {\r\n        int128 priceIncreasePerWorker64 = ABDKMath64x64.divu(1004, 1000);\r\n        return calculatePriceShiftForUnits(unitsToBuy, priceIncreasePerWorker64);\r\n    }\r\n\r\n    /// @inheritdoc IWorkersPool\r\n    function swapProsperityForExactWorkers(\r\n        uint256 workersToBuy,\r\n        uint256 maxProsperityToSell\r\n    )\r\n        public\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(workersToBuy >= 1e18, \"Insufficient workers buy amount\");\r\n        require(MathExtension.isIntegerWithPrecision(workersToBuy, 1e18), \"Not integer amount of workers to buy specified\");\r\n        require(maxProsperityToSell > 0, \"Insufficient maximum prosperity sell amount\");\r\n\r\n        ISettlement(msg.sender).massUpdate();\r\n\r\n        (uint256 prosperityToSell, uint256 newStartingPrice) = getAmountIn(workersToBuy / 1e18);\r\n\r\n        require(prosperityToSell <= maxProsperityToSell, \"Prosperity to sell is more than specified limit\");\r\n\r\n        IProsperity prosperity = prosperity();\r\n        IWorkers workers = workers();\r\n\r\n        prosperity.spend(msg.sender, prosperityToSell);\r\n        workers.mint(msg.sender, workersToBuy);\r\n\r\n        startingPrice = newStartingPrice;\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        emit WorkersBought(\r\n            msg.sender,\r\n            workersToBuy,\r\n            prosperityToSell\r\n        );\r\n\r\n        return workersToBuy;\r\n    }\r\n}\r\n"
    },
    "contracts/core/distributions/Distributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./IDistributions.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"../assets/building/IBuilding.sol\";\r\nimport \"../assets/IWorldAsset.sol\";\r\nimport \"../assets/WorldAssetStorageAccessor.sol\";\r\n\r\ncontract Distributions is IDistributions, ERC1155, Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /// @dev Contains set of holders for specified nft id\r\n    mapping(uint256 => EnumerableSet.AddressSet) private distributionReceivers;\r\n\r\n    /// @inheritdoc IDistributions\r\n    IWorld public override world;\r\n    /// @inheritdoc IDistributions\r\n    mapping(uint256 => address) public override distributionIdToBuildingAddress;\r\n    /// @inheritdoc IDistributions\r\n    uint256 public override lastDistributionId;\r\n\r\n    constructor(\r\n        address worldAddress_,\r\n        string memory uri_\r\n    ) ERC1155(uri_) {\r\n        world = IWorld(worldAddress_);\r\n    }\r\n\r\n    /// @dev Allows caller to be only world asset from same epoch\r\n    modifier onlyWorldAssetFromSameEpoch() {\r\n        uint256 epochNumber = WorldAssetStorageAccessor(msg.sender).epochNumber();\r\n        require(world.worldAssets(epochNumber, msg.sender) != bytes32(0), \"onlyWorldAssetFromSameEpoch\");\r\n        _;\r\n    }\r\n\r\n    /// @dev ERC1155 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal override {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            address buildingAddress = distributionIdToBuildingAddress[ids[i]];\r\n            if (buildingAddress == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            IBuilding building = IBuilding(buildingAddress);\r\n            building.distributeToSingleShareholder(from);\r\n            building.distributeToSingleShareholder(to);\r\n        }\r\n    }\r\n\r\n    /// @dev ERC1155 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal override {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            EnumerableSet.AddressSet storage receivers = distributionReceivers[ids[i]];\r\n\r\n            if (from != address(0) && balanceOf(from, ids[i]) == 0) {\r\n                receivers.remove(from);\r\n            }\r\n\r\n            // In case to is already a receiver -> this will do nothing\r\n            receivers.add(to);\r\n\r\n            // Its required to fix produced resource debt for both 'from' and 'to' in order to valid resources distribution\r\n            address buildingAddress = distributionIdToBuildingAddress[ids[i]];\r\n            if (buildingAddress != address(0)) {\r\n                IBuilding(buildingAddress).fixDebtAccordingToNewDistributionsAmounts(from, to, amounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Updates token uri\r\n    /// @dev Only owner can modify token uri\r\n    function updateURI(string memory _newUri) public onlyOwner {\r\n        _setURI(_newUri);\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function getDistributionReceivers(uint256 distributionId) public view returns (address[] memory) {\r\n        return distributionReceivers[distributionId].values();\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function mint(\r\n        address to\r\n    ) public onlyWorldAssetFromSameEpoch returns (uint256) {\r\n        uint256 newDistributionId = lastDistributionId + 1;\r\n\r\n        _mint(\r\n            to,\r\n            newDistributionId,\r\n            getItemsPerNft(),\r\n            bytes(\"\")\r\n        );\r\n\r\n        lastDistributionId = newDistributionId;\r\n        distributionIdToBuildingAddress[newDistributionId] = msg.sender;\r\n        return newDistributionId;\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function getItemsPerNft() public pure returns (uint256) {\r\n        return 100;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/core/tokens/workers/Workers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"../../WorldInitializable.sol\";\r\nimport \"../../assets/building/IBuilding.sol\";\r\nimport \"../../assets/workersPool/IWorkersPool.sol\";\r\nimport \"./IWorkers.sol\";\r\n\r\ncontract Workers is ERC20Burnable, IWorkers, WorldInitializable {\r\n    /// @notice Bytes32 value for any worker market asset type\r\n    /// @dev Used for determination if workers went from/to workers market\r\n    bytes32 public constant WORKERS_POOL_ASSET_TYPE = keccak256(bytes(\"workersPool\"));\r\n    /// @notice Bytes32 value for settlement asset type\r\n    /// @dev Used for determination if workers went from/to settlement\r\n    bytes32 public constant SETTLEMENT_ASSET_TYPE = keccak256(bytes(\"settlement\"));\r\n    /// @notice Bytes32 value for any building asset type\r\n    /// @dev Used for determination if workers went from/to building\r\n    bytes32 public constant BUILDING_ASSET_TYPE = keccak256(bytes(\"building\"));\r\n    /// @notice Epoch number\r\n    /// @dev To which epoch number current workers is related to\r\n    uint256 public epochNumber;\r\n\r\n    constructor(\r\n        address worldAddress,\r\n        uint256 epoch\r\n    ) public ERC20(\r\n        string.concat(\"Workers @\", Strings.toString(epoch)),\r\n        string.concat(\"WRK @\", Strings.toString(epoch))\r\n    ) initializer {\r\n        setWorld(worldAddress);\r\n        epochNumber = epoch;\r\n    }\r\n\r\n    /// @dev ERC20 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (world.worldAssets(epochNumber, from) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(from).productionChanged();\r\n        }\r\n\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(to).productionChanged();\r\n        }\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        bool isFromWorkersPool = world.worldAssets(epochNumber, from) == WORKERS_POOL_ASSET_TYPE;\r\n        bool isFromSettlement = world.worldAssets(epochNumber, from) == SETTLEMENT_ASSET_TYPE;\r\n        bool isFromBuilding = world.worldAssets(epochNumber, from) == BUILDING_ASSET_TYPE;\r\n\r\n        //From can be address(0) or settlement or building\r\n        require(from == address(0) || isFromWorkersPool || isFromSettlement || isFromBuilding, \"invalid from\");\r\n\r\n        bool isToSettlement = world.worldAssets(epochNumber, to) == SETTLEMENT_ASSET_TYPE;\r\n        bool isToBuilding = world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE;\r\n\r\n        //To can be address(0) or workers market or settlement or building\r\n        require(to == address(0) || isToSettlement || isToBuilding, \"invalid to\");\r\n\r\n        //Workers can be minted to settlement\r\n        //Workers can be transferred from settlement to building\r\n        //Workers can be transferred from building to settlement\r\n        //Workers can be transferred from building to building\r\n        //Everything else is disabled\r\n\r\n        if (to == address(0)) {\r\n            return;\r\n        }\r\n\r\n        if (from == address(0) && isToSettlement) {\r\n            return;\r\n        }\r\n\r\n        if (isFromSettlement && isToBuilding && getSettlementByBuilding(to) == from) {\r\n            IBuilding(to).updateState();\r\n            return;\r\n        }\r\n\r\n        if (isFromBuilding && isToSettlement && getSettlementByBuilding(from) == to) {\r\n            IBuilding(from).updateState();\r\n            return;\r\n        }\r\n\r\n        if (isFromBuilding && isToBuilding && getSettlementByBuilding(from) == getSettlementByBuilding(to)) {\r\n            IBuilding(from).updateState();\r\n            IBuilding(to).updateState();\r\n            return;\r\n        }\r\n\r\n        revert(\"Worker transfer disabled\");\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world) || world.worldAssets(epochNumber, addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @dev Returns this buildings settlement\r\n    function getSettlementByBuilding(address buildingAddress) internal view returns (address) {\r\n        return address(IBuilding(buildingAddress).currentSettlement());\r\n    }\r\n\r\n    /// @inheritdoc IWorkers\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetForEpoch(epochNumber) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address from, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _burn(from, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(from, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            return ERC20.transferFrom(from, to, amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/workers/WorkersFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Workers.sol\";\r\nimport \"./IWorkersFactory.sol\";\r\n\r\ncontract WorkersFactory is IWorkersFactory {\r\n    /// @inheritdoc IWorkersFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epoch\r\n    ) public returns (address) {\r\n        return address(new Workers(worldAddress, epoch));\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/epoch/Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../zone/IZone.sol\";\r\nimport \"../settlement/ISettlementFactory.sol\";\r\nimport \"../zone/IZoneFactory.sol\";\r\nimport \"../../../libraries/UintUtils.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"./IEpoch.sol\";\r\nimport \"../../geography/IGeography.sol\";\r\nimport \"../../tokens/prosperity/IProsperityFactory.sol\";\r\nimport \"../../tokens/workers/IWorkersFactory.sol\";\r\nimport \"../../tokens/resources/IResourceFactory.sol\";\r\nimport \"../../tokens/units/IUnitsFactory.sol\";\r\n\r\ncontract Epoch is WorldAsset, IEpoch {\r\n    /// @inheritdoc IEpoch\r\n    mapping(uint256 => IZone) public override zones;\r\n    /// @inheritdoc IEpoch\r\n    mapping(uint32 => ISettlement) public override settlements;\r\n    /// @inheritdoc IEpoch\r\n    uint256 public override mostRecentCultistsSummonTime;\r\n    /// @inheritdoc IEpoch\r\n    uint256 public override totalCultists;\r\n\r\n    /// @inheritdoc IEpoch\r\n    IWorkers public override workers;\r\n    /// @inheritdoc IEpoch\r\n    IProsperity public override prosperity;\r\n    /// @inheritdoc IEpoch\r\n    mapping(string => IResource) public override resources;\r\n    /// @inheritdoc IEpoch\r\n    mapping(string => IUnits) public override units;\r\n\r\n    /// @inheritdoc IEpoch\r\n    mapping(uint256 => ISettlement) public override userSettlements;\r\n\r\n    /// @inheritdoc IEpoch\r\n    function init(uint256 epochNumber) public override initializer {\r\n        // 1. create new resources\r\n        IRegistry.GameResource[] memory gameResources = registry().getGameResources();\r\n        for (uint256 i = 0; i < gameResources.length; i++) {\r\n            IRegistry.GameResource memory gameResource = gameResources[i];\r\n\r\n            address resourceAddress = createNewResource(\r\n                gameResource.tokenName,\r\n                gameResource.tokenSymbol,\r\n                gameResource.worldResourceName,\r\n                epochNumber\r\n            );\r\n\r\n            resources[gameResource.worldResourceName] = IResource(resourceAddress);\r\n            emit NewResource(resourceAddress, gameResource.worldResourceName);\r\n        }\r\n\r\n        // 2. create new units\r\n        IRegistry.GameUnit[] memory gameUnits = registry().getGameUnits();\r\n        for (uint256 i = 0; i < gameUnits.length; i++) {\r\n            IRegistry.GameUnit memory gameUnit = gameUnits[i];\r\n\r\n            address unitsAddress = createNewUnits(\r\n                gameUnit.tokenName,\r\n                gameUnit.tokenSymbol,\r\n                gameUnit.worldUnitName,\r\n                epochNumber\r\n            );\r\n\r\n            units[gameUnit.worldUnitName] = IUnits(unitsAddress);\r\n            emit NewUnits(unitsAddress, gameUnit.worldUnitName);\r\n        }\r\n\r\n        // 3. create new workers\r\n        address workersAddress = createNewWorkers(epochNumber);\r\n        workers = IWorkers(workersAddress);\r\n        emit NewWorkers(workersAddress);\r\n\r\n        // 4. create new prosperity\r\n        address prosperityAddress = createNewProsperity(epochNumber);\r\n        prosperity = IProsperity(prosperityAddress);\r\n        emit NewProsperity(prosperityAddress);\r\n    }\r\n\r\n    function createNewProsperity(uint256 epoch) internal returns (address) {\r\n        IProsperityFactory prosperityFactory = IProsperityFactory(\r\n            registry().factoryContracts(keccak256(abi.encodePacked((\"prosperity\"))))\r\n        );\r\n\r\n        return prosperityFactory.create(address(world()), epoch);\r\n    }\r\n\r\n    function createNewWorkers(uint256 epoch) internal returns (address) {\r\n        IWorkersFactory workersFactory = IWorkersFactory(\r\n            registry().factoryContracts(keccak256(abi.encodePacked((\"workers\"))))\r\n        );\r\n\r\n        return workersFactory.create(address(world()), epoch);\r\n    }\r\n\r\n    /// @dev Creates new resource instance\r\n    function createNewResource(\r\n        string memory resourceName,\r\n        string memory resourceSymbol,\r\n        string memory worldResourceName,\r\n        uint256 epochNumber\r\n    ) internal returns (address) {\r\n        IResourceFactory resourceFactory = IResourceFactory(\r\n            registry().factoryContracts(keccak256(abi.encodePacked((\"resource\"))))\r\n        );\r\n\r\n        return resourceFactory.create(address(world()), epochNumber, resourceName, resourceSymbol, worldResourceName);\r\n    }\r\n\r\n    /// @dev Creates new units instance\r\n    function createNewUnits(\r\n        string memory unitName,\r\n        string memory unitSymbol,\r\n        string memory worldUnitName,\r\n        uint256 epoch\r\n    ) internal returns (address) {\r\n        IUnitsFactory unitsFactory = IUnitsFactory(registry().factoryContracts(keccak256(abi.encodePacked((\"units\")))));\r\n\r\n        return unitsFactory.create(address(world()), unitName, unitSymbol, worldUnitName, epoch);\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function activateZone(uint256 zoneIndex) public override {\r\n        require(address(zones[zoneIndex]) == address(0), \"Zone already activated\");\r\n\r\n        //2. create zone\r\n        IZoneFactory zoneFactory = IZoneFactory(registry().factoryContracts(keccak256(bytes(\"zone\"))));\r\n        address zoneAddress = zoneFactory.create(\r\n            address(world()),\r\n            epochNumber(),\r\n            \"BASIC\",\r\n            zoneIndex\r\n        );\r\n\r\n        IZone zone = IZone(zoneAddress);\r\n        zones[zoneIndex] = zone;\r\n        emit NewZoneActivated(zoneAddress, zoneIndex);\r\n\r\n        //3. creates zone cultists settlement\r\n        zone.createCultists(world().geography().getZoneActivationParams(zoneIndex).cultistsPosition);\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function restoreSettlement(\r\n        uint32 position\r\n    ) public override {\r\n        require(epochNumber() == world().currentEpochNumber(), \"settlement can be restored only in active epoch\");\r\n\r\n        ICrossEpochsMemory crossEpochsMemory = world().crossEpochsMemory();\r\n\r\n        uint256 positionOwnerTokenId = crossEpochsMemory.settlements(position).ownerTokenId();\r\n\r\n        address settlementAddress = this.newAssetSettlement(positionOwnerTokenId, position, \"BASIC\", false);\r\n        addUserSettlement(positionOwnerTokenId, settlementAddress);\r\n        crossEpochsMemory.handleUserSettlementRestored(position, settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function newSettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 newSettlementStartingPrice\r\n    ) public override onlyWorldAssetFromSameEpoch returns (address) {\r\n        ICrossEpochsMemory crossEpochsMemory = world().crossEpochsMemory();\r\n\r\n        require(address(crossEpochsMemory.userSettlements(ownerTokenId)) == address(0), \"nft is bound to settlement\");\r\n\r\n        uint256 gameStartTime = world().gameStartTime();\r\n        require(gameStartTime == 0 || block.timestamp >= gameStartTime, \"game is not started yet\");\r\n        require(epochNumber() == world().currentEpochNumber(), \"settlement can be placed only in active epoch\");\r\n\r\n        IGeography geography = world().geography();\r\n\r\n        IGeography.GameTile memory gameTile = geography.getGameTile(position);\r\n        IZone zone = zones[gameTile.zoneId];\r\n\r\n        require(\r\n            crossEpochsMemory.zoneUserSettlementsCount(gameTile.zoneId) < registry().getMaxSettlementPerZone(),\r\n            \"exceed max settlements per zone\"\r\n        );\r\n\r\n        address settlementAddress = this.newAssetSettlement(ownerTokenId, position, \"BASIC\", true);\r\n        addUserSettlement(ownerTokenId, settlementAddress);\r\n        crossEpochsMemory.handleNewUserSettlement(ownerTokenId, gameTile.zoneId, settlementAddress, newSettlementStartingPrice);\r\n        return settlementAddress;\r\n    }\r\n\r\n    /// @dev Calculates does any settlement exists in provided radius\r\n    function hasSettlementInRadius(uint32 position, uint256 radius) internal view returns (bool) {\r\n        for (uint256 i = 1; i <= radius; i++) {\r\n            if (hasSettlementInRingRadius(position, i)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Calculates does any settlement exists in provided ring radius\r\n    function hasSettlementInRingRadius(uint32 position, uint256 radius) internal view returns (bool) {\r\n        IGeography geography = world().geography();\r\n        ICrossEpochsMemory crossEpochsMemory = world().crossEpochsMemory();\r\n\r\n        (uint32[] memory ringPositions, uint256 ringPositionsLength) = geography.getRingPositions(position, radius);\r\n        for (uint256 i = 0; i < ringPositionsLength; i++) {\r\n            if (address(crossEpochsMemory.settlements(ringPositions[i])) != address(0)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Adds user settlement with its banner id\r\n    function addUserSettlement(uint256 ownerTokenId, address settlementAddress) internal {\r\n        require(address(userSettlements[ownerTokenId]) == address(0), \"token already in use\");\r\n        userSettlements[ownerTokenId] = ISettlement(settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function newAssetSettlement(\r\n        uint256 ownerTokenId,\r\n        uint32 position,\r\n        string memory assetName,\r\n        bool performAttachmentValidation\r\n    ) public override onlyWorldAssetFromSameEpoch returns (address) {\r\n        IGeography geography = world().geography();\r\n        IGeography.GameTile memory gameTile = geography.getGameTile(position);\r\n\r\n        require(gameTile.tileType != uint16(IGeography.TileType.VOID), \"cannot settle on void spot\");\r\n        require(address(settlements[position]) == address(0), \"settlement on this place already exists\");\r\n        require(!hasSettlementInRadius(position, 2), \"settlement in radius 2\");\r\n\r\n        if (performAttachmentValidation) {\r\n            require(hasSettlementInRingRadius(position, 3), \"no settlement in ring radius 3\");\r\n        }\r\n\r\n        ISettlementFactory settlementFactory = ISettlementFactory(\r\n            registry().factoryContracts(keccak256(bytes((\"settlement\"))))\r\n        );\r\n\r\n        address zoneAddress = address(zones[gameTile.zoneId]);\r\n        address settlementAddress = settlementFactory.create(\r\n            address(world()),\r\n            epochNumber(),\r\n            assetName,\r\n            ownerTokenId,\r\n            zoneAddress,\r\n            position\r\n        );\r\n\r\n        settlements[position] = ISettlement(settlementAddress);\r\n        world().crossEpochsMemory().handleNewSettlement(position, settlementAddress);\r\n\r\n        emit NewSettlement(settlementAddress, assetName, zoneAddress, position);\r\n\r\n        return settlementAddress;\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function summonCultistsBatch(uint256[] memory zoneIndices) public override {\r\n        for (uint256 i = 0; i < zoneIndices.length; i++) {\r\n            zones[zoneIndices[i]].summonCultists();\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function increaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEpoch {\r\n        totalCultists += value;\r\n        mostRecentCultistsSummonTime = block.timestamp;\r\n    }\r\n\r\n    /// @inheritdoc IEpoch\r\n    function decreaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEpoch {\r\n        totalCultists -= value;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/zone/IZoneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Zone factory interface\r\n/// @notice Contains instance creator function\r\ninterface IZoneFactory {\r\n    /// @notice Creates Zone instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the army type (Currently only 'BASIC')\r\n    /// @param zoneIndex Zone index\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        uint256 zoneIndex\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/libraries/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Utils for math operations with uint16\r\n/// @notice Contains helper functions for some math operations\r\nlibrary UintUtils {\r\n    /// @dev Checks if adding two uint16 values will overflow or not\r\n    function canAdd(uint16 variable, uint16 value) public pure returns (bool) {\r\n        return (variable + value >= variable);\r\n    }\r\n\r\n    /// @dev Checks if subtracting two uint16 values will underflow or not\r\n    function canSubtract(uint16 variable, uint16 value) public pure returns (bool) {\r\n        return (value <= variable - value);\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/units/UnitsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Units.sol\";\r\nimport \"./IUnitsFactory.sol\";\r\n\r\ncontract UnitsFactory is IUnitsFactory {\r\n    /// @inheritdoc IUnitsFactory\r\n    function create(\r\n        address worldAddress,\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        string memory worldUnitName,\r\n        uint256 epoch\r\n    ) public returns (address) {\r\n        return address(new Units(worldAddress, tokenName, tokenSymbol, worldUnitName, epoch));\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/units/Units.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"../../WorldInitializable.sol\";\r\nimport \"./IUnits.sol\";\r\nimport \"../../assets/building/IBuilding.sol\";\r\nimport \"../../assets/unitsPool/IUnitsPool.sol\";\r\nimport \"../../assets/IWorldAssetStorageAccessor.sol\";\r\n\r\ncontract Units is ERC20Burnable, IUnits, WorldInitializable {\r\n    /// @notice Bytes 32 value for cultists settlement type\r\n    /// @dev Used for determination if units went from/to cultists army\r\n    bytes32 public constant CULTISTS_SETTLEMENT_TYPE = keccak256(bytes(\"CULTISTS\"));\r\n    /// @notice Bytes32 value for any army asset type\r\n    /// @dev Used for determination if unit went from/to army\r\n    bytes32 public constant ARMY_ASSET_TYPE = keccak256(bytes(\"army\"));\r\n    /// @notice Bytes32 value for any units market asset type\r\n    /// @dev Used for determination if unit went from/to units market\r\n    bytes32 public constant UNITS_POOL_ASSET_TYPE = keccak256(bytes(\"unitsPool\"));\r\n\r\n    /// @inheritdoc IUnits\r\n    uint256 public override epochNumber;\r\n    /// @inheritdoc IUnits\r\n    string public override worldUnitName;\r\n\r\n    constructor(\r\n        address worldAddress,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        string memory _worldUnitName,\r\n        uint256 epoch\r\n    )\r\n        public\r\n        ERC20(\r\n            string.concat(string.concat(_tokenName, \" @\"), Strings.toString(epoch)),\r\n            string.concat(string.concat(_tokenSymbol, \" @\"), Strings.toString(epoch))\r\n        )\r\n        initializer\r\n    {\r\n        setWorld(worldAddress);\r\n        worldUnitName = _worldUnitName;\r\n        epochNumber = epoch;\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        //1. If Cultists is minted/burned -> updateState in zone (in order to apply workers before cultists penalty is applied)\r\n        // Mint units\r\n        if (from == address(0) && world.worldAssets(epochNumber, to) == ARMY_ASSET_TYPE) {\r\n            IZone zone = IArmy(to).currentSettlement().currentZone();\r\n\r\n            if (address(zone.cultistsSettlement().army()) == to) {\r\n                zone.updateState();\r\n            }\r\n        }\r\n\r\n        // Burn units\r\n        if (to == address(0) && world.worldAssets(epochNumber, from) == ARMY_ASSET_TYPE) {\r\n            IZone zone = IArmy(from).currentSettlement().currentZone();\r\n\r\n            if (address(zone.cultistsSettlement().army()) == from) {\r\n                zone.updateState();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev ERC20 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        // Minting\r\n        if (from == address(0) && world.worldAssets(epochNumber, to) == ARMY_ASSET_TYPE && isCultistsArmy(to)) {\r\n            IArmy(to).currentSettlement().currentZone().handleCultistsSummoned(to, amount);\r\n        }\r\n\r\n        // Burning\r\n        if (world.worldAssets(epochNumber, from) == ARMY_ASSET_TYPE && to == address(0) && isCultistsArmy(from)) {\r\n            IArmy(from).currentSettlement().currentZone().handleCultistsDefeated(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if provided army address belongs to cultists settlement or not\r\n    function isCultistsArmy(address armyAddress) internal view returns (bool) {\r\n        address armiesSettlementAddress = address(IArmy(armyAddress).currentSettlement());\r\n        return keccak256(bytes(IWorldAssetStorageAccessor(armiesSettlementAddress).assetType())) == CULTISTS_SETTLEMENT_TYPE;\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world) || world.worldAssets(epochNumber, addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IUnits\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetForEpoch(epochNumber) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer is disabled\r\n    /// @inheritdoc IERC20\r\n    function transfer(address to, uint256 amount) public override(ERC20, IERC20) returns (bool success) {\r\n        revert(\"function disabled\");\r\n    }\r\n\r\n    /// @notice Transfer from is disabled\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool success) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            revert(\"function disabled\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/resources/Resource.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"../../WorldInitializable.sol\";\r\nimport \"./IResource.sol\";\r\nimport \"../../assets/building/IBuilding.sol\";\r\nimport \"../../assets/unitsPool/IUnitsPool.sol\";\r\n\r\ncontract Resource is ERC20Burnable, IResource, WorldInitializable {\r\n    /// @notice Bytes32 value for any building asset type\r\n    /// @dev Used for determination if resource went from/to building\r\n    bytes32 public constant BUILDING_ASSET_TYPE = keccak256(bytes(\"building\"));\r\n    /// @notice Bytes32 value for any units pool asset type\r\n    /// @dev Used for determination if resource went from/to units market\r\n    bytes32 public constant UNITS_POOL_ASSET_TYPE = keccak256(bytes(\"unitsPool\"));\r\n    /// @notice Name of the resource inside world.resources\r\n    /// @dev Used for modification of behaviour of certain functions\r\n    string public worldResourceName;\r\n    /// @notice Epoch number\r\n    /// @dev To which epoch number current resource is related to\r\n    uint256 public epochNumber;\r\n\r\n    constructor(\r\n        address worldAddress,\r\n        uint256 _epochNumber,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        string memory _worldResourceName\r\n    )\r\n        public\r\n        ERC20(\r\n            string.concat(string.concat(_tokenName, \" @\"), Strings.toString(_epochNumber)),\r\n            string.concat(string.concat(_tokenSymbol, \" @\"), Strings.toString(_epochNumber))\r\n        )\r\n        initializer\r\n    {\r\n        setWorld(worldAddress);\r\n        worldResourceName = _worldResourceName;\r\n        epochNumber = _epochNumber;\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (world.worldAssets(epochNumber, from) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(from).updateState();\r\n        }\r\n\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(to).updateState();\r\n        }\r\n    }\r\n\r\n    /// @dev ERC20 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (world.worldAssets(epochNumber, from) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(from).productionChanged();\r\n\r\n            // If anyone takes production resource from building -> we consider them as unlocked and increase zone toxicity\r\n            if (to != address(0) && isRequiredForBuildingProduction(worldResourceName, from)) {\r\n                ISettlement settlementOfBuilding = IBuilding(from).currentSettlement();\r\n                settlementOfBuilding.currentZone().increaseToxicity(address(settlementOfBuilding), worldResourceName, amount);\r\n            }\r\n        }\r\n\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE) {\r\n            IBuilding(to).productionChanged();\r\n\r\n            // If anyone sends resource to building -> we consider them as locked and we should lower its zone toxicity\r\n            // however it is done at #_transfer override since we need to decrease toxicity for all amount (not for amount building receives)\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if provided resource is required for building production\r\n    function isRequiredForBuildingProduction(string memory resourceType, address buildingAddress) internal view returns (bool) {\r\n        bytes32 resourceBytes = keccak256(bytes(resourceType));\r\n\r\n        IBuilding.InitialResourceBlock[] memory initialResourceBlocks = IBuilding(buildingAddress).getConfig();\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            if (!initialResourceBlocks[i].isProducing && resourceBytes == keccak256(bytes(initialResourceBlocks[i].resourceName))) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Checks if provided address is reward pool\r\n    function isRewardPool(address addressToCheck) internal view returns (bool) {\r\n        return address(world.rewardPool()) == addressToCheck;\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world) || world.worldAssets(epochNumber, addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IResource\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetForEpoch(epochNumber) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transferred disabled if trying to transfer to the game building which does not use this resource\r\n    /// @inheritdoc IERC20\r\n    function transfer(address to, uint256 amount) public override(ERC20, IERC20) returns (bool success) {\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE && !IBuilding(to).isResourceAcceptable(worldResourceName)) {\r\n            revert(\"resource is not acceptable\");\r\n        }\r\n\r\n        return ERC20.transfer(to, amount);\r\n    }\r\n\r\n    /// @notice Transferred disabled if trying to transfer to the game building which does not use this resource\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool success) {\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE && !IBuilding(to).isResourceAcceptable(worldResourceName)) {\r\n            revert(\"resource is not acceptable\");\r\n        }\r\n\r\n        if (isWorldAsset(msg.sender) || isRewardPool(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            return ERC20.transferFrom(from, to, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice If called for building then it returns amount of resource as if building state was applied\r\n    /// @inheritdoc IERC20\r\n    function balanceOf(address tokenOwner) public view override(ERC20, IERC20) returns (uint256) {\r\n        if (world.worldAssets(epochNumber, tokenOwner) == BUILDING_ASSET_TYPE) {\r\n            return IBuilding(tokenOwner).getResourcesAmount(worldResourceName, block.timestamp);\r\n        }\r\n\r\n        return ERC20.balanceOf(tokenOwner);\r\n    }\r\n\r\n    /// @inheritdoc IResource\r\n    function stateBalanceOf(address tokenOwner) public view override returns (uint256 balance) {\r\n        return ERC20.balanceOf(tokenOwner);\r\n    }\r\n\r\n    /// @notice Behaves same as default ERC20._transfer, however if resource is transferred to the building part of the resource is burned according to cultists balance\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (world.worldAssets(epochNumber, to) == BUILDING_ASSET_TYPE) {\r\n            ISettlement settlementOfBuilding = IBuilding(to).currentSettlement();\r\n            uint256 penalty = settlementOfBuilding.currentZone().getPenaltyFromCultists();\r\n\r\n            uint256 amountToBeBurned = amount * penalty / 1e18;\r\n            uint256 amountToBeSent = amount - amountToBeBurned;\r\n\r\n            ERC20._transfer(from, to, amountToBeSent);\r\n\r\n            if (amountToBeBurned > 0) {\r\n                ERC20._burn(from, amountToBeBurned);\r\n            }\r\n\r\n            settlementOfBuilding.currentZone().decreaseToxicity(address(settlementOfBuilding), worldResourceName, amount);\r\n        } else {\r\n            ERC20._transfer(from, to, amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/resources/ResourceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Resource.sol\";\r\nimport \"./IResourceFactory.sol\";\r\n\r\ncontract ResourceFactory is IResourceFactory {\r\n    /// @inheritdoc IResourceFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        string memory worldResourceName\r\n    ) public returns (address) {\r\n        Resource newResource = new Resource(worldAddress, epochNumber, tokenName, tokenSymbol, worldResourceName);\r\n        IWorld(worldAddress).addWorldAsset(epochNumber, address(newResource), keccak256(bytes(worldResourceName)));\r\n        return address(newResource);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/UnitsPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IUnitsPool.sol\";\r\nimport \"./IUnitsPoolFactory.sol\";\r\n\r\ncontract UnitsPoolFactory is IUnitsPoolFactory, WorldAssetFactory {\r\n    /// @inheritdoc IUnitsPoolFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress,\r\n        string memory unitsType\r\n    ) public returns (address) {\r\n        IUnitsPool unitsPool = IUnitsPool(createAndSet(worldAddress, epochNumber, \"unitsPool\", assetName));\r\n        unitsPool.init(zoneAddress, unitsType);\r\n        return address(unitsPool);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAssetProxy.sol\";\r\n\r\n/// @title Abstract world asset factory\r\n/// @notice Any world asset factory should inherit this abstract factory containing common method to create and set world asset\r\nabstract contract WorldAssetFactory {\r\n    /// @dev Allows caller to be only world or world asset\r\n    modifier onlyWorldOrWorldAsset(address worldAddress, uint256 epochNumber) {\r\n        require(\r\n            msg.sender == worldAddress || IWorld(worldAddress).worldAssets(epochNumber, msg.sender) != bytes32(0),\r\n            \"onlyWorldAsset\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Creates new world asset with specified world asset params and adds newly created asset to the world\r\n    function createAndSet(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetType,\r\n        string memory assetName\r\n    ) internal onlyWorldOrWorldAsset(worldAddress, epochNumber) returns (address) {\r\n        WorldAssetProxy newProxy = new WorldAssetProxy(worldAddress, epochNumber, assetType, assetName);\r\n        IWorld(worldAddress).addWorldAsset(epochNumber, address(newProxy), keccak256(bytes(assetType)));\r\n        return address(newProxy);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\n\r\n/// @title World asset proxy\r\n/// @notice Acts as a proxy contract to specified world asset, implementation of which is dereferenced from its creation parameters\r\ncontract WorldAssetProxy {\r\n    constructor(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetGroup,\r\n        string memory assetType\r\n    ) public {\r\n        WorldAssetStorage storage proxyStorage = getWorldAssetStorage();\r\n        proxyStorage.worldAddress = worldAddress;\r\n        proxyStorage.epochNumber = epochNumber;\r\n        proxyStorage.assetId = keccak256(abi.encodePacked(assetGroup, assetType));\r\n        proxyStorage.assetGroup = assetGroup;\r\n        proxyStorage.assetType = assetType;\r\n    }\r\n\r\n    /// @dev Fallback function that delegates calls to the address returned by registry script contract. Will run if no other function in the contract matches the call data.\r\n    fallback() external payable {\r\n        WorldAssetStorage storage proxyStorage = getWorldAssetStorage();\r\n        address impl = IWorld(proxyStorage.worldAddress).registry().scriptContracts(proxyStorage.assetId);\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n\r\n            // (1) copy incoming call data\r\n            calldatacopy(ptr, 0, calldatasize())\r\n\r\n            // (2) forward call to logic contract\r\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n\r\n            // (3) retrieve return data\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // (4) forward return data back to caller\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/zone/ZoneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IZone.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IZoneFactory.sol\";\r\n\r\ncontract ZoneFactory is IZoneFactory, WorldAssetFactory {\r\n    /// @inheritdoc IZoneFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        uint256 zoneIndex\r\n    ) public returns (address) {\r\n        IZone zone = IZone(createAndSet(worldAddress, epochNumber, \"zone\", assetName));\r\n        zone.init(zoneIndex);\r\n        return address(zone);\r\n    }\r\n}\r\n"
    },
    "contracts/core/geography/Geography.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IGeography.sol\";\r\nimport \"../../libraries/UintUtils.sol\";\r\nimport \"../WorldInitializable.sol\";\r\n\r\ncontract Geography is IGeography, WorldInitializable {\r\n    /// @inheritdoc IGeography\r\n    mapping(uint32 => uint256) public override packedGameTileMap;\r\n\r\n    /// @notice Array containing zones activation params\r\n    /// @dev Value accessible via #getZoneActivationParams\r\n    ZoneActivationParams[] private zonesActivationParams;\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    modifier onlyMightyCreator() {\r\n        require(msg.sender == world.registry().mightyCreator(), \"onlyMightyCreator\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getZonesLength() public view override returns (uint256) {\r\n        return zonesActivationParams.length;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function createZone(\r\n        uint32[] memory positions,\r\n        uint16[] memory tileTypes,\r\n        uint256 cultistsCoordinateIndex\r\n    ) public override onlyMightyCreator {\r\n        require(zonesActivationParams.length != type(uint16).max, \"exceeded zones limit\");\r\n\r\n        uint16 newZoneId = uint16(zonesActivationParams.length);\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            require(isVoidSpot(positions[i]), \"ZONE_INTERSECTS_WITH_CURRENT_WORLD\");\r\n            setGameTile(positions[i], GameTile(newZoneId, tileTypes[i]));\r\n        }\r\n\r\n        uint32 cultistsPosition = positions[cultistsCoordinateIndex];\r\n        zonesActivationParams.push(ZoneActivationParams({cultistsPosition: cultistsPosition}));\r\n        emit NewZoneCreated(newZoneId, positions, tileTypes, cultistsPosition);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function isPathValid(uint32[] memory path) public view override returns (bool) {\r\n        if (path.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint256 i = 1; i < path.length; i++) {\r\n            if (!isNeighborTo(path[i], path[i - 1])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function isNeighborTo(uint32 position, uint32 neighbor) public pure override returns (bool) {\r\n        if (position == neighbor) {\r\n            return false;\r\n        }\r\n\r\n        (uint16 positionX, uint16 positionY) = getCoordinates(position);\r\n        (uint16 neighborX, uint16 neighborY) = getCoordinates(neighbor);\r\n        bool isCloseByY = ((positionY > neighborY && positionY - neighborY == 1) ||\r\n        (neighborY > positionY && neighborY - positionY == 1));\r\n        if (positionX == neighborX && isCloseByY) {\r\n            return true;\r\n        }\r\n\r\n        bool isCloseByX = ((positionX > neighborX && positionX - neighborX == 1) ||\r\n        (neighborX > positionX && neighborX - positionX == 1));\r\n        if (positionY == neighborY && isCloseByX) {\r\n            return true;\r\n        }\r\n\r\n        bool isEvenCell = isEven(positionX, positionY);\r\n        if (isEvenCell && positionY > neighborY && positionY - neighborY == 1 && isCloseByX) {\r\n            return true;\r\n        }\r\n\r\n        if (!isEvenCell && neighborY > positionY && neighborY - positionY == 1 && isCloseByX) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getGameTile(uint32 position) public view override returns (GameTile memory) {\r\n        uint32 slotNumber = position >> 3;\r\n        uint32 itemNumber = position % 8;\r\n        uint256 packedGameTiles = packedGameTileMap[slotNumber];\r\n        uint32 packedGameTile = uint32(packedGameTiles >> ((7 - itemNumber) << 5));\r\n        return getUnpackedTile(packedGameTile);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getZoneActivationParams(uint256 index) public view override returns (ZoneActivationParams memory) {\r\n        return zonesActivationParams[index];\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRingPositions(uint32 position, uint256 radius) public pure override returns (uint32[] memory, uint256) {\r\n        uint32[] memory ringPositions = new uint32[](radius * 6);\r\n\r\n        (uint16 _x, uint16 _y) = getCoordinates(position);\r\n        int128 movingX = int128(uint128(_x));\r\n        int128 movingY = int128(uint128(_y));\r\n\r\n        for (uint256 i = 0; i < radius; i++) {\r\n            (movingX, movingY) = getNeighborCoordinates(movingX, movingY, 4);\r\n        }\r\n\r\n        uint256 _index = 0;\r\n        for (uint256 i = 0; i < 6; i++) {\r\n            for (uint256 j = 0; j < radius; j++) {\r\n                if (isValidCoordinates(movingX, movingY)) {\r\n                    ringPositions[_index] = getPosition(uint16(int16(movingX)), uint16(int16(movingY)));\r\n                    _index++;\r\n                }\r\n\r\n                (movingX, movingY) = getNeighborCoordinates(movingX, movingY, i);\r\n            }\r\n        }\r\n\r\n        return (ringPositions, _index);\r\n    }\r\n\r\n    function isValidCoordinates(int128 x, int128 y) internal pure returns (bool) {\r\n        return x >= 0 && x < 65536 && y >= 0 && y < 65536;\r\n    }\r\n\r\n    /// @dev Calculates neighbor position of position according to provided direction\r\n    function getNeighborCoordinates(int128 x, int128 y, uint256 direction) internal pure returns (int128 neighborX, int128 neighborY) {\r\n        bool isEven = (x & 1) == 0;\r\n\r\n        if (direction == 0) {\r\n            return (x, y - 1);\r\n        }\r\n\r\n        if (direction == 1) {\r\n            if (isEven) {\r\n                return (x + 1, y - 1);\r\n            } else {\r\n                return (x + 1, y);\r\n            }\r\n        }\r\n\r\n        if (direction == 2) {\r\n            if (isEven) {\r\n                return (x + 1, y);\r\n            } else {\r\n                return (x + 1, y + 1);\r\n            }\r\n        }\r\n\r\n        if (direction == 3) {\r\n            return (x, y + 1);\r\n        }\r\n\r\n        if (direction == 4) {\r\n            if (isEven) {\r\n                return (x - 1, y);\r\n            } else {\r\n                return (x - 1, y + 1);\r\n            }\r\n        }\r\n\r\n        if (direction == 5) {\r\n            if (isEven) {\r\n                return (x - 1, y - 1);\r\n            } else {\r\n                return (x - 1, y);\r\n            }\r\n        }\r\n\r\n        revert(\"invalid state\");\r\n    }\r\n\r\n    /// @dev Checks if provided position is 'void'\r\n    function isVoidSpot(uint32 position) internal view returns (bool) {\r\n        return getGameTile(position).tileType == uint16(TileType.VOID);\r\n    }\r\n\r\n    /// @dev Sets gameTile by provided position\r\n    function setGameTile(uint32 position, GameTile memory gameTile) internal {\r\n        uint32 packedGameTile = getPackedTile(gameTile);\r\n\r\n        uint32 slotNumber = position >> 3;\r\n        uint32 itemNumber = position % 8;\r\n        uint256 packedGameTiles = packedGameTileMap[slotNumber];\r\n\r\n        uint256 offset = (7 - itemNumber) << 5;\r\n        packedGameTileMap[slotNumber] =\r\n            (packedGameTiles & ~(uint256(type(uint32).max) << offset)) |\r\n            (uint256(packedGameTile) << offset);\r\n    }\r\n\r\n    /// @dev Calculates is provided coordinates are 'even' for current hex variant implementation\r\n    function isEven(\r\n        uint16 x,\r\n        uint16 /*y*/\r\n    ) internal pure returns (bool) {\r\n        return x % 2 == 0;\r\n    }\r\n\r\n    /// @dev Calculates position by coordinates\r\n    function getPosition(uint16 x, uint16 y) internal pure returns (uint32) {\r\n        return (uint32(y) << 16) + uint32(x);\r\n    }\r\n\r\n    /// @dev Calculates coordinates by position\r\n    function getCoordinates(uint32 position) internal pure returns (uint16, uint16) {\r\n        uint16 y = uint16(position >> 16);\r\n        uint16 x = uint16(position);\r\n        return (x, y);\r\n    }\r\n\r\n    /// @dev Packs gameTile struct into 32 bit value\r\n    function getPackedTile(GameTile memory gameTile) internal pure returns (uint32) {\r\n        return (uint32(gameTile.zoneId) << 16) | uint32(gameTile.tileType);\r\n    }\r\n\r\n    /// @dev Unpacks gameTile struct from 32 bit value\r\n    function getUnpackedTile(uint32 gameTile) internal pure returns (GameTile memory) {\r\n        uint16 zoneId = uint16(gameTile >> 16);\r\n        uint16 tileType = uint16(gameTile);\r\n        return GameTile(zoneId, tileType);\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/prosperity/Prosperity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"../../WorldInitializable.sol\";\r\nimport \"../../../token/ERC20IntBurnable.sol\";\r\nimport \"../../assets/workersPool/IWorkersPool.sol\";\r\n\r\ncontract Prosperity is ERC20IntBurnable, IProsperity, WorldInitializable {\r\n    /// @inheritdoc IProsperity\r\n    mapping(address => uint256) public override prosperitySpent;\r\n\r\n    /// @notice Bytes32 value for any workers pool asset type\r\n    /// @dev Used for determination if prosperity went from/to workers pool\r\n    bytes32 public constant WORKERS_POOL_ASSET_TYPE = keccak256(bytes(\"workersPool\"));\r\n\r\n    /// @notice Epoch number\r\n    /// @dev To which epoch number current prosperity is related to\r\n    uint256 public epochNumber;\r\n\r\n    constructor(address worldAddress, uint256 epoch)\r\n        public\r\n        ERC20Int(\r\n            string.concat(\"Prosperity @\", Strings.toString(epoch)),\r\n            string.concat(\"PRS @\", Strings.toString(epoch))\r\n        )\r\n        initializer\r\n    {\r\n        setWorld(worldAddress);\r\n        epochNumber = epoch;\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n\r\n    }\r\n\r\n    /// @inheritdoc IProsperity\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetForEpoch(epochNumber) {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IProsperity\r\n    function spend(address from, uint256 amount) public override onlyWorldAssetForEpoch(epochNumber) {\r\n        require(balanceOf(from) >= amount, \"not enough amount to spend\");\r\n        prosperitySpent[from] += amount;\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world) || world.worldAssets(epochNumber, addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20IntBurnable, IERC20Burnable) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20IntBurnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice For prosperity default ERC20.transfer is disabled\r\n    function transfer(address to, uint256 amount) public override(ERC20Int, IERC20) returns (bool success) {\r\n        revert(\"Prosperity: transfer function disabled\");\r\n    }\r\n\r\n    /// @notice For prosperity default ERC20.transferFrom is disabled\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20Int, IERC20) returns (bool success) {\r\n        if (isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            revert(\"Prosperity: transfer function disabled\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/tokens/prosperity/ProsperityFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Prosperity.sol\";\r\nimport \"./IProsperityFactory.sol\";\r\n\r\ncontract ProsperityFactory is IProsperityFactory {\r\n    /// @inheritdoc IProsperityFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epoch\r\n    ) public returns (address) {\r\n        return address(new Prosperity(worldAddress, epoch));\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/WorkersPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorkersPool.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IWorkersPoolFactory.sol\";\r\n\r\ncontract WorkersPoolFactory is IWorkersPoolFactory, WorldAssetFactory {\r\n    /// @inheritdoc IWorkersPoolFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress\r\n    ) public returns (address) {\r\n        IWorkersPool workersPool = IWorkersPool(createAndSet(worldAddress, epochNumber, \"workersPool\", assetName));\r\n        workersPool.init(zoneAddress);\r\n        return address(workersPool);\r\n    }\r\n}\r\n"
    },
    "contracts/core/crossEpochsMemory/CrossEpochsMemory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./ICrossEpochsMemory.sol\";\r\nimport \"../WorldInitializable.sol\";\r\n\r\ncontract CrossEpochsMemory is ICrossEpochsMemory, WorldInitializable  {\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    mapping(uint32 => ISettlement) public override settlements;\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    mapping(uint256 => ISettlement) public override userSettlements;\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    mapping(uint256 => uint256) public override zoneUserSettlementsCount;\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    mapping(uint256 => uint256) public override zoneSettlementStartingPrice;\r\n\r\n    /// @dev Allows caller to be only active world epoch\r\n    modifier onlyActiveEpoch() {\r\n        uint256 currentEpochNumber = world.currentEpochNumber();\r\n        require(msg.sender == address(world.epochs(currentEpochNumber)), \"onlyActiveEpoch\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    function handleUserSettlementRestored(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) public onlyActiveEpoch {\r\n        uint256 positionOwnerTokenId = settlements[position].ownerTokenId();\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n\r\n        settlements[position] = settlement;\r\n        userSettlements[positionOwnerTokenId] = settlement;\r\n    }\r\n\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    function handleNewUserSettlement(\r\n        uint256 ownerTokenId,\r\n        uint256 zoneIndex,\r\n        address settlementAddress,\r\n        uint256 newSettlementStartingPrice\r\n    ) public onlyActiveEpoch {\r\n        userSettlements[ownerTokenId] = ISettlement(settlementAddress);\r\n        zoneUserSettlementsCount[zoneIndex]++;\r\n        zoneSettlementStartingPrice[zoneIndex] = newSettlementStartingPrice;\r\n    }\r\n\r\n    /// @inheritdoc ICrossEpochsMemory\r\n    function handleNewSettlement(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) public onlyActiveEpoch {\r\n        settlements[position] = ISettlement(settlementAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlement/SettlementFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./ISettlement.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./ISettlementFactory.sol\";\r\n\r\ncontract SettlementFactory is ISettlementFactory, WorldAssetFactory {\r\n    /// @inheritdoc ISettlementFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        uint256 ownerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) public returns (address) {\r\n        ISettlement settlement = ISettlement(createAndSet(worldAddress, epochNumber, \"settlement\", assetName));\r\n        settlement.init(ownerTokenId, zoneAddress, settlementPosition);\r\n        return address(settlement);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlement/Settlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../building/IBuildingFactory.sol\";\r\nimport \"../army/IArmyFactory.sol\";\r\nimport \"../siege/ISiegeFactory.sol\";\r\nimport \"../zone/IZone.sol\";\r\nimport \"./ISettlement.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\ncontract Settlement is WorldAsset, ISettlement {\r\n    /// @inheritdoc ISettlement\r\n    IZone public override currentZone;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override ownerTokenId;\r\n    /// @inheritdoc ISettlement\r\n    ISiege public override siege;\r\n    /// @inheritdoc ISettlement\r\n    mapping(string => IBuilding) public override buildings;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override currentGovernorsEpoch;\r\n    /// @inheritdoc ISettlement\r\n    mapping(uint256 => mapping(address => bool)) public override governors;\r\n    /// @inheritdoc ISettlement\r\n    IArmy public override army;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override extraProsperity;\r\n    /// @inheritdoc ISettlement\r\n    uint32 public override position;\r\n\r\n    /// @dev Allows caller to be settlement owner or world asset\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == getSettlementOwner() || world().worldAssets(epochNumber(), msg.sender) != bytes32(0),\r\n            \"owner or system only\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be settlement ruler or world asset\r\n    modifier onlyRulerOrWorldAsset() {\r\n        require(isRuler(msg.sender) || world().worldAssets(epochNumber(), msg.sender) != bytes32(0), \"onlyRulerOrWorldAsset\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function init(\r\n        uint256 createdWithOwnerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) public override initializer {\r\n        currentZone = IZone(zoneAddress);\r\n        ownerTokenId = createdWithOwnerTokenId;\r\n        position = settlementPosition;\r\n\r\n        createBuildings();\r\n        createNewArmy();\r\n        mintInitialResources();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function getSettlementOwner() public view override returns (address) {\r\n        return world().bannerContract().ownerOf(ownerTokenId);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function newBuilding(string memory buildingName) public override onlyActiveGame returns (address) {\r\n        require(address(buildings[buildingName]) == address(0), \"building already created\");\r\n\r\n        IBuildingFactory buildingFactory = IBuildingFactory(\r\n            registry().factoryContracts(keccak256(bytes(\"building\")))\r\n        );\r\n\r\n        address newBuildingAddress = buildingFactory.create(address(world()), epochNumber(), buildingName, address(this));\r\n        IBuilding building = IBuilding(newBuildingAddress);\r\n\r\n        buildings[buildingName] = building;\r\n\r\n        emit NewBuilding(newBuildingAddress, buildingName);\r\n        return newBuildingAddress;\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function accumulatedCurrentProsperity(uint256 _timestamp) public view override returns (int256) {\r\n        if (_timestamp == 0) {\r\n            _timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 spent = epoch().prosperity().prosperitySpent(address(this));\r\n\r\n        uint256 res = extraProsperity;\r\n\r\n        res += buildings[\"LUMBERMILL\"].getTreasury(_timestamp) * registry().getResourceWeight(\"WOOD\");\r\n        res += buildings[\"MINE\"].getTreasury(_timestamp) * registry().getResourceWeight(\"ORE\");\r\n        res += buildings[\"SMITHY\"].getTreasury(_timestamp) * registry().getResourceWeight(\"WEAPON\");\r\n\r\n        return int256(res) - int256(spent);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function massUpdate() public override {\r\n        buildings[\"FARM\"].updateState();\r\n        buildings[\"LUMBERMILL\"].updateState();\r\n        buildings[\"MINE\"].updateState();\r\n        buildings[\"SMITHY\"].updateState();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function transferWorkers(address _to, uint256 _amount) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        require(MathExtension.isIntegerWithPrecision(_amount, 1e18), \"workers can be only cell\");\r\n        require(IBuilding(_to).getWorkers() + _amount <= IBuilding(_to).getMaxWorkers(), \"settlement balance exceed limit\");\r\n\r\n        epoch().workers().transfer(_to, _amount);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function transferResources(\r\n        string memory _resourceName,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        IResource resource = epoch().resources(_resourceName);\r\n        uint256 resourceBalance = resource.balanceOf(address(this));\r\n        resource.transfer(_to, Math.min(_amount, resourceBalance));\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function updateFortHealth(uint256 _healthDiff, bool _isProduced) public override onlyWorldAssetFromSameEpoch {\r\n        IFort fort = IFort(address(buildings[\"FORT\"]));\r\n        uint256 currentHealth = fort.health();\r\n\r\n        if (_isProduced) {\r\n            fort.updateHealth(currentHealth + _healthDiff);\r\n            return;\r\n        }\r\n\r\n        if (currentHealth >= _healthDiff) {\r\n            fort.updateHealth(currentHealth - _healthDiff);\r\n            return;\r\n        }\r\n\r\n        fort.updateHealth(0);\r\n        siege.systemUpdate(_healthDiff - currentHealth);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function updateCurrentHealth() public override {\r\n        buildings[\"FORT\"].updateState();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function getCurrentSiegePower() public view override returns (uint256) {\r\n        if (address(siege) != address(0)) {\r\n            (uint256 power, ) = siege.calculateTotalSiegeStats();\r\n            return power * registry().getGlobalMultiplier();\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function calculateCurrentHealthAndDamage(uint256 timestamp)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 currentHealth, uint256 damage)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        IFort fort = IFort(address(buildings[\"FORT\"]));\r\n\r\n        IBuilding.ProductionResultItem[] memory res = fort.getProductionResult(timestamp);\r\n\r\n        uint256 _healthDiff;\r\n        bool _isProduced;\r\n\r\n        for (uint256 i = 0; i < res.length; i++) {\r\n            if (keccak256(bytes(res[i].resourceName)) == keccak256(bytes(\"HEALTH\"))) {\r\n                _healthDiff = res[i].balanceChanges;\r\n                _isProduced = res[i].isProducing;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (_healthDiff == 0) {\r\n            return (fort.health(), 0);\r\n        }\r\n\r\n        if (_isProduced) {\r\n            return (fort.health() + _healthDiff, 0);\r\n        }\r\n\r\n        if (fort.health() >= _healthDiff) {\r\n            return (fort.health() - _healthDiff, 0);\r\n        }\r\n\r\n        return (0, _healthDiff - fort.health());\r\n    }\r\n\r\n    /// @notice Adds settlement governor\r\n    /// @dev Settlement owner and other governor can add governor\r\n    /// @param _governorAddress Address to add as the governor\r\n    function addGovernor(address _governorAddress) public {\r\n        require(\r\n            msg.sender == getSettlementOwner() || governors[currentGovernorsEpoch][msg.sender],\r\n            \"only owner or governor\"\r\n        );\r\n        governors[currentGovernorsEpoch][_governorAddress] = true;\r\n        emit GovernorChanged(currentGovernorsEpoch, _governorAddress, true);\r\n    }\r\n\r\n    /// @notice Removes settlement governor\r\n    /// @dev Only settlement owner can remove governor\r\n    /// @param _governorAddress Address to remove from governors\r\n    function removeGovernor(address _governorAddress) public onlyOwner {\r\n        governors[currentGovernorsEpoch][_governorAddress] = false;\r\n        emit GovernorChanged(currentGovernorsEpoch, _governorAddress, false);\r\n    }\r\n\r\n    /// @notice Removes all settlement governors\r\n    /// @dev Only settlement owner can remove all governors\r\n    function removeGovernors() public onlyOwner {\r\n        currentGovernorsEpoch++;\r\n        emit NewSettlementEpoch(currentGovernorsEpoch);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function isRuler(address _address) public view override returns (bool) {\r\n        return getSettlementOwner() == _address || governors[currentGovernorsEpoch][_address];\r\n    }\r\n\r\n    /// @dev Mints initial settlement resources\r\n    function mintInitialResources() internal {\r\n        address settlementOwner = getSettlementOwner();\r\n\r\n        epoch().workers().mint(address(this), 7e18);\r\n\r\n        IRegistry.ExtraResource[] memory extraResources = registry().getNewSettlementExtraResources();\r\n        for (uint256 i = 0; i < extraResources.length; i++) {\r\n            epoch().resources(extraResources[i].resourceName).mint(settlementOwner, extraResources[i].value);\r\n        }\r\n    }\r\n\r\n    /// @dev Creates settlements buildings\r\n    function createBuildings() internal {\r\n        string[] memory buildings = registry().getBuildings();\r\n        for (uint256 i = 0; i < buildings.length; i++) {\r\n            newBuilding(buildings[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Creates settlements army\r\n    function createNewArmy() internal {\r\n        IArmyFactory armyFactory = IArmyFactory(registry().factoryContracts(keccak256(bytes((\"army\")))));\r\n        army = IArmy(armyFactory.create(address(world()), epochNumber(), \"BASIC\", address(this)));\r\n        emit NewArmy(address(army), position);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function createSiege() public override onlyActiveGame {\r\n        require(address(siege) == address(0), \"siege already created\");\r\n\r\n        ISiegeFactory siegeFactory = ISiegeFactory(registry().factoryContracts(keccak256(bytes((\"siege\")))));\r\n        address newSiegeAddress = siegeFactory.create(address(world()), epochNumber(), \"BASIC\", address(this));\r\n        siege = ISiege(newSiegeAddress);\r\n        emit SiegeCreated(newSiegeAddress);\r\n    }\r\n\r\n    /// @notice Swaps current settlement prosperity for exact workers\r\n    /// @dev Only ruler or world asset can perform swap\r\n    /// @param _workersToBuy Exact amount of workers to buy\r\n    /// @param _maxProsperityToSell Maximum amount of prosperity to spend for exact workers\r\n    function swapProsperityForExactWorkers(uint256 _workersToBuy, uint256 _maxProsperityToSell)\r\n        public\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAsset\r\n    {\r\n        uint256 newWorkers = currentZone.workersPool().swapProsperityForExactWorkers(_workersToBuy, _maxProsperityToSell);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function extendProsperity(uint256 prosperityAmount) public override onlyActiveGame onlyWorldAssetFromSameEpoch {\r\n        epoch().prosperity().mint(address(this), prosperityAmount);\r\n        extraProsperity += prosperityAmount;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/IBuildingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Building factory interface\r\n/// @notice Contains instance creator function\r\ninterface IBuildingFactory {\r\n    /// @notice Creates Building instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the building type (Currently 'FARM', 'LUMBERMILL', 'MINE', 'SMITHY', 'FORT')\r\n    /// @param settlementAddress Settlement address\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/army/IArmyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Army factory interface\r\n/// @notice Contains instance creator function\r\ninterface IArmyFactory {\r\n    /// @notice Creates Army instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the army type (Currently only 'BASIC')\r\n    /// @param settlementAddress Settlement address\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/siege/ISiegeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Siege factory interface\r\n/// @notice Contains instance creator function\r\ninterface ISiegeFactory {\r\n    /// @notice Creates Siege instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the battle type (Currently only 'BASIC')\r\n    /// @param settlementAddress Address of the related settlement\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/IFort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IBuilding.sol\";\r\n\r\n/// @title Fort interface\r\n/// @notice Functions to read state/modify state in order to get current fort parameters and/or interact with it\r\ninterface IFort is IBuilding {\r\n    // State variables\r\n\r\n    /// @notice Fort health\r\n    /// @dev Updated when #updateHealth is called\r\n    function health() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Updates fort health\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param value New fort health\r\n    function updateHealth(uint256 value) external;\r\n\r\n    /// @notice Calculates maximum amount of health for provided level\r\n    /// @dev Useful to determine maximum amount of health will be available at provided level\r\n    /// @param level Level at which calculate maximum amount of health\r\n    /// @return maxHealth Maximum amount of health for provided level\r\n    function getMaxHealthOnLevel(uint256 level) external view returns (uint256 maxHealth);\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/UnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\n\r\ncontract UnitsPool is WorldAsset, IUnitsPool {\r\n    /// @inheritdoc IUnitsPool\r\n    IZone public override currentZone;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override lastPurchaseTime;\r\n    /// @inheritdoc IUnitsPool\r\n    string public override unitsType;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override startingPrice;\r\n\r\n    /// @dev Allows caller to be only zone\r\n    modifier onlyZone() {\r\n        require(msg.sender == address(currentZone), \"onlyZone\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Returns weapons\r\n    function weapons() internal view returns (IResource) {\r\n        return epoch().resources(\"WEAPON\");\r\n    }\r\n\r\n    /// @dev Returns units by pool unit type\r\n    function units() internal view returns (IUnits) {\r\n        return epoch().units(unitsType);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function init(\r\n        address _zoneAddress,\r\n        string memory _unitsType\r\n    ) public override initializer {\r\n        currentZone = IZone(_zoneAddress);\r\n        unitsType = _unitsType;\r\n        lastPurchaseTime = block.timestamp;\r\n        startingPrice = 10e18;\r\n    }\r\n\r\n    /// @dev Calculates dropped price after last purchase time\r\n    function getDroppedPrice() internal view returns (int128) {\r\n        uint256 secondsPassed = block.timestamp - Math.max(lastPurchaseTime, world().gameStartTime());\r\n        int128 startingPrice64 = ABDKMath64x64.divu(startingPrice, 1e18);\r\n\r\n        (uint256 numerator, uint256 denominator) = registry().getUnitPriceDropByUnitType(unitsType);\r\n        int128 priceDropPerSecond64 = ABDKMath64x64.divu(numerator, denominator);\r\n        int128 priceDrop64 = ABDKMath64x64.pow(priceDropPerSecond64, secondsPassed);\r\n        return ABDKMath64x64.mul(startingPrice64, priceDrop64);\r\n    }\r\n\r\n    /// @dev Calculates amount of weapons and new starting price according to amount of units and price shift per unit interaction with the pool\r\n    function calculatePriceShiftForUnits(\r\n        uint256 amountOfUnits,\r\n        int128 priceShiftPerUnit64\r\n    ) internal view returns (uint256, uint256) {\r\n        int128 droppedPrice = getDroppedPrice();\r\n        int128 lastUnitPriceShift64 = ABDKMath64x64.pow(\r\n            priceShiftPerUnit64,\r\n            amountOfUnits\r\n        );\r\n\r\n        int128 sumOfPriceShifts64 = ABDKMath64x64.div(\r\n            ABDKMath64x64.sub(\r\n                lastUnitPriceShift64,\r\n                ABDKMath64x64.fromUInt(1)\r\n            ),\r\n            ABDKMath64x64.ln(priceShiftPerUnit64)\r\n        );\r\n\r\n        int128 weaponsForPriceShift64 = ABDKMath64x64.mul(droppedPrice, sumOfPriceShifts64);\r\n        int128 newStartingPrice64 = ABDKMath64x64.mul(droppedPrice, lastUnitPriceShift64);\r\n\r\n        uint256 weaponsForPriceShift = uint256(ABDKMath64x64.muli(weaponsForPriceShift64, 1e18));\r\n        uint256 newStartingPrice = uint256(ABDKMath64x64.muli(newStartingPrice64, 1e18));\r\n\r\n        return (weaponsForPriceShift, newStartingPrice);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function getAmountIn(uint256 unitsToBuy) public view override returns (uint256, uint256) {\r\n        int128 priceIncreasePerUnit64 = ABDKMath64x64.divu(1004, 1000);\r\n        return calculatePriceShiftForUnits(unitsToBuy, priceIncreasePerUnit64);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapWeaponsForExactUnits(\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) public override returns (uint256) {\r\n        return _swapWeaponsForExactUnits(msg.sender, settlementAddress, unitsToBuy, maxWeaponsToSell);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapWeaponsForExactUnitsByZone(\r\n        address weaponsPayer,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) public override onlyZone returns (uint256) {\r\n        return _swapWeaponsForExactUnits(weaponsPayer, settlementAddress, unitsToBuy, maxWeaponsToSell);\r\n    }\r\n\r\n    /// @dev Core logic related to swapping weapons for exact units\r\n    function _swapWeaponsForExactUnits(\r\n        address weaponsPayer,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) internal returns (uint256) {\r\n        require(unitsToBuy >= 1e18, \"Insufficient units buy amount\");\r\n        require(MathExtension.isIntegerWithPrecision(unitsToBuy, 1e18), \"Not integer amount of units to buy specified\");\r\n        require(maxWeaponsToSell > 0, \"Insufficient maximum weapons sell amount\");\r\n        require(\r\n            address(ISettlement(settlementAddress).currentZone()) == address(currentZone),\r\n            \"Settlement doesn't belong to this zone\"\r\n        );\r\n\r\n        uint256 health = updateAndGetHealth(settlementAddress);\r\n        uint256 currentUnits = updateAndGetArmyTotalUnits(settlementAddress);\r\n\r\n        require(getMaxAllowedToBuy(health, currentUnits) >= unitsToBuy, \"Exceeded limit\");\r\n        (uint256 weaponsToSell, uint256 newStartingPrice) = getAmountIn(unitsToBuy / 1e18);\r\n\r\n        require(weaponsToSell <= maxWeaponsToSell, \"Weapons to sell is more than specified limit\");\r\n        require(weapons().balanceOf(weaponsPayer) >= weaponsToSell, \"Not enough weapons to sell\");\r\n\r\n        IArmy army = ISettlement(settlementAddress).army();\r\n        army.updateState();\r\n        (, uint64 endTime) = army.movementTiming();\r\n        require(endTime == 0, \"Can't hire units while moving\");\r\n        (, uint64 stunEndTime) = army.movementTiming();\r\n        require(stunEndTime == 0, \"stunned army cannot hire units\");\r\n\r\n        address armyAddress = address(army);\r\n        weapons().burnFrom(weaponsPayer, weaponsToSell);\r\n        currentZone.decreaseToxicity(settlementAddress, \"WEAPON\", weaponsToSell);\r\n        units().mint(armyAddress, unitsToBuy);\r\n\r\n        startingPrice = newStartingPrice;\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        emit UnitsBought(\r\n            weaponsPayer,\r\n            armyAddress,\r\n            unitsToBuy,\r\n            weaponsToSell\r\n        );\r\n\r\n        return unitsToBuy;\r\n    }\r\n\r\n    /// @dev Updates provided settlements fort health up to current block and returns its new value\r\n    function updateAndGetHealth(address settlementAddress) internal returns (uint256) {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        settlement.updateCurrentHealth();\r\n        IFort fort = IFort(address(settlement.buildings(\"FORT\")));\r\n        return fort.health();\r\n    }\r\n\r\n    /// @dev Updates provided settlements army up to current block and returns its total units count\r\n    function updateAndGetArmyTotalUnits(address settlementAddress) internal returns (uint256 totalUnits) {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        IArmy army = settlement.army();\r\n        army.updateState();\r\n\r\n        require(army.isHomePosition(), \"Can hire only on home position\");\r\n\r\n        ISiege siege = army.siege();\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            totalUnits += epoch().units(unitName).balanceOf(address(army));\r\n            if (address(siege) != address(0)) {\r\n                totalUnits += siege.storedUnits(address(army), unitName);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates maximum allowed extra units that can be bought and placed into army given its total units count and fort health\r\n    function getMaxAllowedToBuy(uint256 health, uint256 currentUnits) internal returns (uint256) {\r\n        uint256 maxAllowedUnits = MathExtension.roundDownWithPrecision(\r\n            health / registry().getUnitHiringFortHpMultiplier(),\r\n            1e18\r\n        );\r\n\r\n        if (currentUnits >= maxAllowedUnits) {\r\n            return 0;\r\n        }\r\n\r\n        return maxAllowedUnits - currentUnits;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Fort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../Building.sol\";\r\nimport \"./IFort.sol\";\r\n\r\ncontract Fort is Building, IFort {\r\n    /// @inheritdoc IFort\r\n    uint256 public override health;\r\n\r\n    /// @inheritdoc IFort\r\n    function updateHealth(uint256 value) public onlyWorldAssetFromSameEpoch {\r\n        uint256 maxHealth = getMaxHealthOnLevel(getBuildingLevel());\r\n        health = Math.min(value, maxHealth);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceName() public view override(Building, IBuilding) returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override(Building, IBuilding) {\r\n        revert(\"resetDistribution is disabled\");\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function init(address settlementAddress)\r\n        public\r\n        override(Building, IBuilding)\r\n        initializer\r\n    {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        production.lastUpdateStateTime = block.timestamp;\r\n        health = 4e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig()\r\n        public\r\n        view\r\n        override(Building, IBuilding)\r\n        returns (InitialResourceBlock[] memory initialResourceBlocks)\r\n    {\r\n        initialResourceBlocks = new InitialResourceBlock[](3);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(3e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[1] = InitialResourceBlock({\r\n            resourceName: \"WOOD\",\r\n            perTick: uint256(2e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[2] = InitialResourceBlock({\r\n            resourceName: \"HEALTH\",\r\n            perTick: uint256(1e18) / (1 days),\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n\r\n    /// @inheritdoc IFort\r\n    function getMaxHealthOnLevel(uint256 level) public view override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 2) * 2 * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc Building\r\n    function recalculateProduction() internal override {}\r\n\r\n    /// @inheritdoc Building\r\n    function updateProsperity() internal override {}\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasury(uint256 _timestamp) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 _level) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public override(Building, IBuilding) {\r\n        if (production.lastUpdateStateTime == block.timestamp) {\r\n            return;\r\n        }\r\n\r\n        uint256 currentTime = getCurrentTime();\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n        production.lastUpdateStateTime = currentTime;\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (keccak256(bytes(productionResult[i].resourceName)) == keccak256(bytes(\"HEALTH\"))) {\r\n                //health\r\n                currentSettlement.updateFortHealth(\r\n                    productionResult[i].balanceChanges,\r\n                    productionResult[i].isProducing\r\n                );\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].balanceChanges == 0) {\r\n                continue;\r\n            }\r\n\r\n            epoch().resources(productionResult[i].resourceName).burn(productionResult[i].balanceChanges);\r\n        }\r\n    }\r\n\r\n    struct FortData {\r\n        uint256 fullHealthProductionSeconds;\r\n        uint256 partialHealthProductionSeconds;\r\n    }\r\n\r\n    /// @dev Calculates fort health production\r\n    function calculateFortData() public view returns (FortData memory) {\r\n        uint256 currentHealth = health;\r\n        uint256 maxHealth = getMaxHealthOnLevel(getBuildingLevel());\r\n        uint256 missingHealth = maxHealth - currentHealth;\r\n\r\n        InitialResourceBlock[] memory initialResourceBlocks = getConfig();\r\n        uint256 basicRegenIncome = initialResourceBlocks[2].perTick * getBasicProductionMultiplier() / 1e18;\r\n        uint256 advancedRegenIncome = initialResourceBlocks[2].perTick * getAdvancedProductionMultiplier() / 1e18;\r\n        if (advancedRegenIncome == 0) {\r\n            return FortData({fullHealthProductionSeconds: 0, partialHealthProductionSeconds: 0});\r\n        }\r\n\r\n        uint256 degenIncome = currentSettlement.getCurrentSiegePower();\r\n\r\n        if (basicRegenIncome >= degenIncome) {\r\n            basicRegenIncome = basicRegenIncome - degenIncome;\r\n            degenIncome = 0;\r\n        } else {\r\n            degenIncome = degenIncome - basicRegenIncome;\r\n            basicRegenIncome = 0;\r\n        }\r\n\r\n        uint256 regenIncome = basicRegenIncome + advancedRegenIncome;\r\n\r\n        uint256 toBeProducedValue = initialResourceBlocks[2].perTick * calculateProductionTicksAmount();\r\n\r\n        uint256 secondsUntilResourcesDepletionWithFullSpeed = (toBeProducedValue == 0)\r\n            ? 0\r\n            : toBeProducedValue / advancedRegenIncome;\r\n\r\n        if (degenIncome >= regenIncome) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: secondsUntilResourcesDepletionWithFullSpeed,\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        uint256 secondsUntilFullWithCurrentSpeed = (regenIncome <= degenIncome)\r\n            ? type(uint256).max\r\n            : (missingHealth == 0)\r\n                ? 0\r\n                : missingHealth % (regenIncome - degenIncome) == 0\r\n                    ? missingHealth / (regenIncome - degenIncome)\r\n                    : (missingHealth / (regenIncome - degenIncome)) + 1;\r\n\r\n        if (degenIncome == 0) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: Math.min(\r\n                        secondsUntilResourcesDepletionWithFullSpeed,\r\n                        secondsUntilFullWithCurrentSpeed\r\n                    ),\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        if (secondsUntilFullWithCurrentSpeed >= secondsUntilResourcesDepletionWithFullSpeed) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: secondsUntilResourcesDepletionWithFullSpeed,\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        uint256 partialHealthProductionSeconds = (\r\n            (secondsUntilResourcesDepletionWithFullSpeed - secondsUntilFullWithCurrentSpeed) * regenIncome\r\n        ) / degenIncome;\r\n\r\n        return\r\n            FortData({\r\n                fullHealthProductionSeconds: secondsUntilFullWithCurrentSpeed,\r\n                partialHealthProductionSeconds: partialHealthProductionSeconds\r\n            });\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override(Building, IBuilding)\r\n        returns (ProductionResultItem[] memory res)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime != 0) {\r\n            timestamp = Math.min(timestamp, gameFinishTime);\r\n        }\r\n\r\n        InitialResourceBlock[] memory initialResourceBlocks = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](initialResourceBlocks.length);\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceName: initialResourceBlocks[i].resourceName,\r\n                isProducing: initialResourceBlocks[i].isProducing,\r\n                balanceChanges: 0\r\n            });\r\n        }\r\n\r\n        if (timestamp <= production.lastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        FortData memory secondsUntilSpeedChanges = calculateFortData();\r\n        uint256 elapsedSeconds = timestamp - production.lastUpdateStateTime;\r\n\r\n        uint256 fullIncomeSecondsElapsed = Math.min(\r\n            secondsUntilSpeedChanges.fullHealthProductionSeconds,\r\n            elapsedSeconds\r\n        );\r\n        uint256 partialIncomeSecondsElapsed = Math.min(\r\n            elapsedSeconds - fullIncomeSecondsElapsed,\r\n            secondsUntilSpeedChanges.partialHealthProductionSeconds\r\n        );\r\n\r\n        uint256 degenIncome = currentSettlement.getCurrentSiegePower();\r\n        uint256 basicRegenIncome = (initialResourceBlocks[2].perTick * getBasicProductionMultiplier()) / 1e18;\r\n        uint256 advancedRegenIncome = (initialResourceBlocks[2].perTick * getAdvancedProductionMultiplier()) / 1e18;\r\n\r\n        uint256 advancedHealthProduced = fullIncomeSecondsElapsed * advancedRegenIncome + partialIncomeSecondsElapsed * degenIncome;\r\n        uint256 healthProduced = advancedHealthProduced + elapsedSeconds * basicRegenIncome;\r\n        uint256 healthLost = elapsedSeconds * degenIncome;\r\n        uint256 advancedTicksProduced = advancedHealthProduced / initialResourceBlocks[2].perTick;\r\n\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            if (initialResourceBlocks[i].isProducing) {\r\n                bool isHealthProduced = healthProduced >= healthLost;\r\n                uint256 healthChanges = isHealthProduced\r\n                    ? healthProduced - healthLost\r\n                    : healthLost - healthProduced;\r\n\r\n                productionResult[i].isProducing = isHealthProduced;\r\n                productionResult[i].balanceChanges = healthChanges;\r\n            } else {\r\n                productionResult[i].balanceChanges = initialResourceBlocks[i].perTick * advancedTicksProduced;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/Building.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"./IBuilding.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\nabstract contract Building is WorldAsset, IBuilding {\r\n    /// @inheritdoc IBuilding\r\n    ISettlement public override currentSettlement;\r\n    /// @inheritdoc IBuilding\r\n    BasicProduction public override basicProduction;\r\n    /// @inheritdoc IBuilding\r\n    AdvancedProduction public override advancedProduction;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override upgradeCooldownFinishTime;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override prosperity;\r\n    /// @inheritdoc IBuilding\r\n    Production public override production;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override distributionId;\r\n    /// @inheritdoc IBuilding\r\n    mapping(address => uint256) public override producedResourceDebt;\r\n\r\n    modifier onlyDistributions() {\r\n        require(\r\n            address(world().distributions()) == msg.sender,\r\n            \"onlyDistributions\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only settlement owner\r\n    modifier onlySettlementOwner() {\r\n        require(\r\n            currentSettlement.getSettlementOwner() == msg.sender,\r\n            \"onlySettlementOwner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be ruler or world or world asset\r\n    modifier onlyRulerOrWorldAssetFromSameEpoch() {\r\n        require(\r\n            currentSettlement.isRuler(msg.sender) ||\r\n                msg.sender == address(world()) ||\r\n                world().worldAssets(epochNumber(), msg.sender) != bytes32(0),\r\n            \"onlyRulerOrWorldAssetFromSameEpoch\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Calculates building coefficient\r\n    function getBuildingCoefficient(uint256 level) internal view returns (uint256) {\r\n        uint256 increaseByEveryNLevels = 5;\r\n        uint256 b = level / increaseByEveryNLevels;\r\n        uint256 c = level - b * increaseByEveryNLevels;\r\n        uint256 d = (((b + 1) * b) / 2) * increaseByEveryNLevels;\r\n        uint256 e = d + c * (b + 1);\r\n        return e;\r\n    }\r\n\r\n    /// @dev Creates default distribution (all possible tokens will be minted to current settlement owner)\r\n    function setDefaultDistribution() internal {\r\n        // Previous distributors is required for thegraph purposes\r\n        address[] memory previousReceivers = world().distributions().getDistributionReceivers(distributionId);\r\n        distributionId = world().distributions().mint(currentSettlement.getSettlementOwner());\r\n        emit NewDistribution(distributionId, previousReceivers);\r\n    }\r\n\r\n    /// @dev Saves produced amount of resource between treasury and production.readyToBeDistributed\r\n    function saveProducedResource(string memory resourceName, uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        //N% of resources moves to treasury pool\r\n        uint256 amountOfResourceGoingToTreasury = (amount * registry().getToTreasuryPercent()) / 1e18;\r\n\r\n        uint256 currentTreasury = epoch().resources(resourceName).stateBalanceOf(address(this));\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n\r\n        if (currentTreasury >= maxTreasury) {\r\n            amountOfResourceGoingToTreasury = 0;\r\n        } else if (amountOfResourceGoingToTreasury > maxTreasury - currentTreasury) {\r\n            amountOfResourceGoingToTreasury = maxTreasury - currentTreasury;\r\n        }\r\n\r\n        if (amountOfResourceGoingToTreasury > 0) {\r\n            epoch().resources(resourceName).mint(address(this), amountOfResourceGoingToTreasury);\r\n            amount = amount - amountOfResourceGoingToTreasury;\r\n        }\r\n\r\n        if (amount > 0) {\r\n            currentSettlement.currentZone().increaseToxicity(\r\n                address(currentSettlement),\r\n                getProducingResourceName(),\r\n                amount\r\n            );\r\n\r\n            production.readyToBeDistributed += amount;\r\n        }\r\n    }\r\n\r\n    /// @dev Updates building prosperity according to changed amount of resources in building\r\n    function updateProsperity() internal virtual {\r\n        uint256 buildingLevel = getBuildingLevel();\r\n        uint256 levelCoefficient = getBuildingCoefficient(buildingLevel);\r\n\r\n        uint256 currentProductionResourceBalance = epoch().resources(getProducingResourceName()).stateBalanceOf(\r\n            address(this)\r\n        );\r\n\r\n        uint256 prosperityBefore = prosperity;\r\n\r\n        uint256 resourceWeight = registry().getResourceWeight(getProducingResourceName());\r\n        uint256 potentialNewProsperity = currentProductionResourceBalance * resourceWeight / levelCoefficient;\r\n        uint256 maxProsperity = getMaxTreasuryByLevel(buildingLevel) * resourceWeight / levelCoefficient;\r\n\r\n        uint256 prosperityAfter = Math.min(maxProsperity, potentialNewProsperity);\r\n        prosperity = prosperityAfter;\r\n\r\n        if (prosperityBefore > prosperityAfter) {\r\n            epoch().prosperity().burnFrom(address(currentSettlement), prosperityBefore - prosperityAfter);\r\n        } else if (prosperityBefore < prosperityAfter) {\r\n            epoch().prosperity().mint(address(currentSettlement), prosperityAfter - prosperityBefore);\r\n        }\r\n    }\r\n\r\n    /// @dev Recalculates production structure according to new resource balances\r\n    function recalculateProduction() internal virtual {\r\n        uint256 productionMultiplier = getAdvancedProductionMultiplier() / 1e18;\r\n        uint256 productionZoneTimeLeftUntilStop = 0;\r\n        uint256 extraTicksAfterFinish = 0;\r\n\r\n        if (productionMultiplier > 0) {\r\n            uint256 productionTicksLeftUntilStop = calculateProductionTicksAmount();\r\n\r\n            if (productionTicksLeftUntilStop == type(uint256).max) {\r\n                productionZoneTimeLeftUntilStop = type(uint256).max;\r\n            } else {\r\n                productionZoneTimeLeftUntilStop = (productionTicksLeftUntilStop * (1e18 / registry().getProductionTicksInSecond())) / productionMultiplier;\r\n\r\n                if (productionTicksLeftUntilStop % productionMultiplier > 0) {\r\n                    extraTicksAfterFinish = productionTicksLeftUntilStop % productionMultiplier;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (productionZoneTimeLeftUntilStop == type(uint256).max) {\r\n            production.productionFinishZoneTime = type(uint256).max;\r\n        } else {\r\n            production.productionFinishZoneTime = currentSettlement.currentZone().getZoneTime(getCurrentTime()) + productionZoneTimeLeftUntilStop;\r\n        }\r\n\r\n        production.extraTicksAfterFinish = extraTicksAfterFinish;\r\n    }\r\n\r\n    /// @dev Calculates current game time, taking into an account game finish time\r\n    function getCurrentTime() internal view returns (uint256) {\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime == 0) {\r\n            return block.timestamp;\r\n        }\r\n\r\n        return Math.min(block.timestamp, gameFinishTime);\r\n    }\r\n\r\n    /// @dev Calculates basic production multiplier\r\n    function getBasicProductionMultiplier() internal view returns (uint256) {\r\n        string memory currentBuildingName = buildingName();\r\n\r\n        return (\r\n            basicProduction.coefficient\r\n            * registry().getBasicProductionBuildingCoefficient(currentBuildingName)\r\n            * registry().getWorkerCapacityCoefficient(currentBuildingName)\r\n            * registry().getGlobalMultiplier()\r\n        ) / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates advanced production multiplier\r\n    function getAdvancedProductionMultiplier() internal view returns (uint256) {\r\n        return (Math.min(getWorkers(), getMaxWorkers())) * registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates amount of production ticks for current building according to its resources balances\r\n    function calculateProductionTicksAmount() internal view returns (uint256) {\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        uint256 productionTicksAmountUntilStop = type(uint256).max;\r\n\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (config[i].isProducing) {\r\n                continue;\r\n            }\r\n\r\n            uint256 balance = epoch().resources(config[i].resourceName).stateBalanceOf(address(this));\r\n            if (balance == 0) {\r\n                return 0;\r\n            }\r\n\r\n            productionTicksAmountUntilStop = Math.min(\r\n                balance / config[i].perTick,\r\n                productionTicksAmountUntilStop\r\n            );\r\n        }\r\n\r\n        return productionTicksAmountUntilStop;\r\n    }\r\n\r\n    /// @dev Calculates is building token recall allowed according to building token transfer threshold\r\n    function isBuildingTokenRecallAllowed() internal returns (bool) {\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n        string memory producingResourceName = getProducingResourceName();\r\n        if (bytes(producingResourceName).length == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 currentTreasuryThreshold = (maxTreasury * registry().getBuildingTokenTransferThresholdPercent()) / 1e18;\r\n        uint256 currentTreasury = epoch().resources(producingResourceName).balanceOf(address(this));\r\n\r\n        return currentTreasury <= currentTreasuryThreshold;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function init(address settlementAddress) public virtual override initializer {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        uint256 timestamp = getCurrentTime();\r\n        production.lastUpdateStateTime = timestamp;\r\n        production.lastUpdateStateZoneTime = currentSettlement.currentZone().getZoneTime(timestamp);\r\n\r\n        if (registry().hasStartingTreasury(buildingName())) {\r\n            epoch().resources(getProducingResourceName()).mint(address(this), getMaxTreasuryByLevel(getBuildingLevel()));\r\n            updateProsperity();\r\n        }\r\n\r\n        setDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function productionChanged() public virtual override {\r\n        updateProsperity();\r\n        updateState();\r\n        recalculateProduction();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public virtual override {\r\n        currentSettlement.currentZone().updateState();\r\n\r\n        uint256 currentTime = getCurrentTime();\r\n        if (production.lastUpdateStateTime == currentTime) {\r\n            return;\r\n        }\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n        production.lastUpdateStateTime = currentTime;\r\n        production.lastUpdateStateZoneTime = currentSettlement.currentZone().getZoneTime(currentTime);\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (productionResult[i].balanceChanges == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].isProducing) {\r\n                saveProducedResource(productionResult[i].resourceName, productionResult[i].balanceChanges);\r\n            } else {\r\n                epoch().resources(productionResult[i].resourceName).burn(productionResult[i].balanceChanges);\r\n            }\r\n        }\r\n\r\n        updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function fixDebtAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyDistributions {\r\n        uint256 debtAmount = amount * production.readyToBeDistributed;\r\n        if (debtAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        producedResourceDebt[from] -= debtAmount;\r\n        producedResourceDebt[to] += debtAmount;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToSingleShareholder(address holder) public override {\r\n        updateState();\r\n\r\n        IDistributions distributions = world().distributions();\r\n        uint256 nftBalance = distributions.balanceOf(holder, distributionId);\r\n        if (nftBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 partOfProduction = production.readyToBeDistributed * nftBalance / distributions.getItemsPerNft() - producedResourceDebt[holder];\r\n        if (partOfProduction == 0) {\r\n            return;\r\n        }\r\n\r\n        producedResourceDebt[holder] += partOfProduction;\r\n        string memory productionResourceType = getProducingResourceName();\r\n        epoch().resources(productionResourceType).mint(holder, partOfProduction);\r\n        emit DistributedToShareHolder(productionResourceType, holder, partOfProduction);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToAllShareholders() public override {\r\n        updateState();\r\n\r\n        uint256 readyToBeDistributed = production.readyToBeDistributed;\r\n        string memory productionResourceType = getProducingResourceName();\r\n        IResource producingResource = epoch().resources(productionResourceType);\r\n        IDistributions distributions = world().distributions();\r\n        uint256 itemsPerNft = distributions.getItemsPerNft();\r\n\r\n        address[] memory topHolders = world().distributions().getDistributionReceivers(distributionId);\r\n        for (uint256 i = 0; i < topHolders.length; i++) {\r\n            address holder = topHolders[i];\r\n            uint256 holderDebt = producedResourceDebt[holder];\r\n            uint256 partOfProduction = ((readyToBeDistributed * distributions.balanceOf(holder, distributionId)) / itemsPerNft) - holderDebt;\r\n            if (holderDebt > 0) {\r\n                producedResourceDebt[holder] = 0;\r\n            }\r\n\r\n            if (partOfProduction > 0) {\r\n                producingResource.mint(holder, partOfProduction);\r\n                emit DistributedToShareHolder(productionResourceType, holder, partOfProduction);\r\n            }\r\n        }\r\n\r\n        production.readyToBeDistributed = 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getResourcesAmount(string memory _resourceName, uint256 _timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        ProductionResultItem[] memory result = getProductionResult(_timestamp);\r\n\r\n        bytes32 resourceNameBytes = keccak256(bytes(_resourceName));\r\n\r\n        for (uint256 i = 0; i < result.length; i++) {\r\n            if (keccak256(bytes(result[i].resourceName)) == resourceNameBytes) {\r\n                if (result[i].isProducing) {\r\n                    uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n                    if (maxTreasury == 0) {\r\n                        return 0;\r\n                    }\r\n\r\n                    uint256 amountOfResourcePotentiallyGoingToTreasury = (result[i].balanceChanges * registry().getToTreasuryPercent()) / 1e18;\r\n                    uint256 currentTreasuryResourcesAmount = epoch().resources(getProducingResourceName()).stateBalanceOf(address(this));\r\n\r\n                    // In case if building has more resources than max in treasury -> none of production resources will go to the treasury\r\n                    // therefore building doesnt produced anything to the building\r\n                    if (currentTreasuryResourcesAmount >= maxTreasury) {\r\n                        return currentTreasuryResourcesAmount;\r\n                    }\r\n\r\n                    return Math.min(\r\n                        amountOfResourcePotentiallyGoingToTreasury + currentTreasuryResourcesAmount,\r\n                        maxTreasury\r\n                    );\r\n                } else {\r\n                    return epoch().resources(_resourceName).stateBalanceOf(address(this)) - result[i].balanceChanges;\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (ProductionResultItem[] memory)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime != 0) {\r\n            timestamp = Math.min(timestamp, gameFinishTime);\r\n        }\r\n\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](config.length);\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceName: config[i].resourceName,\r\n                isProducing: config[i].isProducing,\r\n                balanceChanges: 0\r\n            });\r\n        }\r\n\r\n        if (timestamp <= production.lastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        uint256 zoneTime = currentSettlement.currentZone().getZoneTime(timestamp);\r\n        uint256 advancedProductionFinishTime = zoneTime;\r\n\r\n        bool isProductionSurpassedFinishTime = false;\r\n        if (advancedProductionFinishTime > production.productionFinishZoneTime) {\r\n            advancedProductionFinishTime = production.productionFinishZoneTime;\r\n            isProductionSurpassedFinishTime = true;\r\n        }\r\n\r\n        uint256 producedTicksByBasicProduction = getProducedTicksByBasicProduction(\r\n            production.lastUpdateStateZoneTime,\r\n            zoneTime\r\n        );\r\n\r\n        uint256 producedTicksByAdvancedProduction = getProducedTicksByAdvancedProduction(\r\n            production.lastUpdateStateZoneTime,\r\n            advancedProductionFinishTime,\r\n            isProductionSurpassedFinishTime\r\n        );\r\n\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            productionResult[i].balanceChanges = config[i].perTick * producedTicksByAdvancedProduction;\r\n\r\n            // Is producing value increased here because basic production does not stop and building upgrades through time\r\n            if (productionResult[i].isProducing) {\r\n                productionResult[i].balanceChanges += config[i].perTick * producedTicksByBasicProduction;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by advanced production for provided start, finish time and is production surpassed finish time\r\n    function getProducedTicksByAdvancedProduction(\r\n        uint256 advancedProductionStartTime,\r\n        uint256 advancedProductionFinishTime,\r\n        bool isProductionSurpassedFinishTime\r\n    ) internal view returns (uint256) {\r\n        if (advancedProductionFinishTime <= advancedProductionStartTime) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 advancedProductionDuration = advancedProductionFinishTime - advancedProductionStartTime;\r\n\r\n        uint256 productionMultiplier = getAdvancedProductionMultiplier();\r\n        uint256 fullTicksPassed = advancedProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return isProductionSurpassedFinishTime\r\n            ? (productionMultiplier * fullTicksPassed) / 1e18 + production.extraTicksAfterFinish\r\n            : (productionMultiplier * fullTicksPassed) / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by basic production for provided start, finish time and basic production coefficient\r\n    function getProducedTicksByBasicProduction(\r\n        uint256 basicProductionStartTime,\r\n        uint256 basicProductionFinishTime\r\n    ) internal view returns (uint256) {\r\n        uint256 basicProductionDuration = basicProductionFinishTime - basicProductionStartTime;\r\n        uint256 ticksPassed = basicProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return getBasicProductionMultiplier() * ticksPassed / 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override virtual onlySettlementOwner {\r\n        require(isBuildingTokenRecallAllowed(), \"Token recall not allowed\");\r\n        distributeToAllShareholders();\r\n        setDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function isResourceAcceptable(string memory _resourceName) public view override returns (bool) {\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (keccak256(bytes(config[i].resourceName)) == keccak256(bytes(_resourceName))) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function batchTransferResources(\r\n        string[] calldata resourcesNames,\r\n        address to,\r\n        uint256[] calldata amounts\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        for (uint256 i = 0; i < resourcesNames.length; i++) {\r\n            transferResources(resourcesNames[i], to, amounts[i]);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function transferWorkers(address to, uint256 amount) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        epoch().workers().transfer(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        IResource resource = epoch().resources(resourceName);\r\n        uint256 balance = resource.balanceOf(address(this));\r\n        if (balance == 0) {\r\n            return;\r\n        }\r\n\r\n        if (amount > balance) {\r\n            amount = balance;\r\n        }\r\n\r\n        if (keccak256(bytes(resourceName)) == keccak256(bytes(getProducingResourceName()))) {\r\n            uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n            uint256 availableToTransfer = 0;\r\n\r\n            if (balance > maxTreasury) {\r\n                availableToTransfer = balance - maxTreasury;\r\n            }\r\n\r\n            if (amount > availableToTransfer) {\r\n                amount = availableToTransfer;\r\n            }\r\n        }\r\n\r\n        if (amount > 0) {\r\n            resource.transfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getUpgradePrice(uint256 level)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTreasuryByLevel = getMaxTreasuryByLevel(level);\r\n        uint256 maxTreasuryByNextLevel = getMaxTreasuryByLevel(level + 1);\r\n        uint256 maxTreasuryByLevelWithCoefficient = (maxTreasuryByLevel * 75) / 100;\r\n        uint256 treasuryDifference = maxTreasuryByNextLevel - maxTreasuryByLevelWithCoefficient;\r\n        return treasuryDifference;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBuildingLevel() public view override returns (uint256) {\r\n        return basicProduction.level + advancedProduction.level;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getWorkers() public view virtual override returns (uint256) {\r\n        return epoch().workers().balanceOf(address(this));\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function startBasicUpgrade() public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        require(getCurrentTime() >= upgradeCooldownFinishTime, \"already upgrading\");\r\n\r\n        uint256 upgradePrice = getUpgradePrice(getBuildingLevel());\r\n\r\n        epoch().resources(\"WOOD\").burnFrom(msg.sender, upgradePrice);\r\n        currentSettlement.currentZone().decreaseToxicity(address(currentSettlement), \"WOOD\", upgradePrice);\r\n\r\n        upgradeCooldownFinishTime = block.timestamp + getBasicUpgradeCooldownDuration(getBuildingLevel());\r\n\r\n        uint256 oldLevel = basicProduction.level;\r\n        uint256 newLevel = oldLevel + 1;\r\n        basicProduction.level = newLevel;\r\n\r\n        uint256 coefficientDelta = getBuildingCoefficient(newLevel) - getBuildingCoefficient(oldLevel);\r\n        basicProduction.coefficient = basicProduction.coefficient + coefficientDelta;\r\n\r\n        updateProsperity();\r\n\r\n        emit UpgradeFinish(getBuildingLevel());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function startAdvancedUpgrade() public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        require(getCurrentTime() >= upgradeCooldownFinishTime, \"already upgrading\");\r\n\r\n        uint256 upgradePrice = getUpgradePrice(getBuildingLevel());\r\n\r\n        epoch().resources(\"ORE\").burnFrom(msg.sender, upgradePrice);\r\n        currentSettlement.currentZone().decreaseToxicity(address(currentSettlement), \"ORE\", upgradePrice);\r\n\r\n        upgradeCooldownFinishTime = block.timestamp + getAdvancedUpgradeCooldownDuration(getBuildingLevel());\r\n\r\n        uint256 oldLevel = advancedProduction.level;\r\n        uint256 newLevel = oldLevel + 1;\r\n        advancedProduction.level = newLevel;\r\n\r\n        uint256 coefficientDelta = getBuildingCoefficient(newLevel) - getBuildingCoefficient(oldLevel);\r\n        advancedProduction.coefficient = advancedProduction.coefficient + coefficientDelta;\r\n\r\n        updateProsperity();\r\n\r\n        emit UpgradeFinish(getBuildingLevel());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBasicUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return level * 6 hours;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceName() public view virtual override returns (string memory) {\r\n        InitialResourceBlock[] memory initialResourceBlocks = getConfig();\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            if (initialResourceBlocks[i].isProducing) {\r\n                return initialResourceBlocks[i].resourceName;\r\n            }\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxWorkers() public view override returns (uint256) {\r\n        return advancedProduction.coefficient * registry().getWorkerCapacityCoefficient(buildingName());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasury(uint256 timestamp) public view virtual override returns (uint256) {\r\n        return getResourcesAmount(getProducingResourceName(), timestamp);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 level) public view virtual override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 2) * 10 * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function stealTreasury(address to, uint256 amountToSteal)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyWorldAssetFromSameEpoch\r\n        returns (uint256)\r\n    {\r\n        updateState();\r\n\r\n        uint256 currentTreasuryResourcesAmount = epoch().resources(getProducingResourceName()).stateBalanceOf(address(this));\r\n        uint256 currentTreasuryAmount = Math.min(getMaxTreasuryByLevel(getBuildingLevel()), currentTreasuryResourcesAmount);\r\n        if (currentTreasuryAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        amountToSteal = Math.min(currentTreasuryAmount, amountToSteal);\r\n\r\n        uint256 amountToBurn = (amountToSteal * registry().getRobberyFee()) / 1e18;\r\n\r\n        IResource resource = epoch().resources(getProducingResourceName());\r\n        resource.transfer(to, amountToSteal - amountToBurn);\r\n        burnTreasury(amountToBurn);\r\n\r\n        return amountToSteal;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function burnTreasury(uint256 burnAmount) public override onlyActiveGame onlyWorldAssetFromSameEpoch {\r\n        IResource resource = epoch().resources(getProducingResourceName());\r\n        resource.burn(burnAmount);\r\n        updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view virtual override returns (InitialResourceBlock[] memory initialResourceBlocks);\r\n\r\n    /// @inheritdoc IBuilding\r\n    function buildingName() public view virtual override returns (string memory) {\r\n        return assetType();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/core/assets/building/impl/Smithy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Smithy is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view override returns (InitialResourceBlock[] memory initialResourceBlocks) {\r\n        initialResourceBlocks = new InitialResourceBlock[](4);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[1] = InitialResourceBlock({\r\n            resourceName: \"WOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[2] = InitialResourceBlock({\r\n            resourceName: \"ORE\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[3] = InitialResourceBlock({\r\n            resourceName: \"WEAPON\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Mine.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Mine is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view override returns (InitialResourceBlock[] memory initialResourceBlocks) {\r\n        initialResourceBlocks = new InitialResourceBlock[](3);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[1] = InitialResourceBlock({\r\n            resourceName: \"WOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[2] = InitialResourceBlock({\r\n            resourceName: \"ORE\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Lumbermill.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Lumbermill is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view override returns (InitialResourceBlock[] memory initialResourceBlocks) {\r\n        initialResourceBlocks = new InitialResourceBlock[](2);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[1] = InitialResourceBlock({\r\n            resourceName: \"WOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Farm.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Farm is Building {\r\n    /// @inheritdoc Building\r\n    function getConfig() public view override returns (InitialResourceBlock[] memory initialResourceBlocks) {\r\n        initialResourceBlocks = new InitialResourceBlock[](1);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n\r\n    /// @inheritdoc Building\r\n    function updateProsperity() internal virtual override {\r\n        return;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/army/Army.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../battle/IBattleFactory.sol\";\r\nimport \"./IArmy.sol\";\r\nimport \"../../IWorld.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../epoch/IEpoch.sol\";\r\nimport \"../zone/IZone.sol\";\r\nimport \"../siege/ISiege.sol\";\r\nimport \"../../tokens/resources/IResource.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\n\r\ncontract Army is WorldAsset, IArmy {\r\n    /// @inheritdoc IArmy\r\n    ISettlement public override currentSettlement;\r\n    /// @inheritdoc IArmy\r\n    uint32 public override currentPosition;\r\n    /// @inheritdoc IArmy\r\n    uint32 public override destinationPosition;\r\n    /// @inheritdoc IArmy\r\n    IBattle public override battle;\r\n    /// @inheritdoc IArmy\r\n    ISiege public override siege;\r\n    /// @inheritdoc IArmy\r\n    MovementTiming public override movementTiming;\r\n    /// @inheritdoc IArmy\r\n    StunTiming public override stunTiming;\r\n    /// @inheritdoc IArmy\r\n    uint32[] public override movementPath;\r\n    /// @inheritdoc IArmy\r\n    uint256 public override lastDemilitarizationTime;\r\n\r\n    /// @dev Allows caller to be only ruler or any world asset\r\n    modifier onlyOwnerOrWorldAssetFromSameEpoch() {\r\n        require(\r\n            currentSettlement.isRuler(msg.sender) ||\r\n                msg.sender == address(world()) ||\r\n                world().worldAssets(WorldAssetStorageAccessor.epochNumber(), msg.sender) != bytes32(0),\r\n            \"onlyOwnerOrWorldAssetFromSameEpoch\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function init(address settlementAddress) public override initializer {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n        currentPosition = currentSettlement.position();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getMovementPath() public view override returns (uint32[] memory) {\r\n        return movementPath;\r\n    }\r\n\r\n    /// @dev Applies stun\r\n    function applyStun(\r\n        uint64 stunStartTime,\r\n        uint64 stunDuration\r\n    ) internal {\r\n        uint64 newStunEndTime = stunStartTime + stunDuration;\r\n        if (newStunEndTime > stunTiming.endTime) {\r\n            stunTiming.endTime = newStunEndTime;\r\n            stunTiming.startTime = stunStartTime;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function updateState() public override onlyActiveGame {\r\n        if (address(battle) != address(0)) {\r\n            if (!battle.isFinishedBattle() && battle.canFinishBattle()) {\r\n                battle.finishBattle();\r\n            }\r\n\r\n            if (battle.isFinishedBattle()) {\r\n                address oldBattleAddress = address(battle);\r\n                require(oldBattleAddress != address(0), \"not in battle\");\r\n                battle.removeArmyFromBattle(address(this));\r\n\r\n                IBattle oldBattle = IBattle(oldBattleAddress);\r\n\r\n                bool isArmyWon = oldBattle.armySide(address(this)) == oldBattle.winningSide();\r\n                if (!isArmyWon) {\r\n                    (uint64 battleCreationTime, uint64 lobbyDuration, uint64 ongoingDuration,) = oldBattle.timing();\r\n                    uint64 battleDuration = lobbyDuration + ongoingDuration;\r\n                    uint64 stunStartTime = battleCreationTime + battleDuration;\r\n                    uint64 stunDuration = uint64(battleDuration * registry().getBattleDurationStunMultiplier() / 1e18);\r\n                    applyStun(stunStartTime, stunDuration);\r\n                }\r\n\r\n                emit ExitedFromBattle(oldBattleAddress);\r\n            }\r\n        }\r\n\r\n        if (canUpdatePosition()) {\r\n            uint64 movementDuration = movementTiming.endTime - movementTiming.startTime;\r\n            uint64 stunStartTime = movementTiming.endTime;\r\n            uint64 stunDuration = uint64(movementDuration * registry().getMovementDurationStunMultiplier() / 1e18);\r\n\r\n            currentPosition = movementPath[movementPath.length - 1];\r\n\r\n            movementTiming = MovementTiming({startTime: 0, endTime: 0});\r\n            movementPath = new uint32[](0);\r\n            destinationPosition = 0;\r\n\r\n            applyStun(stunStartTime, stunDuration);\r\n\r\n            emit UpdatedPosition(address(epoch().settlements(currentPosition)), currentPosition);\r\n        }\r\n\r\n        if (stunTiming.endTime != 0 && block.timestamp >= stunTiming.endTime) {\r\n            stunTiming.startTime = 0;\r\n            stunTiming.endTime = 0;\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if army can update position at the moment\r\n    function canUpdatePosition() internal view returns (bool) {\r\n        if (movementTiming.endTime != 0 && block.timestamp >= movementTiming.endTime) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getOwner() public view override returns (address) {\r\n        return currentSettlement.getSettlementOwner();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function burnUnits(string[] memory unitNames, uint256[] memory unitsCount)\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEpoch\r\n        onlyActiveGame\r\n    {\r\n        for (uint256 i = 0; i < unitNames.length; i++) {\r\n            if (unitsCount[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            IUnits units = epoch().units(unitNames[i]);\r\n            units.burn(unitsCount[i]);\r\n            emit UnitsChanged(unitNames[i], units.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /// @dev Updates farm's treasury, burns food specified for feeding and returns new path time\r\n    function speedUpArmyBySpendingFood(\r\n        uint256 defaultPathTime,\r\n        uint256 pathLength,\r\n        uint256 foodToSpendOnFeeding\r\n    ) internal returns (uint256) {\r\n        if (foodToSpendOnFeeding == 0) {\r\n            return defaultPathTime;\r\n        }\r\n\r\n        uint256 foodAmountToMaximumSpeed = getFoodMovementStats(pathLength);\r\n        ISettlement settlementOnPosition = ISettlement(epoch().settlements(currentPosition));\r\n        IBuilding farm = settlementOnPosition.buildings(\"FARM\");\r\n        farm.updateState();\r\n\r\n        uint256 farmTreasury = Math.min(\r\n            epoch().resources(farm.getProducingResourceName()).stateBalanceOf(address(farm)),\r\n            farm.getMaxTreasuryByLevel(farm.getBuildingLevel())\r\n        );\r\n\r\n        require(farmTreasury >= foodToSpendOnFeeding, \"exceeded food amount in treasury\");\r\n        farm.burnTreasury(foodToSpendOnFeeding);\r\n\r\n        return getDecreasedPathTime(pathLength, defaultPathTime, foodToSpendOnFeeding, foodAmountToMaximumSpeed);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function move(uint32[] memory path, uint256 foodToSpendOnFeeding)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyOwnerOrWorldAssetFromSameEpoch\r\n    {\r\n        updateState();\r\n\r\n        require(stunTiming.endTime == 0, \"army is stunned\");\r\n        require(movementTiming.endTime == 0, \"cannot move while moving\");\r\n        require(address(battle) == address(0), \"cannot move while in battle\");\r\n        require(address(siege) == address(0), \"cannot move while besieging\");\r\n\r\n        require(world().geography().isNeighborTo(currentPosition, path[0]), \"invalid first path position\");\r\n\r\n        //0 army can't move (you can move only on your settlement hex)\r\n        uint256 totalUnitsCount = getTotalUnitsCount();\r\n        address destinationSettlement = address(epoch().settlements(path[path.length - 1]));\r\n        if (totalUnitsCount == 0 && destinationSettlement != address(currentSettlement)) {\r\n            revert(\"empty army can move only to home\");\r\n        }\r\n\r\n        require(destinationSettlement != address(0), \"can move only to other settlement\");\r\n        require(world().geography().isPathValid(path), \"invalid path\");\r\n\r\n        if (foodToSpendOnFeeding > 0) {\r\n            require(totalUnitsCount > 0, \"cannot accelerate empty army\");\r\n        }\r\n\r\n        uint256 totalPathTime = speedUpArmyBySpendingFood(\r\n            calculateDefaultPathTime(path),\r\n            path.length,\r\n            foodToSpendOnFeeding\r\n        );\r\n\r\n        movementTiming = MovementTiming({\r\n            startTime: uint64(block.timestamp),\r\n            endTime: uint64(block.timestamp + totalPathTime)\r\n        });\r\n\r\n        movementPath = path;\r\n\r\n        destinationPosition = path[path.length - 1];\r\n\r\n        emit MovingTo(destinationSettlement, movementTiming.startTime, movementTiming.endTime, path);\r\n    }\r\n\r\n    /// @dev Calculates default path time\r\n    function calculateDefaultPathTime(uint32[] memory path) internal returns (uint256) {\r\n        return (8 hours * path.length) / registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function demilitarize(string[] memory unitTypes, uint256[] memory unitsAmounts)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyOwnerOrWorldAssetFromSameEpoch\r\n    {\r\n        updateState();\r\n\r\n        uint256 demilitarizationCooldown = registry().getDemilitarizationCooldown() / registry().globalMultiplier();\r\n\r\n        require(stunTiming.endTime == 0, \"army is stunned\");\r\n        require(block.timestamp > lastDemilitarizationTime + demilitarizationCooldown, \"demilitarization cooldown\");\r\n        require(unitTypes.length == unitsAmounts.length, \"invalid input\");\r\n        require(address(battle) == address(0), \"cannot demilitarize while in battle\");\r\n\r\n        ISettlement settlementAtPosition = epoch().settlements(getCurrentPosition());\r\n        IZone settlementsZone = settlementAtPosition.currentZone();\r\n\r\n        uint256 prosperityForDemilitarization = 0;\r\n        for (uint256 i = 0; i < unitTypes.length; i++) {\r\n            uint256 unitAmount = unitsAmounts[i];\r\n            require(unitAmount > 0 && MathExtension.isIntegerWithPrecision(unitAmount, 1e18), \"wrong input\");\r\n\r\n            prosperityForDemilitarization += unitAmount / 1e18 * registry().getProsperityForDemilitarization(unitTypes[i]);\r\n        }\r\n\r\n        this.burnUnits(unitTypes, unitsAmounts);\r\n\r\n        // If demilitarization occurs not at cultists position -> we give prosperity to the settlement where army stands\r\n        if (address(settlementsZone.cultistsSettlement()) != address(settlementAtPosition)) {\r\n            ISettlement(settlementAtPosition).extendProsperity(prosperityForDemilitarization);\r\n        }\r\n\r\n        lastDemilitarizationTime = block.timestamp;\r\n    }\r\n\r\n    /// @dev Calculates decreased path time by feeding parameters\r\n    function getDecreasedPathTime(\r\n        uint256 pathLength,\r\n        uint256 defaultPathTime,\r\n        uint256 foodToSpendOnFeeding,\r\n        uint256 foodAmountToMaximumSpeed\r\n    ) internal returns (uint256) {\r\n        uint256 maxDecreasedPathTime = (defaultPathTime * 1e18 / MathExtension.sqrt(pathLength * 1e18)) / 1e9;\r\n        uint256 delta = defaultPathTime - maxDecreasedPathTime;\r\n        uint256 foodUsage = foodToSpendOnFeeding * 1e18 / foodAmountToMaximumSpeed;\r\n\r\n        return defaultPathTime - delta * foodUsage / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates amount of needed food for maximum speed increase and amount of max allowed food to spend on feeding\r\n    function getFoodMovementStats(uint256 pathLength) internal returns (uint256) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        uint256 foodAmountToMaximumSpeed = 0;\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            uint256 unitsCount = epoch().units(units[i]).balanceOf(address(this));\r\n\r\n            foodAmountToMaximumSpeed +=\r\n                (unitsCount / 1e18) *\r\n                registry().getUnitMaxFoodToSpendOnMove(units[i]) *\r\n                pathLength;\r\n        }\r\n\r\n        return (foodAmountToMaximumSpeed * MathExtension.sqrt(pathLength * 1e18)) / 1e9;\r\n    }\r\n\r\n    /// @dev Calculates current army units balance\r\n    function getTotalUnitsCount() internal view returns (uint256 totalUnitsCount) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            totalUnitsCount += epoch().units(units[i]).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates if provided army has more than specified units\r\n    function isArmyUnitsExceeds(\r\n        address armyAddress,\r\n        string[] calldata unitTypes,\r\n        uint256[] calldata maxUnits\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < unitTypes.length; i++) {\r\n            uint256 balance = epoch().units(unitTypes[i]).balanceOf(armyAddress);\r\n            if (balance > maxUnits[i]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getCurrentPosition() public view override returns (uint32) {\r\n        if (movementTiming.endTime != 0 && block.timestamp >= movementTiming.endTime) {\r\n            return destinationPosition;\r\n        }\r\n\r\n        return currentPosition;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function setBattle(address battleAddress) public override onlyWorldAssetFromSameEpoch {\r\n        battle = IBattle(battleAddress);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function newBattle(\r\n        address targetArmyAddress,\r\n        string[] calldata maxUnitTypesToAttack,\r\n        uint256[] calldata maxUnitsToAttack\r\n    )\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyOwnerOrWorldAssetFromSameEpoch\r\n    {\r\n        updateState();\r\n        IArmy targetArmy = IArmy(targetArmyAddress);\r\n\r\n        //only target army position is updated because in order to attack, new position is required\r\n        //but in case target army is still in battle then army will exit battle whenever 'joinBattle' is called below\r\n        targetArmy.updateState();\r\n        uint32 targetArmyPosition = targetArmy.getCurrentPosition();\r\n\r\n        require(stunTiming.endTime == 0, \"army is stunned\");\r\n        require(movementTiming.endTime == 0, \"cannot attack while moving\");\r\n        require(currentPosition == targetArmyPosition, \"enemy is not near\");\r\n        require(!isArmyUnitsExceeds(targetArmyAddress, maxUnitTypesToAttack, maxUnitsToAttack), \"army has grown bigger\");\r\n\r\n        IBattleFactory battleFactory = IBattleFactory(registry().factoryContracts(keccak256(bytes(\"battle\"))));\r\n        address newBattleAddress = battleFactory.create(\r\n            address(world()),\r\n            epochNumber(),\r\n            \"BASIC\",\r\n            address(this),\r\n            targetArmyAddress\r\n        );\r\n\r\n        emit NewBattle(newBattleAddress, targetArmyAddress);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function joinBattle(address battleAddress, uint256 side)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyOwnerOrWorldAssetFromSameEpoch\r\n    {\r\n        updateState();\r\n\r\n        // If current army is moving, joinBattle should work only if caller = battle (joins on battle.init)\r\n        if (movementTiming.endTime != 0) {\r\n            require(\r\n                world().worldAssets(epochNumber(), msg.sender) == keccak256(bytes(\"battle\")),\r\n                \"cannot join while moving\"\r\n            );\r\n        }\r\n\r\n        // If current army is stunned, joinBattle should work only if caller = battle (joins on battle.init)\r\n        if (stunTiming.endTime != 0) {\r\n            require(\r\n                world().worldAssets(epochNumber(), msg.sender) == keccak256(bytes(\"battle\")),\r\n                \"cannot join battle while stunned\"\r\n            );\r\n        }\r\n\r\n        require(address(battle) == address(0), \"already in battle\");\r\n        require(getTotalUnitsCount() > 0, \"0 army can't join battle\");\r\n\r\n        IBattle(battleAddress).acceptArmyInBattle(address(this), side);\r\n        emit JoinedBattle(battleAddress, side);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function setUnitsInSiege(\r\n        string[] memory _addUnitsNames,\r\n        uint256[] memory _addUnitsCount,\r\n        string[] memory _removeUnitsNames,\r\n        uint256[] memory _removeUnitsCount\r\n    ) public override onlyActiveGame onlyOwnerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        require(stunTiming.endTime == 0, \"army is stunned\");\r\n\r\n        withdrawUnitsFromSiege(_removeUnitsNames, _removeUnitsCount);\r\n        startSiege(_addUnitsNames, _addUnitsCount);\r\n    }\r\n\r\n    /// @dev Sets specified units in siege\r\n    function startSiege(string[] memory _unitNames, uint256[] memory _unitsCount) internal {\r\n        require(_unitNames.length == _unitsCount.length, \"startSiege: invalid input\");\r\n        if (_unitsCount.length == 0) {\r\n            return;\r\n        }\r\n\r\n        require(movementTiming.endTime == 0, \"cannot siege while moving\");\r\n        require(address(battle) == address(0), \"cannot start siege while in battle\");\r\n\r\n        address _settlementAddress = address(epoch().settlements(getCurrentPosition()));\r\n\r\n        require(_settlementAddress != address(0), \"no settlement in current position\");\r\n        require(_settlementAddress != address(currentSettlement), \"cannot attack own settlement\");\r\n\r\n        ISettlement settlement = ISettlement(_settlementAddress);\r\n        if (address(settlement.siege()) == address(0)) {\r\n            settlement.createSiege();\r\n        }\r\n\r\n        siege = settlement.siege();\r\n\r\n        siege.addUnits(_unitNames, _unitsCount);\r\n        require(!siege.canLiquidate(address(this)), \"you cannot add unprotected units to the siege\");\r\n    }\r\n\r\n    /// @dev Withdraws units from siege\r\n    function withdrawUnitsFromSiege(string[] memory _unitNames, uint256[] memory _unitsCount) internal {\r\n        if (_unitsCount.length == 0) {\r\n            return;\r\n        }\r\n\r\n        siege.withdrawUnits(_unitNames, _unitsCount);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function setSiege(address _siegeAddress) public override onlyWorldAssetFromSameEpoch {\r\n        siege = ISiege(_siegeAddress);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function claimResources(address buildingAddress, uint256 _points)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyOwnerOrWorldAssetFromSameEpoch\r\n    {\r\n        updateState();\r\n        require(address(siege) != address(0), \"no siege\");\r\n\r\n        siege.claimResources(buildingAddress, _points);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getTotalSiegeSupport() public view override returns (uint256 totalSiegeSupport) {\r\n        string[] memory units = registry().getUnits();\r\n        uint256[] memory casualties = new uint256[](units.length);\r\n\r\n        if (address(battle) != address(0) && battle.canFinishBattle()) {\r\n            (, casualties) = battle.calculateArmyCasualties(address(this));\r\n        }\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n            (, , , , , , uint256 siegeSupport) = registry().unitsStats(unitName);\r\n\r\n            totalSiegeSupport +=\r\n                ((epoch().units(unitName).balanceOf(address(this)) - casualties[i]) * siegeSupport) /\r\n                1e18;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function isHomePosition() public view override returns (bool) {\r\n        if (canUpdatePosition()) {\r\n            return destinationPosition == currentSettlement.position();\r\n        }\r\n\r\n        return currentPosition == currentSettlement.position();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/battle/IBattleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Battle factory interface\r\n/// @notice Contains instance creator function\r\ninterface IBattleFactory {\r\n    /// @notice Creates Battle instance and initializes it with specified parameters\r\n    /// @dev Even though this function is opened, it can only be called by world or world asset\r\n    /// @param worldAddress World address\r\n    /// @param epochNumber Epoch number\r\n    /// @param assetName Name of the battle type (Currently only 'BASIC')\r\n    /// @param attackerArmyAddress Attacker army address\r\n    /// @param attackedArmyAddress Attacked army address\r\n    /// @return createdInstanceAddress Created instance address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address attackerArmyAddress,\r\n        address attackedArmyAddress\r\n    ) external returns (address createdInstanceAddress);\r\n}\r\n"
    },
    "contracts/core/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IRegistry.sol\";\r\n\r\ncontract Registry is IRegistry, Initializable {\r\n    /// @inheritdoc IRegistry\r\n    address public override mightyCreator;\r\n    /// @inheritdoc IRegistry\r\n    mapping(address => bool) public override isFactoryContract;\r\n    /// @inheritdoc IRegistry\r\n    mapping(bytes32 => address) public override factoryContracts;\r\n    /// @inheritdoc IRegistry\r\n    mapping(bytes32 => address) public override scriptContracts;\r\n    /// @inheritdoc IRegistry\r\n    mapping(string => UnitStats) public override unitsStats;\r\n    /// @inheritdoc IRegistry\r\n    uint256 public override globalMultiplier;\r\n    /// @inheritdoc IRegistry\r\n    uint256 public override settlementStartingPrice;\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    modifier onlyMightyCreator() {\r\n        require(msg.sender == mightyCreator, \"onlyMightyCreator\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function init(\r\n        uint256 _globalMultiplier,\r\n        uint256 _settlementStartingPrice\r\n    ) public override initializer {\r\n        mightyCreator = msg.sender;\r\n        globalMultiplier = _globalMultiplier;\r\n        settlementStartingPrice = _settlementStartingPrice;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function setFactoryContract(bytes32 id, address addr) public override onlyMightyCreator {\r\n        factoryContracts[id] = addr;\r\n        isFactoryContract[addr] = true;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function setScriptContractName(\r\n        string memory groupName,\r\n        string memory name,\r\n        address addr\r\n    ) public override onlyMightyCreator {\r\n        scriptContracts[keccak256(abi.encodePacked(groupName, name))] = addr;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function setUnitStats(string calldata unitName, UnitStats memory _unitStats) public override onlyMightyCreator {\r\n        unitsStats[unitName] = _unitStats;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGlobalMultiplier() public view override returns (uint256) {\r\n        return globalMultiplier;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getSiegePowerToSiegePointsMultiplier() public pure override returns (uint256) {\r\n        return 5e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getSiegePointsToResourceMultiplier(string memory resourceName) public view override returns (uint256) {\r\n        bytes32 resourceId = keccak256(bytes(resourceName));\r\n\r\n        if (resourceId == keccak256(bytes(\"FOOD\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WOOD\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"ORE\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WEAPON\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        revert(\"unknown resource\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getWorkerCapacityCoefficient(string memory buildingName) public pure override returns (uint256) {\r\n        bytes32 buildingId = keccak256(bytes(buildingName));\r\n\r\n        if (buildingId == keccak256(bytes(\"FARM\"))) {\r\n            return 10e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"LUMBERMILL\"))) {\r\n            return 7e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"MINE\"))) {\r\n            return 5e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"SMITHY\"))) {\r\n            return 3e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"FORT\"))) {\r\n            return 5e18;\r\n        }\r\n\r\n        revert(\"unknown building\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBasicProductionBuildingCoefficient(string memory buildingName) public pure override returns (uint256) {\r\n        bytes32 buildingId = keccak256(bytes(buildingName));\r\n\r\n        if (buildingId == keccak256(bytes(\"FARM\"))) {\r\n            return 0.5e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"LUMBERMILL\"))) {\r\n            return 0.35e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"MINE\"))) {\r\n            return 0.25e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"SMITHY\"))) {\r\n            return 0.2e18;\r\n        }\r\n\r\n        if (buildingId == keccak256(bytes(\"FORT\"))) {\r\n            return 0.2e18;\r\n        }\r\n\r\n        revert(\"unknown building\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function hasStartingTreasury(string memory buildingName) public pure override returns (bool) {\r\n//        bytes32 buildingId = keccak256(bytes(buildingName));\r\n//        if (buildingId == keccak256(bytes(\"LUMBERMILL\"))) {\r\n//            return true;\r\n//        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getToxicityByResource(string memory resourceName) public pure override returns (uint256) {\r\n        bytes32 resourceId = keccak256(bytes(resourceName));\r\n\r\n        if (resourceId == keccak256(bytes(\"FOOD\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WOOD\"))) {\r\n            return 2e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"ORE\"))) {\r\n            return 4e18;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WEAPON\"))) {\r\n            return 8e18;\r\n        }\r\n\r\n        revert(\"unknown resource\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getResourceWeight(string memory resourceName) public pure override returns (uint256) {\r\n        bytes32 resourceId = keccak256(bytes(resourceName));\r\n\r\n        if (resourceId == keccak256(bytes(\"FOOD\"))) {\r\n            return 0;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WOOD\"))) {\r\n            return 1;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"ORE\"))) {\r\n            return 2;\r\n        }\r\n\r\n        if (resourceId == keccak256(bytes(\"WEAPON\"))) {\r\n            return 3;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getRobberyFee() public view override returns (uint256) {\r\n        return 0.3e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getToTreasuryPercent() public pure override returns (uint256) {\r\n        return 0.9e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBaseBattleDuration() public pure override returns (uint256) {\r\n        return 24 hours;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBattleLobbyDurationPercent() public pure override returns (uint256) {\r\n        return 0.75e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBattleDurationStunMultiplier() public pure override returns (uint256) {\r\n        return 0.25e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMovementDurationStunMultiplier() public pure override returns (uint256) {\r\n        return 0.6e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBuildings() public pure override returns (string[] memory) {\r\n        string[] memory buildings = new string[](5);\r\n\r\n        buildings[0] = \"FARM\";\r\n        buildings[1] = \"LUMBERMILL\";\r\n        buildings[2] = \"MINE\";\r\n        buildings[3] = \"SMITHY\";\r\n        buildings[4] = \"FORT\";\r\n\r\n        return buildings;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGameResources() public pure override returns (GameResource[] memory) {\r\n        GameResource[] memory resources = new GameResource[](4);\r\n\r\n        resources[0] = GameResource(\"Mithraeum Food\", \"mFOOD\", \"FOOD\");\r\n        resources[1] = GameResource(\"Mithraeum Wood\", \"mWOOD\", \"WOOD\");\r\n        resources[2] = GameResource(\"Mithraeum Ore\", \"mORE\", \"ORE\");\r\n        resources[3] = GameResource(\"Mithraeum Weapon\", \"mWEAPON\", \"WEAPON\");\r\n\r\n        return resources;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGameUnits() public pure override returns (GameUnit[] memory) {\r\n        GameUnit[] memory units = new GameUnit[](3);\r\n\r\n        units[0] = GameUnit(\"Mithraeum Warrior\", \"mWARRIOR\", \"WARRIOR\");\r\n        units[1] = GameUnit(\"Mithraeum Archer\", \"mARCHER\", \"ARCHER\");\r\n        units[2] = GameUnit(\"Mithraeum Horseman\", \"mHORSEMAN\", \"HORSEMAN\");\r\n\r\n        return units;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getResources() public pure override returns (string[] memory) {\r\n        string[] memory resources = new string[](4);\r\n\r\n        resources[0] = \"FOOD\";\r\n        resources[1] = \"WOOD\";\r\n        resources[2] = \"ORE\";\r\n        resources[3] = \"WEAPON\";\r\n\r\n        return resources;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnits() public pure override returns (string[] memory) {\r\n        string[] memory units = new string[](3);\r\n\r\n        units[0] = \"WARRIOR\";\r\n        units[1] = \"ARCHER\";\r\n        units[2] = \"HORSEMAN\";\r\n\r\n        return units;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitHiringFortHpMultiplier() public pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitMaxFoodToSpendOnMove(string memory unitType) public pure override returns (uint256) {\r\n        bytes32 unitId = keccak256(bytes(unitType));\r\n\r\n        if (unitId == keccak256(bytes(\"WARRIOR\"))) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"ARCHER\"))) {\r\n            return 0.25e18;\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"HORSEMAN\"))) {\r\n            return 0.1e18;\r\n        }\r\n\r\n        revert(\"unknown unit\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getProsperityForDemilitarization(string memory unitType) public pure override returns (uint256) {\r\n        bytes32 unitId = keccak256(bytes(unitType));\r\n\r\n        if (unitId == keccak256(bytes(\"WARRIOR\"))) {\r\n            return 2e18;\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"ARCHER\"))) {\r\n            return 3e18;\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"HORSEMAN\"))) {\r\n            return 4e18;\r\n        }\r\n\r\n        revert(\"unknown unit\");\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsSummonDelay() public pure override returns (uint256) {\r\n        return 2 weeks;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxSettlementPerZone() public pure override returns (uint256) {\r\n        return 40;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsNoDestructionDelay() public pure override returns (uint256) {\r\n        return 10 days;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsPerZoneMultiplier() public pure override returns (uint256) {\r\n        return 5000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxCultistsPerZone() public pure override returns (uint256) {\r\n        return 10000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistUnitType() public pure override returns (string memory) {\r\n        return \"WARRIOR\";\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBuildingTokenTransferThresholdPercent() public pure override returns (uint256) {\r\n        return 0.3e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNewSettlementExtraResources() public view override returns (ExtraResource[] memory) {\r\n        ExtraResource[] memory extraResources = new ExtraResource[](0);\r\n//        ExtraResource[] memory extraResources = new ExtraResource[](2);\r\n//        extraResources[0] = ExtraResource(\"WOOD\", 5e18);\r\n//        extraResources[1] = ExtraResource(\"ORE\", 5e18);\r\n        return extraResources;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNewSettlementStartingPrice() public view override returns (uint256) {\r\n        return settlementStartingPrice;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getProductionTicksInSecond() public view override returns (uint256) {\r\n        return getMaxCultistsPerZone() / 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getDemilitarizationCooldown() public pure override returns (uint256) {\r\n        return 2 days;\r\n    }\r\n\r\n    function getUnitPriceDropByUnitType(string memory unitType) public pure override returns (uint256, uint256) {\r\n        bytes32 unitId = keccak256(bytes(unitType));\r\n\r\n        if (unitId == keccak256(bytes(\"WARRIOR\"))) {\r\n            return (9999966703519269, 10000000000000000);\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"ARCHER\"))) {\r\n            return (9999974173233430, 10000000000000000);\r\n        }\r\n\r\n        if (unitId == keccak256(bytes(\"HORSEMAN\"))) {\r\n            return (9999981189956406, 10000000000000000);\r\n        }\r\n\r\n        revert(\"unknown unit\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/battle/Battle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IBattle.sol\";\r\nimport \"../army/IArmy.sol\";\r\nimport \"../../tokens/resources/IResource.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\ncontract Battle is WorldAsset, IBattle {\r\n    /// @inheritdoc IBattle\r\n    uint32 public override position;\r\n    /// @inheritdoc IBattle\r\n    address[] public override sideA;\r\n    /// @inheritdoc IBattle\r\n    address[] public override sideB;\r\n    /// @inheritdoc IBattle\r\n    mapping(uint256 => mapping(string => uint256)) public override sideUnitsCount;\r\n    /// @inheritdoc IBattle\r\n    mapping(address => mapping(string => uint256)) public override armyUnitsCount;\r\n    /// @inheritdoc IBattle\r\n    mapping(uint256 => mapping(string => uint256)) public override casualties;\r\n    /// @inheritdoc IBattle\r\n    mapping(address => uint256) public override armySide;\r\n    /// @inheritdoc IBattle\r\n    Timing public override timing;\r\n    /// @inheritdoc IBattle\r\n    uint256 public override winningSide;\r\n\r\n    /// @inheritdoc IBattle\r\n    function init(\r\n        address attackerArmyAddress,\r\n        address attackedArmyAddress\r\n    ) public override initializer {\r\n        IArmy attackerArmy = IArmy(attackerArmyAddress);\r\n        IArmy attackedArmy = IArmy(attackedArmyAddress);\r\n\r\n        position = attackerArmy.getCurrentPosition();\r\n\r\n        timing.creationTime = uint64(block.timestamp);\r\n\r\n        ISettlement settlementOnBattlePosition = epoch().settlements(position);\r\n        address cultistsArmy = address(settlementOnBattlePosition.currentZone().cultistsSettlement().army());\r\n        bool isCultistsAttacked = attackedArmyAddress == cultistsArmy;\r\n\r\n        (,uint64 movementEndTime) = attackedArmy.movementTiming();\r\n\r\n        uint256 maxBattleDuration = 0;\r\n        if (movementEndTime != 0 && movementEndTime > timing.creationTime) {\r\n            maxBattleDuration = movementEndTime - timing.creationTime;\r\n        }\r\n\r\n        (uint64 lobbyDuration, uint64 ongoingDuration) = getTimings(\r\n            isCultistsAttacked,\r\n            maxBattleDuration,\r\n            calculateUnitsCount(attackerArmyAddress),\r\n            calculateUnitsCount(attackedArmyAddress)\r\n        );\r\n\r\n        timing.lobbyDuration = lobbyDuration;\r\n        timing.ongoingDuration = ongoingDuration;\r\n\r\n        attackerArmy.joinBattle(address(this), 1);\r\n        attackedArmy.joinBattle(address(this), 2);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function getSideALength() public view override returns (uint256) {\r\n        return sideA.length;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function getSideBLength() public view override returns (uint256) {\r\n        return sideB.length;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function isLobbyTime() public view override returns (bool) {\r\n        uint256 lobbyEndTime = timing.creationTime + timing.lobbyDuration;\r\n        return block.timestamp >= timing.creationTime && block.timestamp < lobbyEndTime;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function acceptArmyInBattle(\r\n        address armyAddress,\r\n        uint256 side\r\n    ) public override onlyWorldAssetFromSameEpoch onlyActiveGame {\r\n        require(side == 1 || side == 2, \"invalid side\");\r\n        require(isLobbyTime(), \"not a lobby time\");\r\n        IArmy army = IArmy(armyAddress);\r\n\r\n        require(position == army.currentPosition(), \"invalid position\");\r\n\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n            uint256 unitCount = epoch().units(unitName).balanceOf(address(army));\r\n\r\n            sideUnitsCount[side][unitName] += unitCount;\r\n            armyUnitsCount[armyAddress][unitName] += unitCount;\r\n        }\r\n\r\n        if (side == 1) {\r\n            sideA.push(armyAddress);\r\n        } else if (side == 2) {\r\n            sideB.push(armyAddress);\r\n        } else {\r\n            revert(\"invalid state\");\r\n        }\r\n\r\n        armySide[armyAddress] = side;\r\n\r\n        army.setBattle(address(this));\r\n\r\n        if (getSideALength() > 0 && getSideBLength() > 0) {\r\n            calculateAndSaveCasualties();\r\n        }\r\n\r\n        emit ArmyJoined(armyAddress, side);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function canFinishBattle() public view override returns (bool) {\r\n        return timing.creationTime > 0 && block.timestamp >= timing.creationTime + timing.lobbyDuration + timing.ongoingDuration;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function isFinishedBattle() public view override returns (bool) {\r\n        return timing.finishTime != 0;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function removeArmyFromBattle(address armyAddress) public override onlyActiveGame onlyWorldAssetFromSameEpoch {\r\n        require(isFinishedBattle(), \"battle still in process\");\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n\r\n        (, uint256[] memory unitsCount) = calculateArmyCasualties(armyAddress);\r\n\r\n        // It is important for 'setBattle' be after 'burnUnits' because\r\n        // burnUnits will trigger zone.updateState and zone.updateState rely on army.battle in order to properly save its time\r\n        army.burnUnits(registry().getUnits(), unitsCount);\r\n        army.setBattle(address(0));\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateArmyCasualties(address armyAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (bool, uint256[] memory)\r\n    {\r\n        uint256 side = armySide[armyAddress];\r\n\r\n        require(side == 1 || side == 2, \"wrong army address\");\r\n\r\n        string[] memory units = registry().getUnits();\r\n\r\n        uint256[] memory result = new uint256[](units.length);\r\n\r\n        bool isArmyWon = side == winningSide;\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            uint256 _sideUnitsCount = sideUnitsCount[side][unitName];\r\n            uint256 _armyUnitsCount = armyUnitsCount[armyAddress][unitName];\r\n\r\n            if (_sideUnitsCount == 0 || _armyUnitsCount == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 percent = (_armyUnitsCount * 1e18) / _sideUnitsCount;\r\n            uint256 sideUnitsCasualties = side == 1\r\n                ? casualties[1][unitName]\r\n                : casualties[2][unitName];\r\n\r\n            uint256 userCasualties = (sideUnitsCasualties * percent) / 1e18;\r\n\r\n            if (userCasualties == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 integerUserCasualties = MathExtension.roundDownWithPrecision(userCasualties, 1e18);\r\n            if (!isArmyWon) {\r\n                uint256 roundedUpIntegerUserCasualties = MathExtension.roundUpWithPrecision(userCasualties, 1e18);\r\n                integerUserCasualties = _armyUnitsCount >= roundedUpIntegerUserCasualties\r\n                    ? roundedUpIntegerUserCasualties\r\n                    : integerUserCasualties;\r\n            }\r\n\r\n            result[i] = integerUserCasualties;\r\n        }\r\n\r\n        return (isArmyWon, result);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateTimings(\r\n        uint256 globalMultiplier,\r\n        uint256 baseBattleDuration,\r\n        uint256 battleLobbyDurationPercent,\r\n        bool isCultistsAttacked,\r\n        uint256 units1,\r\n        uint256 units2,\r\n        uint256 maxBattleDuration\r\n    ) public view override returns (uint64, uint64) {\r\n        require(units1 != 0 && units2 != 0, \"can't attack 0 army\");\r\n\r\n        uint64 battleDuration = uint64(baseBattleDuration / globalMultiplier);\r\n        if (maxBattleDuration != 0 && maxBattleDuration < battleDuration) {\r\n            battleDuration = uint64(maxBattleDuration);\r\n        }\r\n\r\n        uint64 lobbyDuration = uint64(battleDuration * battleLobbyDurationPercent / 1e18);\r\n        if (!isCultistsAttacked) {\r\n            if (units1 >= units2 && units1 / units2 > 1) {\r\n                lobbyDuration = uint64(lobbyDuration * 2 * units2 / units1);\r\n            }\r\n\r\n            if (units2 > units1 && units2 / units1 > 1) {\r\n                lobbyDuration = uint64(lobbyDuration * 2 * units1 / units2);\r\n            }\r\n        }\r\n\r\n        return (lobbyDuration, battleDuration - lobbyDuration);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function getTimings(\r\n        bool isCultistsAttacked,\r\n        uint256 maxBattleDuration,\r\n        uint256 sideAUnitsCount,\r\n        uint256 sideBUnitsCount\r\n    ) public view override returns (uint64, uint64) {\r\n        uint256 globalMultiplier = registry().getGlobalMultiplier();\r\n        uint256 baseBattleDuration = registry().getBaseBattleDuration();\r\n        uint256 battleLobbyDurationPercent = registry().getBattleLobbyDurationPercent();\r\n\r\n        return calculateTimings(\r\n            globalMultiplier,\r\n            baseBattleDuration,\r\n            battleLobbyDurationPercent,\r\n            isCultistsAttacked,\r\n            sideAUnitsCount,\r\n            sideBUnitsCount,\r\n            maxBattleDuration\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function finishBattle() public override onlyActiveGame {\r\n        require(\r\n            block.timestamp >= timing.creationTime + timing.lobbyDuration + timing.ongoingDuration,\r\n            \"wait for starting time\"\r\n        );\r\n        require(!isFinishedBattle(), \"cannot finish battle again\");\r\n\r\n        timing.finishTime = uint64(timing.creationTime + timing.lobbyDuration + timing.ongoingDuration);\r\n\r\n        emit BattleFinished(timing.finishTime);\r\n\r\n        // In case if battle is finished on cultists position & cultists are in this battle => update cultists army state\r\n        ISettlement settlementOnThisPosition = epoch().settlements(position);\r\n        string memory settlementAssetType = IWorldAssetStorageAccessor(address(settlementOnThisPosition)).assetType();\r\n\r\n        if (\r\n            keccak256(bytes(settlementAssetType)) == keccak256(bytes(\"CULTISTS\"))\r\n            && address(settlementOnThisPosition.army().battle()) == address(this)\r\n        ) {\r\n            settlementOnThisPosition.army().updateState();\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates and saves casualties\r\n    function calculateAndSaveCasualties() internal {\r\n        (\r\n            uint256[] memory _sideACasualties,\r\n            uint256[] memory _sideBCasualties,\r\n            uint256 _winningSide\r\n        ) = calculateAllCasualties();\r\n\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            casualties[1][unitName] = _sideACasualties[i];\r\n            casualties[2][unitName] = _sideBCasualties[i];\r\n        }\r\n\r\n        winningSide = _winningSide;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateStage1Casualties()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory _sideACasualties,\r\n            uint256[] memory _sideBCasualties,\r\n            bytes memory stageParams\r\n        )\r\n    {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        _sideACasualties = new uint256[](units.length);\r\n        _sideBCasualties = new uint256[](units.length);\r\n\r\n        uint256 sideAOffense;\r\n        uint256 sideBOffense;\r\n\r\n        uint256 sideADefence;\r\n        uint256 sideBDefence;\r\n\r\n        // 1st stage\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            (uint256 weaponPowerStage1, uint256 armourPowerStage1, , , , , ) = registry().unitsStats(unitName);\r\n\r\n            sideAOffense += sideUnitsCount[1][unitName] * weaponPowerStage1 * 1e18;\r\n            sideBOffense += sideUnitsCount[2][unitName] * weaponPowerStage1 * 1e18;\r\n\r\n            sideADefence += sideUnitsCount[1][unitName] * armourPowerStage1 * 1e18;\r\n            sideBDefence += sideUnitsCount[2][unitName] * armourPowerStage1 * 1e18;\r\n        }\r\n\r\n        stageParams = abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence);\r\n\r\n        uint256 sideALossPercentageAfterStage1 = calculateSideLossPercentage(\r\n            sideBOffense,\r\n            sideADefence,\r\n            timing.lobbyDuration + timing.ongoingDuration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        uint256 sideBLossPercentageAfterStage1 = calculateSideLossPercentage(\r\n            sideAOffense,\r\n            sideBDefence,\r\n            timing.lobbyDuration + timing.ongoingDuration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        // 2nd stage\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            uint256 sideAUnitsLost = (sideUnitsCount[1][unitName] * sideALossPercentageAfterStage1) / 1e18;\r\n            if (sideAUnitsLost > sideUnitsCount[1][unitName]) {\r\n                _sideACasualties[i] = sideUnitsCount[1][unitName];\r\n            } else {\r\n                _sideACasualties[i] = sideAUnitsLost;\r\n            }\r\n\r\n            uint256 sideBUnitsLost = (sideUnitsCount[2][unitName] * sideBLossPercentageAfterStage1) / 1e18;\r\n            if (sideBUnitsLost > sideUnitsCount[2][unitName]) {\r\n                _sideBCasualties[i] = sideUnitsCount[2][unitName];\r\n            } else {\r\n                _sideBCasualties[i] = sideBUnitsLost;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateStage2Casualties(\r\n        uint256[] memory stage1SideACasualties,\r\n        uint256[] memory stage1SideBCasualties\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory _sideACasualties,\r\n            uint256[] memory _sideBCasualties,\r\n            bytes memory stageParams\r\n        )\r\n    {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        _sideACasualties = new uint256[](units.length);\r\n        _sideBCasualties = new uint256[](units.length);\r\n\r\n        uint256 sideAOffense;\r\n        uint256 sideBOffense;\r\n\r\n        uint256 sideADefence;\r\n        uint256 sideBDefence;\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            (, , uint256 weaponPowerStage2, uint256 armourPowerStage2, , , ) = registry().unitsStats(unitName);\r\n\r\n            uint256 unitsARemaining = sideUnitsCount[1][unitName] - stage1SideACasualties[i];\r\n            uint256 unitsBRemaining = sideUnitsCount[2][unitName] - stage1SideBCasualties[i];\r\n\r\n            sideAOffense += unitsARemaining * weaponPowerStage2 * 1e18;\r\n            sideBOffense += unitsBRemaining * weaponPowerStage2 * 1e18;\r\n\r\n            sideADefence += unitsARemaining * armourPowerStage2 * 1e18;\r\n            sideBDefence += unitsBRemaining * armourPowerStage2 * 1e18;\r\n        }\r\n\r\n        stageParams = abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence);\r\n\r\n        // In case if no units left in either side -> no stage 2 casualties\r\n        if (sideADefence == 0 || sideBDefence == 0) {\r\n            return (\r\n                _sideACasualties,\r\n                _sideBCasualties,\r\n                stageParams\r\n            );\r\n        }\r\n\r\n        uint256 sideALossPercentageAfterStage2 = calculateSideLossPercentage(\r\n            sideBOffense,\r\n            sideADefence,\r\n            timing.lobbyDuration + timing.ongoingDuration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        uint256 sideBLossPercentageAfterStage2 = calculateSideLossPercentage(\r\n            sideAOffense,\r\n            sideBDefence,\r\n            timing.lobbyDuration + timing.ongoingDuration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n       // result\r\n       for (uint256 i = 0; i < units.length; i++) {\r\n           string memory unitName = units[i];\r\n\r\n           {\r\n               uint256 sideAUnits = sideUnitsCount[1][unitName] - stage1SideACasualties[i];\r\n               uint256 sideAUnitsLost = (sideAUnits * sideALossPercentageAfterStage2) / 1e18;\r\n               if (sideAUnitsLost >= sideAUnits) {\r\n                   _sideACasualties[i] = sideAUnits;\r\n               } else {\r\n                   _sideACasualties[i] = sideAUnitsLost;\r\n               }\r\n           }\r\n\r\n           {\r\n               uint256 sideBUnits = sideUnitsCount[2][unitName] - stage1SideBCasualties[i];\r\n               uint256 sideBUnitsLost = (sideBUnits * sideBLossPercentageAfterStage2) / 1e18;\r\n               if (sideBUnitsLost >= sideBUnits) {\r\n                   _sideBCasualties[i] = sideBUnits;\r\n               } else {\r\n                   _sideBCasualties[i] = sideBUnitsLost;\r\n               }\r\n           }\r\n       }\r\n    }\r\n\r\n    /// @dev Calculates winning side by side-stage params\r\n    function calculateWinningSide(\r\n        bytes memory stage1Params,\r\n        bytes memory stage2Params\r\n    ) internal view returns (uint256) {\r\n        (\r\n            uint256 stage1SideAOffence,\r\n            uint256 stage1SideBOffence,\r\n            uint256 stage1SideADefence,\r\n            uint256 stage1SideBDefence\r\n        ) = abi.decode(stage1Params, (uint256, uint256, uint256, uint256));\r\n\r\n        (\r\n            uint256 stage2SideAOffence,\r\n            uint256 stage2SideBOffence,\r\n            uint256 stage2SideADefence,\r\n            uint256 stage2SideBDefence\r\n        ) = abi.decode(stage2Params, (uint256, uint256, uint256, uint256));\r\n\r\n        uint256 winningSide = 0;\r\n        uint256 sideALossCoefficient = stage1SideBOffence * 1e18 / stage1SideADefence + stage2SideBOffence * 1e18 / stage2SideADefence;\r\n        uint256 sideBLossCoefficient = stage1SideAOffence * 1e18 / stage1SideBDefence + stage2SideAOffence * 1e18 / stage2SideBDefence;\r\n        if (sideALossCoefficient > sideBLossCoefficient) {\r\n            winningSide = 2;\r\n        }\r\n\r\n        if (sideALossCoefficient < sideBLossCoefficient) {\r\n            winningSide = 1;\r\n        }\r\n\r\n        return winningSide;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateAllCasualties()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256 //Winning side (0 - both sides lost, 1 - side A Won, 2 - side B Won\r\n        )\r\n    {\r\n        //calculate stage1 casualties (based on initial sides)\r\n        (\r\n            uint256[] memory stage1SideACasualties,\r\n            uint256[] memory stage1SideBCasualties,\r\n            bytes memory stage1Params\r\n        ) = calculateStage1Casualties();\r\n\r\n        //calculate stage2 casualties (based on (initial-stage1Losses))\r\n        (\r\n            uint256[] memory stage2SideACasualties,\r\n            uint256[] memory stage2SideBCasualties,\r\n            bytes memory stage2Params\r\n        ) = calculateStage2Casualties(\r\n            stage1SideACasualties,\r\n            stage1SideBCasualties\r\n        );\r\n\r\n        uint256 winningSide = calculateWinningSide(\r\n            stage1Params,\r\n            stage2Params\r\n        );\r\n\r\n        uint256[] memory sideACasualties = new uint256[](stage1SideACasualties.length);\r\n        uint256[] memory sideBCasualties = new uint256[](stage1SideACasualties.length);\r\n\r\n        for (uint256 i = 0; i < stage1SideACasualties.length; i++) {\r\n            sideACasualties[i] = stage1SideACasualties[i] + stage2SideACasualties[i];\r\n            sideBCasualties[i] = stage1SideBCasualties[i] + stage2SideBCasualties[i];\r\n        }\r\n\r\n        return (sideACasualties, sideBCasualties, winningSide);\r\n    }\r\n\r\n    /// @dev Calculate side loss percentage (in 1e18 precision)\r\n    function calculateSideLossPercentage(\r\n        uint256 sideOffence,\r\n        uint256 sideDefence,\r\n        uint256 battleDuration,\r\n        uint256 baseBattleDuration\r\n    ) internal pure returns (uint256) {\r\n        uint256 loweredByBattleTimeOffence = (sideOffence * battleDuration) / baseBattleDuration;\r\n        return (loweredByBattleTimeOffence * 1e18) / sideDefence;\r\n    }\r\n\r\n    /// @dev Calculates total amount of units of specified army\r\n    function calculateUnitsCount(address armyAddress) internal view returns (uint256 unitsCount) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n            unitsCount += epoch().units(unitName).balanceOf(armyAddress);\r\n        }\r\n\r\n        return unitsCount;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/siege/SiegeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./ISiege.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./ISiegeFactory.sol\";\r\n\r\ncontract SiegeFactory is ISiegeFactory, WorldAssetFactory {\r\n    /// @inheritdoc ISiegeFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) public returns (address) {\r\n        ISiege siege = ISiege(createAndSet(worldAddress, epochNumber, \"siege\", assetName));\r\n        siege.init(settlementAddress);\r\n        return address(siege);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/siege/Siege.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./ISiege.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../building/IBuilding.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\ncontract Siege is WorldAsset, ISiege {\r\n    /// @inheritdoc ISiege\r\n    ISettlement public override currentSettlement;\r\n    /// @inheritdoc ISiege\r\n    mapping(address => ArmyInfo) public override armyInfo;\r\n    /// @inheritdoc ISiege\r\n    mapping(address => mapping(string => uint256)) public override storedUnits;\r\n    /// @inheritdoc ISiege\r\n    uint256 public override lastUpdate;\r\n    /// @inheritdoc ISiege\r\n    uint256 public override pointsPerShare;\r\n\r\n    /// @inheritdoc ISiege\r\n    function init(address settlementAddress) public override initializer {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n        lastUpdate = block.timestamp;\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getTotalDamageLastPeriod() public view override returns (uint256) {\r\n        return getTotalDamageByPeriod(block.timestamp - lastUpdate);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getTotalDamageByPeriod(uint256 _period) public view override returns (uint256) {\r\n        (uint256 _power, ) = calculateTotalSiegeStats();\r\n        return _power * (_period * registry().getGlobalMultiplier());\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function canLiquidate(address _armyAddress) public view override returns (bool) {\r\n        (uint256 armyPower, ) = calculateArmySiegeStats(_armyAddress);\r\n        return (IArmy(_armyAddress).getTotalSiegeSupport() < armyPower);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function liquidate(address _armyAddress) public override {\r\n        update();\r\n        IArmy(_armyAddress).updateState();\r\n        require(canLiquidate(_armyAddress), \"army cannot be liquidate\");\r\n        (uint256 _power, ) = calculateTotalSiegeStats();\r\n        require(_power > 0, \"nothing to liquidate\");\r\n\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            string memory unitName = units[i];\r\n            uint256 toLiquidateAmount = storedUnits[_armyAddress][unitName];\r\n\r\n            epoch().units(unitName).burn(toLiquidateAmount);\r\n            storedUnits[_armyAddress][unitName] = 0;\r\n\r\n            emit Liquidated(_armyAddress, unitName, toLiquidateAmount);\r\n        }\r\n\r\n        armyInfo[_armyAddress].rewardDebt = 0;\r\n        IArmy(_armyAddress).setSiege(address(0));\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function addUnits(string[] memory _unitsNames, uint256[] memory _unitsCount) public override onlyWorldAssetFromSameEpoch {\r\n        ArmyInfo storage army = armyInfo[msg.sender];\r\n        update();\r\n\r\n        (uint256 armyPower, uint256 armyMaxSupply) = calculateArmySiegeStats(msg.sender);\r\n        if (armyPower > 0) {\r\n            uint256 pending = armyPower * pointsPerShare - army.rewardDebt;\r\n            uint256 startArmyPoints = army.points;\r\n            if (pending > 0) {\r\n                army.points += pending;\r\n                if (army.points > armyMaxSupply) {\r\n                    army.points = armyMaxSupply;\r\n                }\r\n            }\r\n\r\n            emit PointsReceived(msg.sender, army.points - startArmyPoints);\r\n        }\r\n\r\n        for (uint256 i = 0; i < _unitsNames.length; i++) {\r\n            if (_unitsCount[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            require(MathExtension.isIntegerWithPrecision(_unitsCount[i], 1e18), \"startSiege: _unitsCount must be cell\");\r\n\r\n            string memory unitName = _unitsNames[i];\r\n\r\n            IUnits units = epoch().units(unitName);\r\n            units.transferFrom(msg.sender, address(this), _unitsCount[i]);\r\n            storedUnits[msg.sender][unitName] += _unitsCount[i];\r\n        }\r\n\r\n        (armyPower, ) = calculateArmySiegeStats(msg.sender);\r\n\r\n        require(armyPower > 0, \"cannot add 0 army power\");\r\n\r\n        army.rewardDebt = armyPower * pointsPerShare;\r\n\r\n        emit UnitsAdded(msg.sender, address(currentSettlement), _unitsNames, _unitsCount);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function withdrawUnits(string[] memory _unitsNames, uint256[] memory _unitsCount) public override onlyWorldAssetFromSameEpoch {\r\n        update();\r\n\r\n        ArmyInfo storage army = armyInfo[msg.sender];\r\n        (uint256 armyPower, uint256 armyMaxSupply) = calculateArmySiegeStats(msg.sender);\r\n        uint256 pending = armyPower * pointsPerShare - army.rewardDebt;\r\n\r\n        //down\r\n        if (pending > 0) {\r\n            uint256 startArmyPoints = army.points;\r\n            army.points += pending;\r\n            if (army.points > armyMaxSupply) {\r\n                army.points = armyMaxSupply;\r\n            }\r\n\r\n            emit PointsReceived(msg.sender, army.points - startArmyPoints);\r\n        }\r\n\r\n        //up\r\n\r\n        for (uint256 i = 0; i < _unitsNames.length; i++) {\r\n            if (_unitsCount[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            require(MathExtension.isIntegerWithPrecision(_unitsCount[i], 1e18), \"withdrawUnits: _unitsCount must be cell\");\r\n\r\n            string memory unitName = _unitsNames[i];\r\n\r\n            IUnits units = epoch().units(unitName);\r\n            require(storedUnits[msg.sender][unitName] >= _unitsCount[i], \"not enough units to withdraw\");\r\n            storedUnits[msg.sender][unitName] -= _unitsCount[i];\r\n            units.transferFrom(address(this), msg.sender, _unitsCount[i]);\r\n        }\r\n\r\n        (armyPower, armyMaxSupply) = calculateArmySiegeStats(msg.sender);\r\n        if (army.points > armyMaxSupply) {\r\n            army.points = armyMaxSupply;\r\n        }\r\n\r\n        army.rewardDebt = armyPower * pointsPerShare;\r\n\r\n        if (armyPower == 0) {\r\n            IArmy(msg.sender).setSiege(address(0));\r\n        }\r\n\r\n        emit UnitsWithdrawn(msg.sender, address(currentSettlement), _unitsNames, _unitsCount);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function calculateTotalSiegeStats() public view override returns (uint256 _power, uint256 _supply) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        uint256 totalUnitsCount = units.length;\r\n        uint256[] memory unitsCount = new uint256[](totalUnitsCount);\r\n\r\n        for (uint256 i = 0; i < totalUnitsCount; i++) {\r\n            string memory unitName = units[i];\r\n            IUnits units = epoch().units(unitName);\r\n            unitsCount[i] = units.balanceOf(address(this));\r\n        }\r\n\r\n        return calculateSiegeStats(unitsCount);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function calculateArmySiegeStats(address _armyAddress) public view override returns (uint256 _power, uint256 _supply) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        uint256 totalUnitsCount = units.length;\r\n\r\n        uint256[] memory unitsCount = new uint256[](totalUnitsCount);\r\n\r\n        for (uint256 i = 0; i < totalUnitsCount; i++) {\r\n            string memory unitName = units[i];\r\n            unitsCount[i] = storedUnits[_armyAddress][unitName];\r\n        }\r\n\r\n        return calculateSiegeStats(unitsCount);\r\n    }\r\n\r\n    /// @dev Calculates siege stats for specified unitsCount\r\n    function calculateSiegeStats(uint256[] memory _unitsCount) internal view returns (uint256 power_, uint256 supply_) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        for (uint256 i = 0; i < _unitsCount.length; i++) {\r\n            if (_unitsCount[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            string memory unitName = units[i];\r\n\r\n            (\r\n                uint256 weaponPowerStage1,\r\n                uint256 armourPowerStage1,\r\n                uint256 weaponPowerStage2,\r\n                uint256 armourPowerStage2,\r\n                uint256 siegePower,\r\n                uint256 siegeMaxSupply,\r\n                uint256 siegeSupport\r\n            ) = registry().unitsStats(unitName);\r\n\r\n            power_ += (_unitsCount[i] * siegePower) / 1e18;\r\n            supply_ += (_unitsCount[i] * siegeMaxSupply) / 1e18;\r\n        }\r\n\r\n        return (power_, supply_);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function update() public override {\r\n        currentSettlement.updateCurrentHealth();\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function systemUpdate(uint256 _totalDamage) public override onlyWorldAssetFromSameEpoch {\r\n        lastUpdate = block.timestamp;\r\n\r\n        (uint256 _power, ) = calculateTotalSiegeStats();\r\n\r\n        if (_power == 0) {\r\n            return;\r\n        }\r\n\r\n        pointsPerShare += ((_totalDamage * registry().getSiegePowerToSiegePointsMultiplier()) / 1e18) / _power;\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getUserPoints(address _armyAddress) public view override returns (uint256) {\r\n        return getUserPointsOnTime(_armyAddress, block.timestamp);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getUserPointsOnTime(address _armyAddress, uint256 timestamp) public view override returns (uint256) {\r\n        ArmyInfo storage army = armyInfo[_armyAddress];\r\n        (uint256 armyPower, uint256 armyMaxSupply) = calculateArmySiegeStats(_armyAddress);\r\n\r\n        (, uint256 damage) = currentSettlement.calculateCurrentHealthAndDamage(timestamp);\r\n\r\n        (uint256 _power, ) = calculateTotalSiegeStats();\r\n        if (_power == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _points = armyPower * pointsPerShare +\r\n            (armyPower * (damage * registry().getSiegePowerToSiegePointsMultiplier()) / 1e18) /\r\n            _power;\r\n\r\n        return Math.min(_points - army.rewardDebt + army.points, armyMaxSupply);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function claimResources(address buildingAddress, uint256 _points) public override onlyWorldAssetFromSameEpoch {\r\n        string[] memory empty;\r\n        uint256[] memory uintEmpty;\r\n        withdrawUnits(empty, uintEmpty);\r\n\r\n        IArmy army = IArmy(msg.sender);\r\n        ArmyInfo storage armyInfo = armyInfo[msg.sender];\r\n\r\n        require(buildingAddress != address(0), \"claimResources: building address is 0\");\r\n        require(armyInfo.points >= _points, \"not enough points\");\r\n\r\n        IBuilding producingResourceBuilding = IBuilding(buildingAddress);\r\n\r\n        address targetSettlement = address(epoch().settlements(army.getCurrentPosition()));\r\n        require(targetSettlement == address(producingResourceBuilding.currentSettlement()), \"invalid settlement\");\r\n\r\n        uint256 multiplier = registry().getSiegePointsToResourceMultiplier(\r\n            producingResourceBuilding.getProducingResourceName()\r\n        );\r\n        uint256 resourcesGain = (_points * multiplier) / 1e18;\r\n\r\n        producingResourceBuilding.updateState();\r\n\r\n        army.currentSettlement().currentZone().increaseToxicity(\r\n            address(army.currentSettlement()),\r\n            producingResourceBuilding.getProducingResourceName(),\r\n            resourcesGain\r\n        );\r\n\r\n        uint256 amountOfStolenAndBurnedResources = producingResourceBuilding.stealTreasury(army.getOwner(), resourcesGain);\r\n        require(amountOfStolenAndBurnedResources > 0, \"nothing to stolen or burned\");\r\n\r\n        uint256 pointsSpent = (amountOfStolenAndBurnedResources * 1e18) / multiplier;\r\n        require(pointsSpent > 0, \"nothing to claim\");\r\n\r\n        armyInfo.points = armyInfo.points - pointsSpent;\r\n\r\n        emit PointsSpent(msg.sender, pointsSpent);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getStoredUnits(address _armyAddress) public view override returns (uint256[] memory res) {\r\n        string[] memory units = registry().getUnits();\r\n\r\n        uint256 totalUnitsCount = units.length;\r\n        res = new uint256[](totalUnitsCount);\r\n\r\n        for (uint256 i = 0; i < totalUnitsCount; i++) {\r\n            string memory unitName = units[i];\r\n\r\n            res[i] = storedUnits[_armyAddress][unitName];\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/army/ArmyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IArmy.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IArmyFactory.sol\";\r\n\r\ncontract ArmyFactory is IArmyFactory, WorldAssetFactory {\r\n    /// @inheritdoc IArmyFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) public returns (address) {\r\n        IArmy army = IArmy(createAndSet(worldAddress, epochNumber, \"army\", assetName));\r\n        army.init(settlementAddress);\r\n        return address(army);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlement/CultistsSettlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../army/IArmyFactory.sol\";\r\nimport \"../zone/IZone.sol\";\r\nimport \"./ISettlement.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\ncontract CultistsSettlement is WorldAsset, ISettlement {\r\n    /// @inheritdoc ISettlement\r\n    IZone public override currentZone;\r\n    /// @inheritdoc ISettlement\r\n    IArmy public override army;\r\n    /// @inheritdoc ISettlement\r\n    uint32 public override position;\r\n\r\n    /// @inheritdoc ISettlement\r\n    function init(\r\n        uint256 createdWithOwnerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) public override initializer {\r\n        currentZone = IZone(zoneAddress);\r\n        position = settlementPosition;\r\n\r\n        createNewArmy();\r\n    }\r\n\r\n    /// @dev Creates settlements army\r\n    function createNewArmy() internal {\r\n        IArmyFactory armyFactory = IArmyFactory(registry().factoryContracts(keccak256(bytes((\"army\")))));\r\n        army = IArmy(armyFactory.create(address(world()), epochNumber(), \"BASIC\", address(this)));\r\n        emit NewArmy(address(army), position);\r\n    }\r\n\r\n    /// @notice For cultists settlement any provided address is not ruler\r\n    /// @inheritdoc ISettlement\r\n    function isRuler(address _user) public view override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    // Stubs for ISettlement\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function getSettlementOwner() public view override returns (address) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function ownerTokenId() public view returns (uint256) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function siege() public view returns (ISiege) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function buildings(string memory buildingName) public view returns (IBuilding) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function currentGovernorsEpoch() public view returns (uint256) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function governors(uint256 epoch, address isGovernor) public view returns (bool) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function extraProsperity() public view returns (uint256) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    // Functions\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function transferWorkers(address _to, uint256 _amount) public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function newBuilding(string memory _scriptName) public override returns (address) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function calculateCurrentHealthAndDamage(uint256 timestamp)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 currentHealth, uint256 damage)\r\n    {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function updateCurrentHealth() public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function createSiege() public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function updateFortHealth(uint256 _healthDiff, bool _isProduced) public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function massUpdate() public override {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function accumulatedCurrentProsperity(uint256 _timestamp) public view override returns (int256) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function getCurrentSiegePower() public view override returns (uint256) {\r\n        revert(\"unavailable\");\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function extendProsperity(uint256 prosperityAmount) public override {\r\n        revert(\"unavailable\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/battle/BattleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IBattle.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IBattleFactory.sol\";\r\n\r\ncontract BattleFactory is IBattleFactory, WorldAssetFactory {\r\n    /// @inheritdoc IBattleFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address attackerArmyAddress,\r\n        address attackedArmyAddress\r\n    ) public returns (address) {\r\n        IBattle battle = IBattle(createAndSet(worldAddress, epochNumber, \"battle\", assetName));\r\n        battle.init(attackerArmyAddress, attackedArmyAddress);\r\n        return address(battle);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/BuildingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IBuilding.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IBuildingFactory.sol\";\r\n\r\ncontract BuildingFactory is IBuildingFactory, WorldAssetFactory {\r\n    /// @inheritdoc IBuildingFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address settlementAddress\r\n    ) public returns (address) {\r\n        IBuilding building = IBuilding(createAndSet(worldAddress, epochNumber, \"building\", assetName));\r\n        building.init(settlementAddress);\r\n        return address(building);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/epoch/EpochFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../WorldAssetFactory.sol\";\r\nimport \"./IEpochFactory.sol\";\r\nimport \"./IEpoch.sol\";\r\n\r\ncontract EpochFactory is IEpochFactory, WorldAssetFactory {\r\n    /// @inheritdoc IEpochFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName\r\n    ) public returns (address) {\r\n        IEpoch epoch = IEpoch(createAndSet(worldAddress, epochNumber, \"epoch\", assetName));\r\n        epoch.init(epochNumber);\r\n        return address(epoch);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/SettlementMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./ISettlementMarketFactory.sol\";\r\nimport \"./ISettlementMarket.sol\";\r\nimport \"../WorldAssetFactory.sol\";\r\n\r\ncontract SettlementsMarketFactory is ISettlementsMarketFactory, WorldAssetFactory {\r\n    /// @inheritdoc ISettlementsMarketFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 epochNumber,\r\n        string memory assetName,\r\n        address zoneAddress\r\n    ) public returns (address) {\r\n        ISettlementsMarket settlementsMarket = ISettlementsMarket(createAndSet(worldAddress, epochNumber, \"settlementsMarket\", assetName));\r\n        settlementsMarket.init(zoneAddress);\r\n        return address(settlementsMarket);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/StubBlessToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title Stub bless token\r\n/// @notice Used for development deployments, where specific functions is bless token must be present for testing convenience. Should not be used in production\r\ncontract StubBlessToken is ERC20, Ownable {\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol\r\n    ) public ERC20(name, symbol) {\r\n\r\n    }\r\n\r\n    /// @notice Mints specified amount of tokens to specified address\r\n    /// @dev Only owner can mint tokens\r\n    /// @param dstAddress An address which will receive tokens\r\n    /// @param amount Tokens amount\r\n    function mintTo(\r\n        address dstAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        _mint(dstAddress, amount);\r\n    }\r\n\r\n    /// @notice Burns specified amount of tokens from specified address\r\n    /// @dev Only owner can burn tokens from address\r\n    /// @param srcAddress An address from which tokens will be burned\r\n    /// @param amount Tokens amount\r\n    function burnFrom(\r\n        address srcAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        _burn(srcAddress, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/SimpleProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nstruct SimpleProxyStorage {\r\n    address implementation;\r\n    address owner;\r\n}\r\n\r\nfunction getSimpleProxyStorage() pure returns (SimpleProxyStorage storage ds) {\r\n    //keccak256(\"mithraeum.simpleproxy\") is 89ebf6b655b5bf3480fb4246b9e8786d810726f923695e3ff9668f941b26cb1a\r\n    bytes32 position = 0x89ebf6b655b5bf3480fb4246b9e8786d810726f923695e3ff9668f941b26cb1a;\r\n    assembly {\r\n        ds.slot := position\r\n    }\r\n}\r\n\r\n/// @title Simple proxy contract\r\n/// @notice User of current proxy must be aware of simplicity nature of it, in particular case naming collision is not handled in it. Proxy parameters are written as specific slot address\r\ncontract SimpleProxy {\r\n    /// @notice Emitted when #transferOwnership is called\r\n    /// @param previousOwner Previous proxy owner\r\n    /// @param newOwner New proxy owner\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @dev Allows caller to be only owner\r\n    modifier onlyOwner() {\r\n        require(getSimpleProxyStorage().owner == msg.sender, \"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /// @dev Fallback function that delegates calls to the address returned by `proxyStorage.implementation`. Will run if no other function in the contract matches the call data.\r\n    fallback() external payable {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        address _impl = proxyStorage.implementation;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n\r\n            // (1) copy incoming call data\r\n            calldatacopy(ptr, 0, calldatasize())\r\n\r\n            // (2) forward call to logic contract\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n\r\n            // (3) retrieve return data\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // (4) forward return data back to caller\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Updates proxy implementation address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param _newImpl New implementation address\r\n    function setImplementation(address _newImpl) public onlyOwner {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        proxyStorage.implementation = _newImpl;\r\n    }\r\n\r\n    /// @notice Renounces proxy ownership\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /// @notice Transfers ownership to another address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param newOwner New owner address\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @dev Transfers ownership to another address\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        address oldOwner = proxyStorage.owner;\r\n        proxyStorage.owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title World resolver\r\n/// @notice Contains currently active world address\r\ncontract Resolver is Ownable {\r\n    /// @notice World address\r\n    /// @dev Updated when #setWorldAddress is called\r\n    address public world;\r\n\r\n    /// @notice Emitted when #setWorldAddress is called\r\n    /// @param worldAddress New world address\r\n    event NewWorldAddress(address worldAddress);\r\n\r\n    /// @notice Updates world address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param _worldAddress New world address\r\n    function setWorldAddress(address _worldAddress) public onlyOwner {\r\n        world = _worldAddress;\r\n        emit NewWorldAddress(_worldAddress);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 300
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}