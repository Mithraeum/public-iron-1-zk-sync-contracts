{
  "language": "Solidity",
  "sources": {
    "contracts/periphery/ArmyView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/army/IArmy.sol\";\r\nimport \"../core/assets/epoch/IEpoch.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\nimport \"../core/assets/battle/IBattle.sol\";\r\nimport \"../libraries/MathExtension.sol\";\r\n\r\n/// @title Army view contract\r\n/// @notice Contains helper functions to query army in simple read requests\r\ncontract ArmyView {\r\n    struct ArmyCombinedData {\r\n        address id;\r\n        address owner;\r\n        address ownerSettlementId;\r\n        uint32 currentPosition;\r\n        address currentPositionSettlementId;\r\n        address battleId;\r\n        uint256[] units;\r\n        uint256[] besiegingUnits;\r\n        uint256 robberyTokensCount;\r\n        uint32[] currentPath;\r\n        uint64 stunStartTime;\r\n        uint64 stunEndTime;\r\n        uint64 movementStartTime;\r\n        uint64 movementEndTime;\r\n        address destinationPositionSettlementId;\r\n        uint256 lastDemilitarizationTime;\r\n    }\r\n\r\n    /// @dev Calculates army owner\r\n    function getArmyOwner(IArmy army) internal view returns (address) {\r\n        bool isCultistArmy = address(army.currentSettlement()) == address(army.currentSettlement().currentZone().cultistsSettlement());\r\n        return !isCultistArmy ? army.currentSettlement().getSettlementOwner() : address(0);\r\n    }\r\n\r\n    /// @dev Calculates if battle can be finished at provided timestamp\r\n    function canFinishBattleAtProvidedTimestamp(\r\n        IBattle battle,\r\n        uint256 timestamp\r\n    ) internal view returns (bool) {\r\n        (uint64 creationTime, uint64 lobbyDuration, uint64 ongoingDuration, uint64 finishTime) = battle.timing();\r\n        return creationTime > 0 && timestamp >= creationTime + lobbyDuration + ongoingDuration;\r\n    }\r\n\r\n    /// @notice Calculates combined army data\r\n    /// @dev Provided timestamp takes into account only robberyTokensCount\r\n    /// @param armyAddress Army address\r\n    /// @param timestamp Timestamp at which robberyTokensCount will be calculated\r\n    /// @return armyCombinedData Army combined data\r\n    function getArmyCombinedData(address armyAddress, uint256 timestamp)\r\n        public\r\n        view\r\n        returns (ArmyCombinedData memory armyCombinedData)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n\r\n        IWorld world = IWorldAsset(armyAddress).world();\r\n        IEpoch epoch = IWorldAsset(armyAddress).epoch();\r\n\r\n        string[] memory units = world.registry().getUnits();\r\n\r\n        armyCombinedData.id = armyAddress;\r\n\r\n        armyCombinedData.currentPosition = army.currentPosition();\r\n        armyCombinedData.currentPositionSettlementId = address(epoch.settlements(armyCombinedData.currentPosition));\r\n        armyCombinedData.currentPath = army.getMovementPath();\r\n        armyCombinedData.destinationPositionSettlementId = armyCombinedData.currentPath.length > 0\r\n            ? address(epoch.settlements(armyCombinedData.currentPath[armyCombinedData.currentPath.length - 1]))\r\n            : address(0);\r\n\r\n        (armyCombinedData.stunStartTime, armyCombinedData.stunEndTime) = army.stunTiming();\r\n        (armyCombinedData.movementStartTime, armyCombinedData.movementEndTime) = army.movementTiming();\r\n\r\n        if (armyCombinedData.movementEndTime != 0 && timestamp >= armyCombinedData.movementEndTime) {\r\n            armyCombinedData.currentPosition = armyCombinedData.currentPath[armyCombinedData.currentPath.length - 1];\r\n            armyCombinedData.currentPositionSettlementId = armyCombinedData.destinationPositionSettlementId;\r\n            armyCombinedData.currentPath = new uint32[](0);\r\n            armyCombinedData.destinationPositionSettlementId = address(0);\r\n\r\n            uint64 movementDuration = armyCombinedData.movementEndTime - armyCombinedData.movementStartTime;\r\n            uint64 movementStunDuration = uint64(movementDuration * world.registry().getMovementDurationStunMultiplier() / 1e18);\r\n            uint64 movementStunStartTime = armyCombinedData.movementEndTime;\r\n            uint64 movementStunEndTime = movementStunStartTime + movementStunDuration;\r\n\r\n            if (movementStunEndTime > armyCombinedData.stunEndTime) {\r\n                armyCombinedData.stunStartTime = movementStunStartTime;\r\n                armyCombinedData.stunEndTime = movementStunEndTime;\r\n            }\r\n\r\n            armyCombinedData.movementStartTime = 0;\r\n            armyCombinedData.movementEndTime = 0;\r\n        }\r\n\r\n        armyCombinedData.owner = getArmyOwner(army);\r\n        armyCombinedData.ownerSettlementId = address(army.currentSettlement());\r\n\r\n        armyCombinedData.units = new uint256[](units.length);\r\n\r\n        for (uint256 i = 0; i < units.length; i++) {\r\n            armyCombinedData.units[i] = epoch.units(units[i]).balanceOf(armyAddress);\r\n        }\r\n\r\n        armyCombinedData.battleId = address(army.battle());\r\n        if (armyCombinedData.battleId != address(0)) {\r\n            IBattle battle = IBattle(armyCombinedData.battleId);\r\n            if (canFinishBattleAtProvidedTimestamp(battle, timestamp)) {\r\n                (bool isArmyWon, uint256[] memory casualties) = battle.calculateArmyCasualties(armyAddress);\r\n                for (uint256 i = 0; i < units.length; i++) {\r\n                    armyCombinedData.units[i] = armyCombinedData.units[i] - casualties[i];\r\n                }\r\n\r\n                if (!isArmyWon) {\r\n                    (uint64 battleCreationTime, uint64 lobbyDuration, uint64 ongoingDuration,) = battle.timing();\r\n                    uint64 battleDuration = lobbyDuration + ongoingDuration;\r\n                    uint64 stunDuration = uint64(battleDuration * world.registry().getBattleDurationStunMultiplier() / 1e18);\r\n                    uint64 battleStunStartTime = battleCreationTime + battleDuration;\r\n                    uint64 battleStunEndTime = battleStunStartTime + stunDuration;\r\n                    if (battleStunEndTime > armyCombinedData.stunEndTime) {\r\n                        armyCombinedData.stunStartTime = battleStunStartTime;\r\n                        armyCombinedData.stunEndTime = battleStunEndTime;\r\n                    }\r\n                }\r\n\r\n                armyCombinedData.battleId = address(0);\r\n            }\r\n        }\r\n\r\n        if (timestamp >= armyCombinedData.stunEndTime) {\r\n            armyCombinedData.stunStartTime = 0;\r\n            armyCombinedData.stunEndTime = 0;\r\n        }\r\n\r\n        armyCombinedData.besiegingUnits = new uint256[](units.length);\r\n\r\n        if (address(army.siege()) != address(0)) {\r\n            ISiege siege = army.siege();\r\n            armyCombinedData.robberyTokensCount = siege.getUserPointsOnTime(armyAddress, timestamp);\r\n            armyCombinedData.besiegingUnits = siege.getStoredUnits(armyAddress);\r\n        }\r\n\r\n        armyCombinedData.lastDemilitarizationTime = army.lastDemilitarizationTime();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/army/IArmy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../siege/ISiege.sol\";\r\n\r\n/// @title Army interface\r\n/// @notice Functions to read state/modify state in order to get current army parameters and/or interact with it\r\ninterface IArmy {\r\n    struct MovementTiming {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n    }\r\n\r\n    struct StunTiming {\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n    }\r\n\r\n    /// @notice Emitted when #burnUnits is called (#demilitarize or #exitBattle)\r\n    /// @param unitName Name of the unit type\r\n    /// @param value New amount of unit type presented in army\r\n    event UnitsChanged(string unitName, uint256 value);\r\n\r\n    /// @notice Emitted when #updatePosition is called (even though event can be emitted only on the next action related to the current army, de-facto army will update position based on 'movementTiming.endTime'\r\n    /// @param settlementAddress Address of the settlement where army currently staying on\r\n    /// @param position Position\r\n    event UpdatedPosition(address settlementAddress, uint32 position);\r\n\r\n    /// @notice Emitted when #newBattle is called. Army which attacks another army will emit this event.\r\n    /// @param battleAddress Created battle address\r\n    /// @param targetArmyAddress Address of the attacked army\r\n    event NewBattle(address battleAddress, address targetArmyAddress);\r\n\r\n    /// @notice Emitted when army joins battle. At the battle creation both armies (attacker and attacked) will emit this event. Attacker army will be side A and at attacked army will be sideB\r\n    /// @param battleAddress Address of the battle army joined in\r\n    /// @param side Side to which army joined (sideA = 1, sideB = 2)\r\n    event JoinedBattle(address indexed battleAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #updateState is called (even though event can be emitted only on the next action related to the current army, de-facto army will exit battle when battle is finished)\r\n    /// @param battleAddress Address of the battle army was in\r\n    event ExitedFromBattle(address battleAddress);\r\n\r\n    /// @notice Emitted when #move is called\r\n    /// @param destinationSettlement Address of the settlement army is moving to\r\n    /// @param movementStartTime Time at which movement began\r\n    /// @param movementFinishTime Time at which movement will end\r\n    /// @param path The path army is taken from starting position to destination position\r\n    event MovingTo(\r\n        address indexed destinationSettlement,\r\n        uint256 indexed movementStartTime,\r\n        uint256 indexed movementFinishTime,\r\n        uint32[] path\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this army belongs\r\n    /// @dev Immutable, initialized on the army creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Position where army currently stands on\r\n    /// @dev Updated when army updates position. It does not take into account if army is moving\r\n    /// @dev To proper query current position use #getCurrentPosition\r\n    function currentPosition() external view returns (uint32);\r\n\r\n    /// @notice Position to which are is moving to\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    /// @dev To proper calculate destination position you need to check if army finished movement by comparing current time and movementTiming.endTime\r\n    function destinationPosition() external view returns (uint32);\r\n\r\n    /// @notice Battle in which army is on\r\n    /// @dev If army is not in battle returns address(0). It does not take into account if battle is finished but army is not left the battle\r\n    function battle() external view returns (IBattle);\r\n\r\n    /// @notice Siege in which are army is on\r\n    /// @dev If army is not in siege returns address(0)\r\n    function siege() external view returns (ISiege);\r\n\r\n    /// @notice Movement timings\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    function movementTiming() external view returns (uint64 startTime, uint64 endTime);\r\n\r\n    /// @notice Stun timings\r\n    /// @dev Updated when army finishes move or when army loses battle\r\n    function stunTiming() external view returns (uint64 startTime, uint64 endTime);\r\n\r\n    /// @notice Path army is taken during movement\r\n    /// @dev Updated when army starts moving. It does not take into account if army is finished move by time\r\n    /// @dev To proper query entire movementPath use #getMovementPath\r\n    function movementPath(uint256 index) external view returns (uint32);\r\n\r\n    /// @notice Time at which last demilitarization occured\r\n    /// @dev Updated when #demilitarize is called\r\n    function lastDemilitarizationTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Path army is taken during movement\r\n    /// @dev Useful to get entire movement path rather than querying each path item by index. It does not take into account if army is finished move by time\r\n    /// @return path Entire path army is taken during movement\r\n    function getMovementPath() external view returns (uint32[] memory path);\r\n\r\n    /// @notice Updates army state to the current block\r\n    /// @dev Called on every action which are based on army state and time\r\n    function updateState() external;\r\n\r\n    /// @notice Initiates army movement to the settlement\r\n    /// @dev Even though path can be provided artificial only allowed movement to a settlement\r\n    /// @param path Path army will take to the settlement\r\n    /// @param foodToSpendOnFeeding Amount of food army will take from current position settlements FARM in order to decrease total time army will take to get to destination position\r\n    function move(uint32[] memory path, uint256 foodToSpendOnFeeding) external;\r\n\r\n    /// @notice Demilitarizes part of the army. Demilitarization provides prosperity to the settlement army is currently staying on\r\n    /// @dev Even though demilitarization of 0 units may seem reasonable, it is disabled\r\n    /// @param unitNames Names of the unit types for demilitarization\r\n    /// @param unitsCount Amount of units for demilitarization for every unit type\r\n    function demilitarize(string[] memory unitNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Sets battle\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param battleAddress Battle address\r\n    function setBattle(address battleAddress) external;\r\n\r\n    /// @notice Initiates battle with another army is both are not in battle\r\n    /// @dev Creates IBattle and sets both armies in created battle\r\n    /// @param armyAddress Address of the army this army will attack\r\n    /// @param maxUnitTypesToAttack Max units types to attack\r\n    /// @param maxUnitsToAttack Max units to attack\r\n    function newBattle(\r\n        address armyAddress,\r\n        string[] calldata maxUnitTypesToAttack,\r\n        uint256[] calldata maxUnitsToAttack\r\n    ) external;\r\n\r\n    /// @notice Joins current army in battle to the provided side\r\n    /// @dev Moving army is able to join battle only if caller is another army (drags it into battle)\r\n    /// @param battleAddress Battle address army will join\r\n    /// @param side Side of the battle army will join (sideA = 1, sideB = 2)\r\n    function joinBattle(address battleAddress, uint256 side) external;\r\n\r\n    /// @notice Burns units from the army\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypes Unit types for burning\r\n    /// @param unitAmounts Amount of units for burning for every unit type\r\n    function burnUnits(string[] memory unitTypes, uint256[] memory unitAmounts) external;\r\n\r\n    /// @notice Calculates current position taking to the account #movementTimings\r\n    /// @dev This method should be used to determine real army position\r\n    /// @return position Position\r\n    function getCurrentPosition() external view returns (uint32 position);\r\n\r\n    /// @notice Sets and withdraw units to/from siege\r\n    /// @dev Provides ability to atomically setup/re-setup siege\r\n    /// @param addUnitsNames Names of the unit types to put in siege\r\n    /// @param addUnitsCount Amount of units to put in siege for every unit type\r\n    /// @param removeUnitsNames Names of the unit types to withdraw from siege\r\n    /// @param removeUnitsCount Amount of units to withdraw from siege for every unit type\r\n    function setUnitsInSiege(\r\n        string[] memory addUnitsNames,\r\n        uint256[] memory addUnitsCount,\r\n        string[] memory removeUnitsNames,\r\n        uint256[] memory removeUnitsCount\r\n    ) external;\r\n\r\n    /// @notice Swaps accumulated robbery tokens in siege for resource\r\n    /// @dev Amount of points will be taken may be lesser if building does not have resources in its treasury\r\n    /// @param buildingAddress Address of the building treasury of which will be robbed\r\n    /// @param points Amount of points to spend for resources\r\n    function claimResources(address buildingAddress, uint256 points) external;\r\n\r\n    /// @notice Calculates total siege support of the army\r\n    /// @dev For every unit type placed in siege calculates sum of all of them\r\n    /// @return totalSiegeSupport Total siege support of the army\r\n    function getTotalSiegeSupport() external view returns (uint256 totalSiegeSupport);\r\n\r\n    /// @notice Sets siege\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param siegeAddress Siege address\r\n    function setSiege(address siegeAddress) external;\r\n\r\n    /// @notice Return owner of the army\r\n    /// @dev Same as owner of the settlement to which this army belongs\r\n    /// @return ownerAddress Address of the owner of the army\r\n    function getOwner() external view returns (address ownerAddress);\r\n\r\n    /// @notice Calculates is army on its home position\r\n    /// @dev Takes into account if army movement is finished\r\n    /// @return isHomePosition Is army on home position\r\n    function isHomePosition() external view returns (bool isHomePosition);\r\n}\r\n"
    },
    "contracts/core/assets/epoch/IEpoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Epoch interface\r\n/// @notice Functions to read state/modify state in order to get current epoch parameters and/or interact with it\r\ninterface IEpoch {\r\n    /// @notice Emitted when epoch resource is created\r\n    /// @param resourceAddress Resource address\r\n    /// @param resourceName Resource name\r\n    event NewResource(\r\n        address resourceAddress,\r\n        string resourceName\r\n    );\r\n\r\n    /// @notice Emitted when epoch units is created\r\n    /// @param unitsAddress Units address\r\n    /// @param unitsName Units name\r\n    event NewUnits(\r\n        address unitsAddress,\r\n        string unitsName\r\n    );\r\n\r\n    /// @notice Emitted when epoch workers is created\r\n    /// @param workersAddress Workers address\r\n    event NewWorkers(\r\n        address workersAddress\r\n    );\r\n\r\n    /// @notice Emitted when epoch prosperity is created\r\n    /// @param prosperityAddress Prosperity address\r\n    event NewProsperity(\r\n        address prosperityAddress\r\n    );\r\n\r\n    /// @notice Emitted when #activateZone is called\r\n    /// @param zoneAddress Zone address\r\n    /// @param zoneIndex Zone index\r\n    event NewZoneActivated(\r\n        address zoneAddress,\r\n        uint256 zoneIndex\r\n    );\r\n\r\n    /// @notice Emitted when #newAssetSettlement is called\r\n    /// @param contractAddress Created settlement address\r\n    /// @param scriptName Settlement type (BASIC/CULTISTS)\r\n    /// @param zoneAddress Address of the zone where settlement is created\r\n    /// @param position Position\r\n    event NewSettlement(\r\n        address indexed contractAddress,\r\n        string scriptName,\r\n        address zoneAddress,\r\n        uint32 position\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice An array of attached zones to the continent\r\n    /// @dev Updated when #attachZoneToTheContinent is called\r\n    function zones(uint256 index) external view returns (IZone);\r\n\r\n    /// @notice Mapping containing settlement by provided x and y coordinates\r\n    /// @dev Updated when new settlement is created\r\n    function settlements(uint32 position) external view returns (ISettlement);\r\n\r\n    /// @notice Most recent cultists summon time\r\n    /// @dev Updated when #increaseTotalCultists is called\r\n    function mostRecentCultistsSummonTime() external view returns (uint256);\r\n\r\n    /// @notice Total cultists\r\n    /// @dev Updated when #increaseTotalCultists or #decreaseTotalCultists is called\r\n    function totalCultists() external view returns (uint256);\r\n\r\n    /// @notice Workers token\r\n    /// @dev Updated when #setWorkersContract is called\r\n    function workers() external view returns (IWorkers);\r\n\r\n    /// @notice Prosperity token\r\n    /// @dev Updated when #setProsperityContract is called\r\n    function prosperity() external view returns (IProsperity);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #addUserSettlement is called\r\n    function userSettlements(uint256 val) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing game resources by name\r\n    /// @dev Updated when #addResource is called\r\n    function resources(string memory name) external view returns (IResource);\r\n\r\n    /// @notice Mapping containing units by name\r\n    /// @dev Updated when #addUnit is called\r\n    function units(string memory name) external view returns (IUnits);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param epochNumber Epoch number\r\n    function init(uint256 epochNumber) external;\r\n\r\n    /// @notice Creates zone with provided positions and tile types\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param zoneId Zone id\r\n    function activateZone(uint256 zoneId) external;\r\n\r\n    /// @notice Restores settlement from previous epoch by provided position\r\n    /// @dev Any address can restore user settlement\r\n    /// @param position Position\r\n    function restoreSettlement(\r\n        uint32 position\r\n    ) external;\r\n\r\n    /// @notice Creates new user settlement\r\n    /// @dev Bless tokens will be deducted from msg.sender\r\n    /// @param position Position\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param newSettlementStartingPrice New settlement starting price\r\n    /// @return settlementAddress Settlement address\r\n    function newSettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 newSettlementStartingPrice\r\n    ) external returns (address settlementAddress);\r\n\r\n    /// @notice Creates settlement by type\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param position Position\r\n    /// @param assetName Settlement type (BASIC/CULTISTS)\r\n    /// @param performAttachmentValidation Whether is to perform attachment validation or not (CULTISTS or restored BASIC may not be attached to anything)\r\n    function newAssetSettlement(\r\n        uint256 ownerTokenId,\r\n        uint32 position,\r\n        string memory assetName,\r\n        bool performAttachmentValidation\r\n    ) external returns (address);\r\n\r\n    /// @notice Summons cultists in specified zones\r\n    /// @dev Batch cultists summon\r\n    /// @param zoneIndices Zone indices\r\n    function summonCultistsBatch(\r\n        uint256[] memory zoneIndices\r\n    ) external;\r\n\r\n    /// @notice Increases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists minted\r\n    function increaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists burned\r\n    function decreaseTotalCultists(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\n\r\ninterface IWorldAsset {\r\n    /// @notice World\r\n    /// @dev Value is dereferenced from proxy storage\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Registry\r\n    /// @dev Value is dereferenced from world\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Epoch\r\n    /// @dev Value is dereferenced from proxy storage and world\r\n    function epoch() external view returns (IEpoch);\r\n}\r\n"
    },
    "contracts/core/assets/battle/IBattle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\n\r\n/// @title Battle interface\r\n/// @notice Functions to read state/modify state in order to get current battle parameters and/or interact with it\r\ninterface IBattle {\r\n    struct Timing {\r\n        uint64 creationTime;\r\n        uint64 lobbyDuration;\r\n        uint64 ongoingDuration;\r\n        uint64 finishTime;\r\n    }\r\n\r\n    /// @notice Emitted when army joined battle\r\n    /// @param armyAddress Address of the joined army\r\n    /// @param side Side to which army is joined (sideA = 1, sideB = 2)\r\n    event ArmyJoined(address armyAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #finishBattle is called\r\n    /// @param finishTime Time at which battle is finished\r\n    event BattleFinished(uint256 finishTime);\r\n\r\n    // State variables\r\n\r\n    /// @notice Position at which battle is being held\r\n    /// @dev Immutable, initialized on the battle creation\r\n    function position() external view returns (uint32);\r\n\r\n    /// @notice An array of armies joined to side A\r\n    /// @dev Updated when army joins side A\r\n    /// @param index Index inside the array\r\n    /// @return armyAddress Army address at the specified index\r\n    function sideA(uint256 index) external view returns (address armyAddress);\r\n\r\n    /// @notice An array of armies joined to side B\r\n    /// @dev Updated when army joins side B\r\n    /// @param index Index inside the array\r\n    /// @return armyAddress Army address at the specified index\r\n    function sideB(uint256 index) external view returns (address armyAddress);\r\n\r\n    /// @notice Mapping that contains units amount by side and unit type\r\n    /// @dev Updated when army joins side\r\n    /// @param side Side of which query units amount (sideA = 1, sideB = 2)\r\n    /// @param unitName Unit type to query\r\n    /// @return unitsCount Amount of units by specified side and unit type\r\n    function sideUnitsCount(uint256 side, string memory unitName) external view returns (uint256 unitsCount);\r\n\r\n    /// @notice Mapping that contains amount of units by army address and unit type\r\n    /// @dev Updated when army joins battle\r\n    /// @param armyAddress Address of the army\r\n    /// @param unitName Unit type to query\r\n    /// @return unitsCount Amount of units by army address and unit type\r\n    function armyUnitsCount(address armyAddress, string memory unitName) external view returns (uint256 unitsCount);\r\n\r\n    /// @notice Mapping that contains amount of casualties after battle is finished\r\n    /// @dev Updated when #startBattle is called\r\n    /// @param side Side of which query casualties amount (sideA = 1, sideB = 2)\r\n    /// @param unitName Unit type to query\r\n    /// @return casualtiesCount Amount of casualties by side and unit type\r\n    function casualties(uint256 side, string memory unitName) external view returns (uint256 casualtiesCount);\r\n\r\n    /// @notice Mapping that contains side at which joined army is on\r\n    /// @dev Updated when #acceptArmyInBattle is called\r\n    /// @param armyAddress Address of the army\r\n    /// @return armySide Side of specified army (sideA = 1, sideB = 2)\r\n    function armySide(address armyAddress) external view returns (uint256 armySide);\r\n\r\n    /// @notice Battle time parameters\r\n    /// @dev Updated when battle initialized, first armies joined and finished (#initBattle, #acceptArmyInBattle, #startBattle)\r\n    /// @return creationTime Time when battle is created\r\n    /// @return lobbyDuration Lobby duration, initialized when first two armies joined\r\n    /// @return ongoingDuration Ongoing duration, initialized when first two armies joined\r\n    /// @return finishTime Time when battle is finished\r\n    function timing()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 creationTime,\r\n            uint64 lobbyDuration,\r\n            uint64 ongoingDuration,\r\n            uint64 finishTime\r\n        );\r\n\r\n    /// @notice Winning side\r\n    /// @dev Updated when #finishBattle is called\r\n    /// @return winningSide Winning side (no winner = 0, sideA = 1, sideB = 2)\r\n    function winningSide() external view returns (uint256 winningSide);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param attackerArmyAddress Attacker army address\r\n    /// @param attackedArmyAddress Attacked army address\r\n    function init(address attackerArmyAddress, address attackedArmyAddress) external;\r\n\r\n    /// @notice Calculates amount of armies joined to side A\r\n    /// @dev Basically returns length of sideA array\r\n    /// @return armiesCount Amount of armies joined to side A\r\n    function getSideALength() external view returns (uint256 armiesCount);\r\n\r\n    /// @notice Calculates amount of armies joined to side B\r\n    /// @dev Basically returns length of sideA array\r\n    /// @return armiesCount Amount of armies joined to side B\r\n    function getSideBLength() external view returns (uint256 armiesCount);\r\n\r\n    /// @notice Accepts army in battle\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param armyAddress Army address\r\n    /// @param side Side to which army will join\r\n    function acceptArmyInBattle(address armyAddress, uint256 side) external;\r\n\r\n    /// @notice Removes army from battle\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param armyAddress Army address\r\n    function removeArmyFromBattle(address armyAddress) external;\r\n\r\n    /// @notice Finishes battle\r\n    /// @dev Sets finish time\r\n    function finishBattle() external;\r\n\r\n    /// @notice Calculates casualties for first battle stage\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage1Casualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for second battle stage (based on casualties from first battle stage)\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @param stage1SideACasualties Stage 1 side A casualties\r\n    /// @param stage1SideBCasualties Stage 1 side B casualties\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage2Casualties(\r\n        uint256[] memory stage1SideACasualties,\r\n        uint256[] memory stage1SideBCasualties\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for all battle stages\r\n    /// @dev Uses values from battles' sideUnitsCount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side A casualties\r\n    /// @return winningSide Winning side (0 - both sides lost, 1 - side A Won, 2 - side B Won\r\n    function calculateAllCasualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            uint256 winningSide\r\n        );\r\n\r\n    /// @notice Calculates lobby and ongoing duration\r\n    /// @dev Returns same value as #calculateTimings but without the need to provide all parameters\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @param sideAUnitsCount Side A units count\r\n    /// @param sideBUnitsCount Side B units count\r\n    /// @return lobbyDuration Lobby duration\r\n    /// @return ongoingDuration Ongoing duration\r\n    function getTimings(\r\n        bool isCultistsAttacked,\r\n        uint256 maxBattleDuration,\r\n        uint256 sideAUnitsCount,\r\n        uint256 sideBUnitsCount\r\n    ) external view returns (uint64 lobbyDuration, uint64 ongoingDuration);\r\n\r\n    /// @notice Calculates if battle can be finished\r\n    /// @dev Checks if finishTime is set and current block.timestamp > creationTime + lobbyDuration + ongoingDuration\r\n    /// @return canFinishBattle Can battle be finished\r\n    function canFinishBattle() external view returns (bool canFinishBattle);\r\n\r\n    /// @notice Calculates if battle is finished\r\n    /// @dev Checks if finishTime is not zero\r\n    /// @return isFinishedBattle Is finished battle\r\n    function isFinishedBattle() external view returns (bool isFinishedBattle);\r\n\r\n    /// @notice Calculates casualties for specified army\r\n    /// @dev Provides valid results only for finished battle\r\n    /// @param armyAddress Address of army presented in battle\r\n    /// @return isArmyWon Is army won\r\n    /// @return unitAmounts Amount of casualties for related unit types\r\n    function calculateArmyCasualties(address armyAddress)\r\n        external\r\n        view\r\n        returns (\r\n            bool isArmyWon,\r\n            uint256[] memory unitAmounts\r\n        );\r\n\r\n    /// @notice Calculates if lobby is opened\r\n    /// @dev Calculates if lobby is opened\r\n    /// @return isLobbyTime Is lobby is opened\r\n    function isLobbyTime() external view returns (bool isLobbyTime);\r\n\r\n    /// @notice Calculates lobby duration and ongoing duration based on specified parameters\r\n    /// @dev globalMultiplier, baseLobbyDuration, baseOngoingDuration parameters from registry\r\n    /// @param globalMultiplier Global multiplier (from registry)\r\n    /// @param baseBattleDuration Base battle duration (from registry)\r\n    /// @param battleLobbyDurationPercent Battle lobby duration percent (from registry)\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param units1 Amount of units from attacker army\r\n    /// @param units2 Amount of units from attacked army\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @return lobbyDuration Lobby duration\r\n    /// @return ongoingDuration Ongoing duration\r\n    function calculateTimings(\r\n        uint256 globalMultiplier,\r\n        uint256 baseBattleDuration,\r\n        uint256 battleLobbyDurationPercent,\r\n        bool isCultistsAttacked,\r\n        uint256 units1,\r\n        uint256 units2,\r\n        uint256 maxBattleDuration\r\n    ) external view returns (uint64 lobbyDuration, uint64 ongoingDuration);\r\n}\r\n"
    },
    "contracts/libraries/MathExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Extension of math library\r\n/// @notice Contains helper functions for some math operations\r\nlibrary MathExtension {\r\n    /// @dev Calculates square root of uint256 using Babylonian Method\r\n    function sqrt(uint256 y) external pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding down\r\n    function roundDownWithPrecision(uint256 value, uint256 precision) public pure returns (uint256) {\r\n        return (value / precision) * precision;\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding up\r\n    function roundUpWithPrecision(uint256 value, uint256 precision) external pure returns (uint256) {\r\n        uint256 roundedValue = roundDownWithPrecision(value, precision);\r\n        if (value % precision != 0) {\r\n            roundedValue += precision;\r\n        }\r\n\r\n        return roundedValue;\r\n    }\r\n\r\n    /// @dev Check if uint256 value with provided precision integer value or not\r\n    function isIntegerWithPrecision(uint256 value, uint256 precision) external pure returns (bool) {\r\n        return value % precision == 0;\r\n    }\r\n}\r\n"
    },
    "contracts/core/IWorld.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"./tokens/resources/IResource.sol\";\r\nimport \"./assets/epoch/IEpoch.sol\";\r\nimport \"./tokens/prosperity/IProsperity.sol\";\r\nimport \"./tokens/units/IUnits.sol\";\r\nimport \"./tokens/workers/IWorkers.sol\";\r\nimport \"./geography/IGeography.sol\";\r\nimport \"./crossEpochsMemory/ICrossEpochsMemory.sol\";\r\nimport \"./rewardPool/IRewardPool.sol\";\r\nimport \"./distributions/IDistributions.sol\";\r\n\r\n/// @title World interface\r\n/// @notice Functions to read state/modify state of game world\r\ninterface IWorld {\r\n    /// @notice Emitted when world initialized\r\n    /// @param registryContractAddress Registry contract address\r\n    /// @param geographyAddress Geography contract address\r\n    /// @param bannersAddress Mithraeum banners contract address\r\n    /// @param blessTokenAddress Bless token address\r\n    /// @param distributionsAddress Distributions token address\r\n    /// @param rewardPoolAddress Reward pool address\r\n    event WorldInitialized(\r\n        address registryContractAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address blessTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    );\r\n\r\n    /// @notice Emitted when #setGameStartTime is called\r\n    /// @param timestamp New game start time\r\n    event GameStartTimeUpdated(uint timestamp);\r\n\r\n    /// @notice Emitted when #setGameFinishTime is called\r\n    /// @param timestamp New game finish time\r\n    event GameFinishTimeUpdated(uint timestamp);\r\n\r\n    /// @notice Emitted when world initialized or #destroyCurrentEpoch is called\r\n    /// @param epochAddress New epoch address\r\n    /// @param epochNumber New epoch number\r\n    event NewWorldEpoch(address epochAddress, uint256 epochNumber);\r\n\r\n    /// @notice Emitted after new epoch initialization\r\n    /// @param epochNumber New epoch number\r\n    event CurrentEpochNumberUpdated(uint256 epochNumber);\r\n\r\n    // State variables\r\n\r\n    /// @notice Registry\r\n    /// @dev Immutable, initialized on creation\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Banners token\r\n    /// @dev Immutable, initialized on creation\r\n    function bannerContract() external view returns (IERC721);\r\n\r\n    /// @notice Bless token\r\n    /// @dev Immutable, initialized on creation\r\n    function blessToken() external view returns (IERC20);\r\n\r\n    /// @notice Distributions token\r\n    /// @dev Immutable, initialized on creation\r\n    function distributions() external view returns (IDistributions);\r\n\r\n    /// @notice Cross epochs memory\r\n    /// @dev Immutable, initialized on creation\r\n    function crossEpochsMemory() external view returns (ICrossEpochsMemory);\r\n\r\n    /// @notice Reward pool\r\n    /// @dev Immutable, initialized on creation\r\n    function rewardPool() external view returns (IRewardPool);\r\n\r\n    /// @notice Game start time\r\n    /// @dev Updated when #setGameStartTime is called\r\n    function gameStartTime() external view returns (uint256);\r\n\r\n    /// @notice Game finish time\r\n    /// @dev Updated when #setGameFinishTime is called\r\n    function gameFinishTime() external view returns (uint256);\r\n\r\n    /// @notice Geography\r\n    /// @dev Immutable, initialized on creation\r\n    function geography() external view returns (IGeography);\r\n\r\n    /// @notice Current world epoch\r\n    /// @dev Updated when #destroy is called\r\n    function currentEpochNumber() external view returns (uint256);\r\n\r\n    /// @notice World epochs\r\n    /// @dev Updated when world initialized or #destroy is called\r\n    function epochs(uint256 epochNumber) external view returns (IEpoch);\r\n\r\n    /// @notice Mapping containing world asset type by provided epoch number and address\r\n    /// @dev Updated when #addWorldAsset is called\r\n    function worldAssets(uint256 epochNumber, address worldAsset) external view returns (bytes32);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param registryContractAddress Registry contract address\r\n    /// @param crossEpochsMemoryAddress Cross epochs memory address\r\n    /// @param geographyAddress Geography contract address\r\n    /// @param bannersAddress Banners token address\r\n    /// @param blessTokenAddress Bless token address\r\n    /// @param distributionsAddress Distributions token address\r\n    /// @param rewardPoolAddress Reward pool address\r\n    function init(\r\n        address registryContractAddress,\r\n        address crossEpochsMemoryAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address blessTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    ) external;\r\n\r\n    /// @notice Adds an address as world asset\r\n    /// @dev Even though function is opened, it can only be called by factory contract\r\n    /// @param epochNumber Epoch number\r\n    /// @param worldAssetAddress World asset address\r\n    /// @param assetType Asset type\r\n    function addWorldAsset(\r\n        uint256 epochNumber,\r\n        address worldAssetAddress,\r\n        bytes32 assetType\r\n    ) external;\r\n\r\n    /// @notice Mints workers to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param to Address which will receive workers\r\n    /// @param value Amount of workers to mint\r\n    function mintWorkers(\r\n        uint256 epochNumber,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints units to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param unitName Type of unit to mint\r\n    /// @param to Address which will receive units\r\n    /// @param value Amount of units to mint\r\n    function mintUnits(\r\n        uint256 epochNumber,\r\n        string memory unitName,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints resource to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param epochNumber Epoch number\r\n    /// @param resourceName Resource name\r\n    /// @param to Address which will receive resources\r\n    /// @param value Amount of resources to mint\r\n    function mintResources(\r\n        uint256 epochNumber,\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Transfers multiple resources to provided address\r\n    /// @dev Uses msg.sender as resources sender\r\n    /// @param epochNumber Epoch number\r\n    /// @param to An address which will receive resources\r\n    /// @param resourcesNames Resources names\r\n    /// @param amounts Amount of each resources to transfer\r\n    function batchTransferResources(\r\n        uint256 epochNumber,\r\n        address to,\r\n        string[] calldata resourcesNames,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n//    /// @notice Transfers multiple buildings tokens to provided addresses\r\n//    /// @dev Uses msg.sender to verify is buildings tokens address transfer allowed from specified senders (for ex. settlement owner can recall its buildings tokens in certain conditions)\r\n//    /// @param buildingAddresses Addresses of buildings\r\n//    /// @param senders Addresses from which buildings tokens will be transferred\r\n//    /// @param recipients Addresses which will receive buildings tokens\r\n//    /// @param amounts Amount of each building token to transfer\r\n//    function batchTransferBuildingTokens(\r\n//        address[] calldata buildingAddresses,\r\n//        address[] calldata senders,\r\n//        address[] calldata recipients,\r\n//        uint256[] calldata amounts\r\n//    ) external;\r\n\r\n    /// @notice Sets game finish time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator or reward pool\r\n    /// @param gameFinishTime Game finish time\r\n    function setGameFinishTime(uint256 gameFinishTime) external;\r\n\r\n    /// @notice Sets game start time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param gameStartTime Game start time\r\n    function setGameStartTime(uint256 gameStartTime) external;\r\n\r\n    /// @notice Destroys current epoch if conditions are met\r\n    /// @dev Anyone can call this function\r\n    function destroyCurrentEpoch() external;\r\n}\r\n"
    },
    "contracts/core/assets/settlement/ISettlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../building/IBuilding.sol\";\r\nimport \"../army/IArmy.sol\";\r\nimport \"../siege/ISiege.sol\";\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Settlement interface\r\n/// @notice Functions to read state/modify state in order to get current settlement parameters and/or interact with it\r\ninterface ISettlement {\r\n    /// @notice Emitted when new building is placed, all building are placed on settlement creation\r\n    /// @param contractAddress New building address\r\n    /// @param scriptName Building name\r\n    event NewBuilding(address contractAddress, string scriptName);\r\n\r\n    /// @notice Emitted when settlements army is created, is it created on settlement creation\r\n    /// @param armyAddress New army address\r\n    /// @param position Position\r\n    event NewArmy(address armyAddress, uint32 position);\r\n\r\n    /// @notice Emitted when siege is created on settlement if not present. During settlements lifetime multiple sieges can be created (one after another, not multiple simultaneously)\r\n    /// @param siegeAddress New siege address\r\n    event SiegeCreated(address indexed siegeAddress);\r\n\r\n    /// @notice Emitted when #addGovernor or #removeGovernor is called\r\n    /// @param currentEpoch Current governor epoch\r\n    /// @param governorAddress Address of the governor event is applicable\r\n    /// @param status Is governor became active/inactive\r\n    event GovernorChanged(uint256 indexed currentEpoch, address indexed governorAddress, bool status);\r\n\r\n    /// @notice Emitted when #removeGovernors is called\r\n    /// @param currentEpoch New governor epoch\r\n    event NewSettlementEpoch(uint256 currentEpoch);\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Banner token id to which current settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function ownerTokenId() external view returns (uint256);\r\n\r\n    /// @notice Siege of the settlement\r\n    /// @dev If any army is sieging settlement not address(0), otherwise address(0)\r\n    function siege() external view returns (ISiege);\r\n\r\n    /// @notice Mapping containing settlements buildings\r\n    /// @dev Types of buildings supported can be queried from registry\r\n    function buildings(string memory buildingName) external view returns (IBuilding);\r\n\r\n    /// @notice Current governors epoch\r\n    /// @dev Modified when #removeGovernors is called\r\n    function currentGovernorsEpoch() external view returns (uint256);\r\n\r\n    /// @notice Current settlements governors\r\n    /// @dev Modified when #addGovernor or #removeGovernor is called\r\n    function governors(uint256 epoch, address isGovernor) external view returns (bool);\r\n\r\n    /// @notice Settlements army\r\n    /// Immutable, initialized on the settlement creation\r\n    function army() external view returns (IArmy);\r\n\r\n    /// @notice Extra prosperity amount gained from demilitarization of any army on this settlement\r\n    /// @dev Used for determination amount of real prosperity this settlement has\r\n    function extraProsperity() external view returns (uint256);\r\n\r\n    /// @notice Position on which settlement is created\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function position() external view returns (uint32);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param createdWithOwnerTokenId Banner token id to which current settlement belongs\r\n    /// @param zoneAddress Zone address to which this settlement belongs\r\n    /// @param settlementPosition Position on which settlement is created\r\n    function init(\r\n        uint256 createdWithOwnerTokenId,\r\n        address zoneAddress,\r\n        uint32 settlementPosition\r\n    ) external;\r\n\r\n    /// @notice Transfers workers from settlement to building\r\n    /// @dev Amount of workers to transfer is in 1e18 precision, however only integer amount can be transferred\r\n    /// @param buildingAddress Address of the building transfer workers to\r\n    /// @param amount Amount of workers to transfer\r\n    function transferWorkers(address buildingAddress, uint256 amount) external;\r\n\r\n    /// @notice Transfers game resource from settlement to specified address\r\n    /// @dev In case if someone accidentally transfers game resource to the settlement\r\n    /// @param resourceName Game resource name\r\n    /// @param to Address that will receive resources\r\n    /// @param amount Amount to transfer\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Creates new building\r\n    /// @dev All buildings are created on settlement creation\r\n    /// @param buildingName Building name\r\n    /// @return buildingAddress Address of created building\r\n    function newBuilding(string memory buildingName) external returns (address buildingAddress);\r\n\r\n    /// @notice Calculates current fort health and damage dealt at specified timestamp\r\n    /// @dev Uses fort production and siege parameters to forecast health and damage will be dealt at specified time\r\n    /// @param timestamp Time at which calculate parameters\r\n    /// @return currentHealth Health value at specified time\r\n    /// @return damage Amount of damage dealt from fort.production.lastUpdateState to specified timestamp\r\n    function calculateCurrentHealthAndDamage(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (uint256 currentHealth, uint256 damage);\r\n\r\n    /// @notice Updates settlement health to current block\r\n    /// @dev Can be called by everyone\r\n    function updateCurrentHealth() external;\r\n\r\n    /// @notice Creates empty siege\r\n    /// @dev Can be called by everyone\r\n    function createSiege() external;\r\n\r\n    /// @notice Updates fort health\r\n    /// @dev Even though function is opened it can be called only by world or world asset\r\n    /// @param healthDiff Health delta between current value and new value\r\n    /// @param isProduced Banner, whether health is produced or removed\r\n    function updateFortHealth(uint256 healthDiff, bool isProduced) external;\r\n\r\n    /// @notice Harvests all buildings\r\n    /// @dev Can be used by everyone\r\n    function massUpdate() external;\r\n\r\n    /// @notice Calculates current prosperity at specified timestamp\r\n    /// @dev Uses buildings productions to forecast amount of prosperity will settlement will have at specified time\r\n    /// @param timestamp Time at which calculate current prosperity\r\n    /// @return currentProsperity Amount of prosperity at specified time\r\n    function accumulatedCurrentProsperity(uint256 timestamp) external view returns (int256 currentProsperity);\r\n\r\n    /// @notice Calculates total siege power presented at current time\r\n    /// @dev Updated when army add/remove units from siege\r\n    /// @return currentSiegePower Amount of total siege power at current time\r\n    function getCurrentSiegePower() external view returns (uint256 currentSiegePower);\r\n\r\n    /// @notice Calculates current settlement owner\r\n    /// @dev Settlements owner is considered an address, which holds ownerTokenId NFT\r\n    /// @return settlementOwner Settlement owner\r\n    function getSettlementOwner() external view returns (address settlementOwner);\r\n\r\n    /// @notice Calculates whether provided address is settlement ruler or not\r\n    /// @dev Settlements ruler is an address which owns settlement or an address(es) by which settlement is/are governed\r\n    /// @param potentialRuler Address to check\r\n    /// @return isRuler Banner, whether specified address is ruler or not\r\n    function isRuler(address potentialRuler) external view returns (bool isRuler);\r\n\r\n    /// @notice Extends current settlement prosperity by specified amount\r\n    /// @dev Even though function is opened it can be called only by world or world asset\r\n    /// @param prosperityAmount Amount of prosperity to which extend current prosperity\r\n    function extendProsperity(uint256 prosperityAmount) external;\r\n}\r\n"
    },
    "contracts/core/assets/siege/ISiege.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Siege interface\r\n/// @notice Functions to read state/modify state in order to get current siege parameters and/or interact with it\r\ninterface ISiege {\r\n    struct ArmyInfo {\r\n        uint256 rewardDebt;\r\n        uint256 points;\r\n    }\r\n\r\n    /// @notice Emitted when #addUnits is called\r\n    /// @param from Army address which adds units\r\n    /// @param settlement Settlement address of related siege\r\n    /// @param unitsNames Unit types which were added\r\n    /// @param unitsCount Counts of units which were added\r\n    event UnitsAdded(address indexed from, address indexed settlement, string[] unitsNames, uint256[] unitsCount);\r\n\r\n    /// @notice Emitted when #withdrawUnits is called\r\n    /// @param to Army address which receives back its units\r\n    /// @param settlement Settlement address of related siege\r\n    /// @param unitsNames Unit types which were withdrawn\r\n    /// @param unitsCount Counts of units which were withdrawn\r\n    event UnitsWithdrawn(address indexed to, address indexed settlement, string[] unitsNames, uint256[] unitsCount);\r\n\r\n    /// @notice Emitted when #addUnits or #withdrawUnits is called in order to preserve previous amount of points were farmed by the army with previous speed\r\n    /// @param armyAddress Army address which received siege points\r\n    /// @param pointsReceived Amount of points received\r\n    event PointsReceived(address indexed armyAddress, uint256 pointsReceived);\r\n\r\n    /// @notice Emitted when #claimResources is called\r\n    /// @param armyAddress Army address which spent siege points\r\n    /// @param pointsSpent Amount of points spent\r\n    event PointsSpent(address indexed armyAddress, uint256 pointsSpent);\r\n\r\n    /// @notice Emitted when #liquidate is called, emitted for every unit type that was liquidated\r\n    /// @param armyAddress Army address which was liquidated\r\n    /// @param unitName Unit type\r\n    /// @param unitsLiquidated Amount of units liquidated\r\n    event Liquidated(address armyAddress, string unitName, uint256 unitsLiquidated);\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this siege belongs\r\n    /// @dev Immutable, initialized on the siege creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing army information related to current siege\r\n    /// @dev Updated when #addUnits, #withdrawUnits, #claimResource, #liqudate is called\r\n    function armyInfo(address armyAddress) external view returns (uint256 rewardDebt, uint256 points);\r\n\r\n    /// @notice Mapping containing amount of stored units in siege for specified army\r\n    /// @dev Updated when #addUnits, #withdrawUnits, #liqudate is called\r\n    function storedUnits(address armyAddress, string memory unitName) external view returns (uint256);\r\n\r\n    /// @notice Last time at which siege was updated\r\n    /// @dev Updated when siege parameters related to pointsPerShare were changed\r\n    function lastUpdate() external view returns (uint256);\r\n\r\n    /// @notice Amount of point per share\r\n    /// @dev Updated when siege parameters related to armies were changed\r\n    function pointsPerShare() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Updates current siege to the current state\r\n    /// @dev Synchronizes health up to current state, produces points for besieging armies\r\n    function update() external;\r\n\r\n    /// @notice Claims resources for specified points from building related to siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param buildingAddress Address of building to rob\r\n    /// @param points Amount of points to spend for robbing\r\n    function claimResources(address buildingAddress, uint256 points) external;\r\n\r\n    /// @notice Calculates total damage for provided period of time\r\n    /// @param period Time period to use to calculate damage\r\n    /// @return damage Total damage for provided period of time\r\n    function getTotalDamageByPeriod(uint256 period) external view returns (uint256 damage);\r\n\r\n    /// @notice Calculates total damage for period from lastUpdate and block.timestamp\r\n    /// @return damage Total damage for last period\r\n    function getTotalDamageLastPeriod() external view returns (uint256 damage);\r\n\r\n    /// @notice Updates siege with new amount of damage fort taken\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    function systemUpdate(uint256 totalDamage) external;\r\n\r\n    /// @notice Adds units to siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param unitsNames Unit types which will be added to siege\r\n    /// @param unitsCount Amounts of units will be added to siege\r\n    function addUnits(string[] memory unitsNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Withdraws units from siege\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param unitsNames Unit types which will be withdrawn to siege\r\n    /// @param unitsCount Amounts of units will be withdrawn to siege\r\n    function withdrawUnits(string[] memory unitsNames, uint256[] memory unitsCount) external;\r\n\r\n    /// @notice Calculates if provided army address can be liquidated from current siege\r\n    /// @dev Does not take into an account if army's battle is finished and army isn't left the battle\r\n    /// @param armyAddress Address of the army\r\n    /// @return canLiquidate Can army be liquidated from current siege\r\n    function canLiquidate(address armyAddress) external view returns (bool canLiquidate);\r\n\r\n    /// @notice Calculates amount of points army will have at specified time\r\n    /// @dev If timestamp=0, returns value as if timestamp=block.timestamp\r\n    /// @param armyAddress Address of the army\r\n    /// @param timestamp Time at which calculate points\r\n    /// @return points Amount of points army will have at specified time\r\n    function getUserPointsOnTime(address armyAddress, uint256 timestamp) external view returns (uint256 points);\r\n\r\n    /// @notice Returns amount of stored units for specified army in siege\r\n    /// @dev Function returns only amounts without types, index in returned array for each unit type is same as in 'registry.getUnits'\r\n    /// @param armyAddress Address of the army\r\n    /// @return units Amount of units that army has in siege\r\n    function getStoredUnits(address armyAddress) external view returns (uint256[] memory units);\r\n\r\n    /// @notice Calculates total siege stats\r\n    /// @dev Values are calculated for all armies that are present in siege\r\n    /// @return power Total power that placed into siege\r\n    /// @return supply Total supply that siege has\r\n    function calculateTotalSiegeStats() external view returns (uint256 power, uint256 supply);\r\n\r\n    /// @notice Liquidates army\r\n    /// @dev Can be called by anyone, caller will receive a reward\r\n    /// @param armyAddress Address of army to liquidate\r\n    function liquidate(address armyAddress) external;\r\n\r\n    /// @notice Calculates amount of points army has\r\n    /// @dev Uses block.timestamp at #getUserPointsOnTime\r\n    /// @param armyAddress Address of army\r\n    /// @return points Amount of points army has\r\n    function getUserPoints(address armyAddress) external returns (uint256 points);\r\n\r\n    /// @notice Calculates army siege stats\r\n    /// @dev Values are calculated for specified army that is present in siege\r\n    /// @param armyAddress Address of army\r\n    /// @return power Total power that army has\r\n    /// @return supply Total supply that army has\r\n    function calculateArmySiegeStats(address armyAddress) external returns (uint256 power, uint256 supply);\r\n}\r\n"
    },
    "contracts/core/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Registry interface\r\n/// @notice Functions related to current game configuration\r\ninterface IRegistry {\r\n    struct GameResource {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        string worldResourceName;\r\n    }\r\n\r\n    struct GameUnit {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        string worldUnitName;\r\n    }\r\n\r\n    struct ExtraResource {\r\n        string resourceName;\r\n        uint256 value;\r\n    }\r\n\r\n    struct UnitStats {\r\n        uint256 weaponPowerStage1;\r\n        uint256 armourPowerStage1;\r\n        uint256 weaponPowerStage2;\r\n        uint256 armourPowerStage2;\r\n        uint256 siegePower;\r\n        uint256 siegeMaxSupply;\r\n        uint256 siegeSupport;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice An address which can configure/reconfigure current game\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function mightyCreator() external view returns (address);\r\n\r\n    /// @notice Mapping containing is provided address a factory contract or not\r\n    /// @dev Updated when #setFactoryContract is called\r\n    function isFactoryContract(address factoryAddress) external view returns (bool);\r\n\r\n    /// @notice Mapping containing factory contracts addresses by provided asset types\r\n    /// @dev Updated when #setFactoryContract is called\r\n    /// @dev During new world asset creation process registry is asked for factory contract for exact world asset type, which will contain creation method for new world asset\r\n    function factoryContracts(bytes32 scriptId) external view returns (address);\r\n\r\n    /// @notice Mapping containing assets implementations addresses by provided asset types\r\n    /// @dev Updated when #setScriptContractName is called\r\n    /// @dev Every worlds assets implementation (code, not data) will be defined by value from this mapping\r\n    function scriptContracts(bytes32 scriptId) external view returns (address);\r\n\r\n    /// @notice Mapping containing units stats by provided unit types\r\n    /// @dev Updated when #setUnitStats is called\r\n    function unitsStats(string memory unitName)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 weaponPowerStage1,\r\n            uint256 armourPowerStage1,\r\n            uint256 weaponPowerStage2,\r\n            uint256 armourPowerStage2,\r\n            uint256 siegePower,\r\n            uint256 siegeMaxSupply,\r\n            uint256 siegeSupport\r\n        );\r\n\r\n    /// @notice Global multiplier\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function globalMultiplier() external view returns (uint256);\r\n\r\n    /// @notice Settlement starting price\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function settlementStartingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param globalMultiplier Global multiplier\r\n    /// @param settlementStartingPrice Settlement starting price\r\n    function init(\r\n        uint256 globalMultiplier,\r\n        uint256 settlementStartingPrice\r\n    ) external;\r\n\r\n    /// @notice Sets provided address as factory contract for provided asset type\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param assetType Type of the asset\r\n    /// @param factoryAddress Factory address\r\n    function setFactoryContract(bytes32 assetType, address factoryAddress) external;\r\n\r\n    /// @notice Sets provided address as implementation for provided asset group and asset type (for ex. group - \"settlement\", type - \"CULTISTS\")\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param assetGroup Asset group\r\n    /// @param assetType Type of the asset\r\n    /// @param implementationAddress Implementation address\r\n    function setScriptContractName(\r\n        string memory assetGroup,\r\n        string memory assetType,\r\n        address implementationAddress\r\n    ) external;\r\n\r\n    /// @notice Sets units stats for provided unit type\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param unitName Unit type\r\n    /// @param unitStats Unit stats struct\r\n    function setUnitStats(string calldata unitName, UnitStats memory unitStats) external;\r\n\r\n    /// @notice Calculates worker capacity coefficient for provided building type\r\n    /// @dev Used for internal calculation of max workers for each building\r\n    /// @param buildingName Building type\r\n    /// @return workerCapacityCoefficient Worker capacity coefficient\r\n    function getWorkerCapacityCoefficient(string memory buildingName) external pure returns (uint256 workerCapacityCoefficient);\r\n\r\n    /// @notice Calculates basic production building coefficient\r\n    /// @dev used for internal calculation of production result\r\n    /// @param buildingName Building type\r\n    /// @return basicProductionBuildingCoefficient Basic production building coefficient\r\n    function getBasicProductionBuildingCoefficient(string memory buildingName) external pure returns (uint256 basicProductionBuildingCoefficient);\r\n\r\n    /// @notice Calculates if provided building has starting treasury on creation\r\n    /// @dev Used for determination if treasury should be filled on settlement creation\r\n    /// @param buildingName Building type\r\n    /// @return hasStartingTreasury If treasury should be filled\r\n    function hasStartingTreasury(string memory buildingName) external pure returns (bool hasStartingTreasury);\r\n\r\n    /// @notice Calculates toxicity by resource ratio\r\n    /// @dev Used for minting/burning toxicity\r\n    /// @param resourceName Resource name\r\n    /// @return toxicity Amount of toxicity per 1 resource (both are in 1e18 precision)\r\n    function getToxicityByResource(string memory resourceName) external pure returns (uint256 toxicity);\r\n\r\n    /// @notice Calculates resource weight\r\n    /// @dev Used for calculation how much prosperity will be produced by resource in treasury\r\n    /// @param resourceName Resource name\r\n    /// @return resourceWeight Resource weight (in 1e0 precision)\r\n    function getResourceWeight(string memory resourceName) external pure returns (uint256 resourceWeight);\r\n\r\n    /// @notice Returns siege power to siege siege points multiplier\r\n    /// @dev Used for determination how much siege points will be given\r\n    /// @return siegePowerToSiegePointsMultiplier Siege power to siege siege points multiplier (in 1e18 precision)\r\n    function getSiegePowerToSiegePointsMultiplier() external pure returns (uint256 siegePowerToSiegePointsMultiplier);\r\n\r\n    /// @notice Returns siege point multiplier by provided resource\r\n    /// @dev Used in calculation how many resources can be exchanged for siege points\r\n    /// @param resourceName Resource name\r\n    /// @return siegePointsToResourceMultiplier Siege point multiplier (in 1e18 precision)\r\n    function getSiegePointsToResourceMultiplier(string memory resourceName) external view returns (uint256 siegePointsToResourceMultiplier);\r\n\r\n    /// @notice Returns robbery fee\r\n    /// @dev Used in determination how much of resource will be burned during robbery\r\n    /// @return robberyFee Robbery fee (in 1e18 precision, where 1e18 is 100%)\r\n    function getRobberyFee() external view returns (uint256 robberyFee);\r\n\r\n    /// @notice Returns global multiplier\r\n    /// @dev Used everywhere, where time is involved. Essentially determines game speed\r\n    /// @return globalMultiplier Global multiplier\r\n    function getGlobalMultiplier() external view returns (uint256 globalMultiplier);\r\n\r\n    /// @notice Returns production to treasury percent\r\n    /// @dev Determines how much of buildings production will go to treasury (if not full)\r\n    /// @param toTreasuryPercent Production to treasury percent (in 1e18 precision, where 1e18 is 100%)\r\n    function getToTreasuryPercent() external pure returns (uint256 toTreasuryPercent);\r\n\r\n    /// @notice Returns base battle duration\r\n    /// @dev Used internally to determine how long battle will last\r\n    /// @return baseBattleDuration Base battle duration\r\n    function getBaseBattleDuration() external view returns (uint256 baseBattleDuration);\r\n\r\n    /// @notice Returns battle lobby phase duration percent (in 1e18 precision)\r\n    /// @dev Used internally to determine how long lobby phase will last\r\n    /// @return battleLobbyDurationPercent Battle lobby phase duration percent\r\n    function getBattleLobbyDurationPercent() external view returns (uint256 battleLobbyDurationPercent);\r\n\r\n    /// @notice Returns battle duration stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after army lost battle\r\n    /// @return battleDurationStunMultiplier Battle duration stun multiplier\r\n    function getBattleDurationStunMultiplier() external pure returns (uint256 battleDurationStunMultiplier);\r\n\r\n    /// @notice Returns movement duration stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after armies' movement\r\n    /// @return movementDurationStunMultiplier Movement duration stun multiplier\r\n    function getMovementDurationStunMultiplier() external pure returns (uint256 movementDurationStunMultiplier);\r\n\r\n    /// @notice Returns game buildings\r\n    /// @dev Used internally to determine which buildings will be created on placing settlement\r\n    /// @return buildings Buildings\r\n    function getBuildings() external view returns (string[] memory buildings);\r\n\r\n    /// @notice Returns game resources\r\n    /// @dev Used internally to determine upgrade costs and providing initial resources for settlement owner based on his tier\r\n    /// @param resources Game resources\r\n    function getResources() external view returns (string[] memory resources);\r\n\r\n    /// @notice Returns game units\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return units Game units\r\n    function getUnits() external view returns (string[] memory units);\r\n\r\n    /// @notice Returns game resources\r\n    /// @dev Used internally to determine upgrade costs and providing initial resources for settlement owner based on his tier\r\n    /// @param resources Game resources\r\n    function getGameResources() external view returns (GameResource[] memory resources);\r\n\r\n    /// @notice Returns game units\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return units Game units\r\n    function getGameUnits() external view returns (GameUnit[] memory units);\r\n\r\n    /// @notice Returns unit hiring fort hp multiplier\r\n    /// @dev Used to determine how much units in army can be presented based on its current fort hp and this parameter\r\n    /// @return unitHiringFortHpMultiplier Unit hiring fort hp multiplier\r\n    function getUnitHiringFortHpMultiplier() external pure returns (uint256 unitHiringFortHpMultiplier);\r\n\r\n    /// @notice Returns how much food unit can take from treasury to increase its army movement speed\r\n    /// @dev Used internally to calculate army's movement speed\r\n    /// @param unitType Unit type\r\n    /// @return unitMaxFoodToSpendOnMove Maximum amount of food to spend on move (in 1e18 precision)\r\n    function getUnitMaxFoodToSpendOnMove(string memory unitType) external pure returns (uint256 unitMaxFoodToSpendOnMove);\r\n\r\n    /// @notice Returns how much prosperity will be given for provided unit type\r\n    /// @dev Used internally to calculate how much prosperity will be given\r\n    /// @return prosperityPerUnit Prosperity amount per one unit (in 1e18 precision)\r\n    function getProsperityForDemilitarization(string memory unitType) external pure returns (uint256 prosperityPerUnit);\r\n\r\n    /// @notice Returns cultists summon delay\r\n    /// @dev Used to determine is cultists can be re-summoned\r\n    /// @return cultistsSummonDelay Cultists summon delay (in seconds)\r\n    function getCultistsSummonDelay() external pure returns (uint256 cultistsSummonDelay);\r\n\r\n    /// @notice Returns max settlement that can be placed in one zone\r\n    /// @dev Cultists does not count (so +1 with cultists)\r\n    /// @return maxSettlementPerZone Max settlement that can be placed in one zone\r\n    function getMaxSettlementPerZone() external pure returns (uint256 maxSettlementPerZone);\r\n\r\n    /// @notice Returns interval duration where world is not destructible after recent cultists summon\r\n    /// @dev Used to determine if destruction is available or not\r\n    /// @return cultistsNoDestructionDelay No destruction interval duration (in seconds)\r\n    function getCultistsNoDestructionDelay() external pure returns (uint256 cultistsNoDestructionDelay);\r\n\r\n    /// @notice Returns value of cultists per zone which determines cultists threshold for world destruction\r\n    /// @dev Used to determine amount of cultists that have to be present for world destruction\r\n    /// @return cultistsPerZoneMultiplier Value of cultists per zone\r\n    function getCultistsPerZoneMultiplier() external pure returns (uint256 cultistsPerZoneMultiplier);\r\n\r\n    /// @notice Returns maximum amount of cultists that can be present in zone\r\n    /// @dev Used to determine how many cultists will be summoned\r\n    /// @return maxCultistsPerZone Maximum amount of cultists\r\n    function getMaxCultistsPerZone() external pure returns (uint256 maxCultistsPerZone);\r\n\r\n    /// @notice Returns unit type of cultists army\r\n    /// @dev Determines type of unit in cultists army\r\n    /// @return cultistUnitType Cultists unit type\r\n    function getCultistUnitType() external pure returns (string memory cultistUnitType);\r\n\r\n    /// @notice Returns building token transfer threshold percent\r\n    /// @dev Used to determine is building token transfer allowed based on treasury percent\r\n    /// @return buildingTokenTransferThresholdPercent Building token transfer threshold percent\r\n    function getBuildingTokenTransferThresholdPercent() external pure returns (uint256 buildingTokenTransferThresholdPercent);\r\n\r\n    /// @notice Returns extra resources which will be minted to user when new settlement is placed\r\n    /// @dev During settlement creation continent contract uses output from this function to determine how much extra resources to mint\r\n    /// @return extraResources Extra resources which will be minted to user when new settlement is placed\r\n    function getNewSettlementExtraResources() external view returns (ExtraResource[] memory extraResources);\r\n\r\n    /// @notice Returns new settlement starting price in settlements market\r\n    /// @dev Used to determine how much base price for first settlement will be\r\n    /// @return newSettlementStartingPrice New settlement starting price\r\n    function getNewSettlementStartingPrice() external view returns (uint256 newSettlementStartingPrice);\r\n\r\n    /// @notice Returns amount of production ticks\r\n    /// @dev Used for production calculation\r\n    /// @return ticks Amount of production ticks\r\n    function getProductionTicksInSecond() external view returns (uint256 ticks);\r\n\r\n    /// @notice Returns army demilitarization cooldown in seconds\r\n    /// @dev Used for army demilitarization restriction\r\n    /// @return cooldown Demilitarization cooldown in seconds\r\n    function getDemilitarizationCooldown() external pure returns (uint256 cooldown);\r\n\r\n    /// @notice Returns unit pool price drop per second for provided unit type, provided as numerator and denominator\r\n    /// @dev Used for determination of current unit pool price\r\n    /// @param unitType Unit type\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getUnitPriceDropByUnitType(string memory unitType) external pure returns (uint256 numerator, uint256 denominator);\r\n}\r\n"
    },
    "contracts/core/tokens/resources/IResource.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current resource parameters and/or interact with it\r\ninterface IResource is IERC20Burnable, IERC20 {\r\n    /// @notice Returns state balance for specified token owner\r\n    /// @dev Current function returns value of balances 'as is', without recalculation (same as 'balanceOf' you would expect)\r\n    /// @param tokensOwner Tokens owner\r\n    /// @return balance Balance for token owner\r\n    function stateBalanceOf(address tokensOwner) external view returns (uint256 balance);\r\n\r\n    /// @notice Mints resource to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive resources\r\n    /// @param amount Amount of resources to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/tokens/prosperity/IProsperity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../../token/IERC20Burnable.sol\";\r\nimport \"../../../token/IERC20Int.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current prosperity parameters and/or interact with it\r\ninterface IProsperity is IERC20Int, IERC20Burnable {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing amount of prosperity spend for workers buying\r\n    /// @dev Only settlements can spend prosperity for workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @return amount Amount of prosperity spend for workers buying\r\n    function prosperitySpent(address settlementAddress) external view returns (uint256 amount);\r\n\r\n    // Functions\r\n\r\n    /// @notice Spends prosperity for specified settlement address\r\n    /// @dev Called for settlement when settlement is buying workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @param amount Amount of prosperity spend for workers buying\r\n    function spend(address settlementAddress, uint256 amount) external;\r\n\r\n    /// @notice Mints prosperity to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive prosperity\r\n    /// @param amount Amount of prosperity to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/tokens/units/IUnits.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Units interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IUnits is IERC20Burnable, IERC20 {\r\n    // State variables\r\n\r\n    /// @notice Epoch number\r\n    /// @dev Immutable, initialized on creation\r\n    function epochNumber() external returns (uint256);\r\n\r\n    /// @notice Name of the unit inside epoch.units\r\n    /// @dev Immutable, initialized on creation\r\n    function worldUnitName() external returns (string memory);\r\n\r\n    // Functions\r\n\r\n    /// @notice Mints units to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive units\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/tokens/workers/IWorkers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Workers interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IWorkers is IERC20Burnable, IERC20 {\r\n    /// @notice Mints workers to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive workers\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/geography/IGeography.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\ninterface IGeography {\r\n    enum TileType {\r\n        VOID, //0\r\n        SAND, //1\r\n        ROAD, //2\r\n        GRASS, //3\r\n        SWAMP, //4\r\n        WATER //5\r\n    }\r\n\r\n    struct GameTile {\r\n        uint16 zoneId;\r\n        uint16 tileType;\r\n    }\r\n\r\n    struct ZoneActivationParams {\r\n        uint32 cultistsPosition;\r\n    }\r\n\r\n    /// @notice Emitted when #_createZone is called\r\n    /// @param zoneIndex Zone index\r\n    /// @param positions Positions\r\n    /// @param tileTypes Tile types\r\n    /// @param cultistsPosition Cultists position\r\n    event NewZoneCreated(\r\n        uint256 zoneIndex,\r\n        uint32[] positions,\r\n        uint16[] tileTypes,\r\n        uint256 cultistsPosition\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Mapping containing packed tiles by specified slot number\r\n    /// @dev Each returned element is is packed GameTile structures (8 per slot). Updated when zone is created\r\n    function packedGameTileMap(uint32 slotNumber) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Returns created zones length\r\n    /// @dev Updated when #createZone is called\r\n    /// @return zonesLength Zones length\r\n    function getZonesLength() external view returns (uint256 zonesLength);\r\n\r\n    /// @notice Validates provided path\r\n    /// @dev Useful for determining positions path according to current hex grid\r\n    /// @param path Path\r\n    /// @return isValid Is path valid\r\n    function isPathValid(uint32[] memory path) external view returns (bool isValid);\r\n\r\n    /// @notice Calculates if provided position are neighbor to other position\r\n    /// @param position Provided position\r\n    /// @param neighbor Other position\r\n    /// @param isNeighbor Is other position neighbor to provided position\r\n    function isNeighborTo(uint32 position, uint32 neighbor) external pure returns (bool isNeighbor);\r\n\r\n    /// @notice Calculates gameTile structure from provided position\r\n    /// @param position Provided position\r\n    /// @return gameTile Game tile struct\r\n    function getGameTile(uint32 position) external view returns (GameTile memory gameTile);\r\n\r\n    /// @notice Calculates all ring positions by provided position and radius\r\n    /// @param position Position\r\n    /// @param radius Ring radius\r\n    /// @return ringPositions Ring positions\r\n    /// @return ringPositionsLength Ring positions length (array is initialized 6 * radius, however not all values should be used)\r\n    function getRingPositions(uint32 position, uint256 radius) external pure returns (uint32[] memory ringPositions, uint256 ringPositionsLength);\r\n\r\n    /// @notice Creates zone with provided positions and tile types\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param positions Zone positions\r\n    /// @param tileTypes Zone tile types\r\n    /// @param cultistsCoordinateIndex Coordinate index inside 'positions', where cultists will be placed\r\n    function createZone(\r\n        uint32[] memory positions,\r\n        uint16[] memory tileTypes,\r\n        uint256 cultistsCoordinateIndex\r\n    ) external;\r\n\r\n    /// @notice Returns zone activation params for provided zone index\r\n    /// @dev New values are accessible when #createZone is called\r\n    /// @param zoneIndex Zone index\r\n    /// @return params Zone activation params struct\r\n    function getZoneActivationParams(uint256 zoneIndex) external view returns (ZoneActivationParams memory params);\r\n}\r\n"
    },
    "contracts/core/crossEpochsMemory/ICrossEpochsMemory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\n/// @title Cross epoch memory interface\r\n/// @notice Functions to read state/modify state in order to get cross epoch memory parameters and/or interact with it\r\ninterface ICrossEpochsMemory {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing settlement by provided x and y coordinates\r\n    /// @dev Updated when #handleNewSettlement is called\r\n    function settlements(uint32 position) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #handleNewUserSettlement or #handleSettlementRestored is called\r\n    function userSettlements(uint256 val) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing count of user settlement by provided zone index\r\n    /// @dev Updated when #handleNewUserSettlement is called\r\n    function zoneUserSettlementsCount(uint256 zoneIndex) external view returns (uint256);\r\n\r\n    /// @notice Mapping containing settlement starting price by provided zone index\r\n    /// @dev Updated when #handleNewUserSettlement is called\r\n    function zoneSettlementStartingPrice(uint256 zoneIndex) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Settlement restoration handler\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param position Position at which restoration occurred\r\n    /// @param settlementAddress New settlement address\r\n    function handleUserSettlementRestored(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) external;\r\n\r\n    /// @notice New user settlement handler\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param ownerTokenId Banners token id which will represent to which settlement will be attached to\r\n    /// @param zoneIndex Zone index\r\n    /// @param settlementAddress New settlement address\r\n    function handleNewUserSettlement(\r\n        uint256 ownerTokenId,\r\n        uint256 zoneIndex,\r\n        address settlementAddress,\r\n        uint256 newSettlementStartingPrice\r\n    ) external;\r\n\r\n    /// @notice New user settlement handler (including system ones, like CULTISTS)\r\n    /// @dev Must be called by active epoch to proper persist cross epoch data\r\n    /// @param position Position\r\n    /// @param settlementAddress New settlement address\r\n    function handleNewSettlement(\r\n        uint32 position,\r\n        address settlementAddress\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/rewardPool/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IRewardPool {\r\n    // State variables\r\n\r\n    /// @notice Represents how much of weapons must be given for one unit of token\r\n    /// @dev Updated when #handleEpochDestroyed is called\r\n    function ratio() external view returns (int256);\r\n\r\n    /// @notice Represents how much bless tokens must be repaid first to the mighty creator\r\n    /// @dev Updated when #investIntoPrizePool is called\r\n    function invested() external view returns (uint256);\r\n\r\n    /// @notice Represents last reward pool total balance after repayment and function(s) are done\r\n    /// @dev Updated when #investIntoPrizePool or #handleEpochDestroyed or #swapWeaponsForTokens or #withdrawRepayment are called\r\n    function lastBalance() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Handler of epoch destruction\r\n    /// @dev Must be called when epoch is destroyed\r\n    function handleEpochDestroyed() external;\r\n\r\n    /// @notice Swap provided amount of weapons\r\n    /// @dev Weapons will be deducted from msg.sender\r\n    /// @param weaponsAmount Amount of weapons to swap\r\n    function swapWeaponsForTokens(uint256 weaponsAmount) external;\r\n\r\n    /// @notice Invests specified amount of tokens into prize pool\r\n    /// @dev Bless tokens must be sent to this function (if its type=eth) or will be deducted from msg.sender (if its type=erc20)\r\n    /// @param amountToInvest Amount of tokens to invest\r\n    function investIntoPrizePool(uint256 amountToInvest) external payable;\r\n\r\n    /// @notice Withdraws potential bless token added balance to the mighty creator\r\n    /// @dev Triggers withdraw of potential added balance\r\n    function withdrawRepayment() external;\r\n}\r\n"
    },
    "contracts/core/distributions/IDistributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"../IWorld.sol\";\r\n\r\ninterface IDistributions is IERC1155 {\r\n    // State variables\r\n\r\n    /// @notice World\r\n    /// @dev Immutable, initialized on creation\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Mapping containing distribution id to assigned building address\r\n    /// @dev Updated when #mint is called\r\n    function distributionIdToBuildingAddress(uint256 distributionId) external view returns (address);\r\n\r\n    /// @notice Last nft token id\r\n    /// @dev Updated when #mint is called\r\n    function lastDistributionId() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Returns set of receivers as an array\r\n    /// @dev\r\n    /// @param distributionId Distribution id\r\n    /// @return receivers An array of receivers\r\n    function getDistributionReceivers(uint256 distributionId) external view returns (address[] memory receivers);\r\n\r\n    /// @notice Mints new distribution Nft to specified address\r\n    /// @dev Can be called only by world asset from active epoch\r\n    /// @param to An address which will receive new nft\r\n    /// @return newDistributionId Newly minted distribution id\r\n    function mint(address to) external returns (uint256 newDistributionId);\r\n\r\n    /// @notice Returns items per nft\r\n    /// @dev Used to determine percent holdings\r\n    /// @return itemsPerNft Items per nft\r\n    function getItemsPerNft() external pure returns (uint256 itemsPerNft);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/token/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IERC20Burnable {\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/assets/building/IBuilding.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Building interface\r\n/// @notice Functions to read state/modify state in order to get current building parameters and/or interact with it\r\ninterface IBuilding {\r\n    struct BasicProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    struct AdvancedProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    struct Production {\r\n        uint256 lastUpdateStateTime;\r\n        uint256 lastUpdateStateZoneTime;\r\n        uint256 extraTicksAfterFinish;\r\n        uint256 productionFinishZoneTime;\r\n        uint256 readyToBeDistributed;\r\n    }\r\n\r\n    struct ProductionResultItem {\r\n        string resourceName;\r\n        uint256 balanceChanges;\r\n        bool isProducing;\r\n    }\r\n\r\n    struct InitialResourceBlock {\r\n        string resourceName;\r\n        uint256 perTick;\r\n        bool isProducing;\r\n    }\r\n\r\n    /// @notice Emitted when #startBasicUpgrade or #startAdvancedUpgrade is called\r\n    /// @param stateLevel New building level\r\n    event UpgradeFinish(uint256 stateLevel);\r\n\r\n    /// @notice Emitted when #distribute is called. When resources from production are distributed to building token holders. Will be deprecated in favor of ERC20 transfer event.\r\n    /// @param resourceName Name of resource distributed\r\n    /// @param holder Receiver address\r\n    /// @param amount Amount of distributed resources\r\n    event DistributedToShareHolder(string resourceName, address holder, uint256 amount);\r\n\r\n    /// @notice Emitted when #setDefaultDistribution is called\r\n    /// @param distributionId Newly created distribution id\r\n    /// @param previousReceivers Previous distribution receivers\r\n    event NewDistribution(uint256 distributionId, address[] previousReceivers);\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this building belongs\r\n    /// @dev Immutable, initialized on the building creation\r\n    function currentSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Basic production\r\n    /// @dev Contains basic production upgrade data\r\n    /// @return level Basic production level\r\n    /// @return coefficient Basic production coefficient\r\n    function basicProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient\r\n    );\r\n\r\n    /// @notice Advanced production\r\n    /// @dev Contains advanced production upgrade data\r\n    /// @return level Advanced production level\r\n    /// @return coefficient Advanced production coefficient\r\n    function advancedProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient\r\n    );\r\n\r\n    /// @notice Upgrade cooldown finish time\r\n    /// @dev Updated when #startBasicUpgrade or #startAdvancedUpgrade is called\r\n    /// @return upgradeCooldownFinishTime Upgrade cooldown finish time\r\n    function upgradeCooldownFinishTime() external view returns (uint256 upgradeCooldownFinishTime);\r\n\r\n    /// @notice Buildings prosperity\r\n    /// @dev Contains last written prosperity amount in building\r\n    /// @return prosperity Current building prosperity\r\n    function prosperity() external view returns (uint256 prosperity);\r\n\r\n    /// @notice Contains current production state of the building\r\n    /// @dev Contains information related to how production is calculated\r\n    /// @return lastUpdateStateTime Time at which last #updateState is called\r\n    /// @return lastUpdateStateZoneTime Zone time at which last #updateState is called\r\n    /// @return extraTicksAfterFinish Amount of extra resource ticks will be performed after 'productionFinishZoneTime'. Implication of this parameter is special case when there are resources for production however they are produced in less than a second.\r\n    /// @return productionFinishZoneTime Zone time at which production will stop\r\n    /// @return readyToBeDistributed Amount of produced resource ready to be distributed\r\n    function production()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 lastUpdateStateTime,\r\n            uint256 lastUpdateStateZoneTime,\r\n            uint256 extraTicksAfterFinish,\r\n            uint256 productionFinishZoneTime,\r\n            uint256 readyToBeDistributed\r\n        );\r\n\r\n    /// @notice Distribution id\r\n    /// @dev Initialized on creation and updated on #resetDistribution\r\n    function distributionId() external view returns (uint256);\r\n\r\n    /// @notice Produced resource debt\r\n    /// @dev Updated when #distributeToSingleHolder or #distributeToAllShareholders is called\r\n    function producedResourceDebt(address holder) external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param settlementAddress Settlement address\r\n    function init(address settlementAddress) external;\r\n\r\n    /// @notice Resets current building distribution\r\n    /// @dev Creates new distribution Nft and mints it to current settlement owner\r\n    function resetDistribution() external;\r\n\r\n    /// @notice Callback which recalculates production. Called when workers or resources, which related to production of this building, is transferred from/to this building\r\n    /// @dev Even though function is opened, it is auto-called by transfer method. Standalone calls provide 0 impact.\r\n    function productionChanged() external;\r\n\r\n    /// @notice Updates state of this building up to block.timestamp\r\n    /// @dev Updates building production minting treasury and increasing #production.readyToBeDistributed\r\n    function updateState() external;\r\n\r\n    /// @notice Fixes debt from shareholder whenever its share part changes\r\n    /// @dev Even though function is opened, it can be called only by distributions\r\n    /// @param from From address\r\n    /// @param to To address\r\n    /// @param amount Amount\r\n    function fixDebtAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Distributes produced resource to single shareholder\r\n    /// @dev Useful to taking part of the resource from the building for single shareholder (to not pay gas for minting for all shareholders)\r\n    /// @param holder Holder\r\n    function distributeToSingleShareholder(address holder) external;\r\n\r\n    /// @notice Distributes produces resource to all shareholders\r\n    /// @dev Useful to get full produced resources to all shareholders\r\n    function distributeToAllShareholders() external;\r\n\r\n    /// @notice Calculates amount of workers currently sitting in this building\r\n    /// @dev Same as workers.balanceOf(buildingAddress)\r\n    /// @return workersAmount Amount of workers currently sitting in this building\r\n    function getWorkers() external view returns (uint256 workersAmount);\r\n\r\n    /// @notice Calculates real amount of provided resource in building related to its production at provided time\r\n    /// @dev Useful for determination how much of production resource (either producing and spending) at the specific time\r\n    /// @param resourceName Name of resource related to production\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return resourcesAmount Real amount of provided resource in building related to its production at provided time\r\n    function getResourcesAmount(string memory resourceName, uint256 timestamp) external view returns (uint256 resourcesAmount);\r\n\r\n    /// @notice Calculates production resources changes at provided time\r\n    /// @dev Useful for determination how much of all production will be burned/produced at the specific time\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return productionResult Production resources changes at provided time\r\n    function getProductionResult(uint256 timestamp) external view returns (ProductionResultItem[] memory productionResult);\r\n\r\n    /// @notice Calculates upgrade price by provided level\r\n    /// @dev Useful for determination how much upgrade will cost at any level\r\n    /// @param level Level at which calculate price\r\n    /// @return price Amount of resources needed for upgrade\r\n    function getUpgradePrice(uint256 level) external view returns (uint256 price);\r\n\r\n    /// @notice Calculates basic upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getBasicUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Calculates advanced upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Starts basic building upgrade\r\n    /// @dev Resources required for upgrade will be taken from msg.sender\r\n    function startBasicUpgrade() external;\r\n\r\n    /// @notice Starts advanced building upgrade\r\n    /// @dev Resources required for upgrade will be taken from msg.sender\r\n    function startAdvancedUpgrade() external;\r\n\r\n    /// @notice Calculates current level\r\n    /// @dev Takes into an account if upgrades are finished or not\r\n    /// @return level Current building level\r\n    function getBuildingLevel() external view returns (uint256 level);\r\n\r\n    /// @notice Returns production config for current building\r\n    /// @dev Main config that determines which resources is produced/spend by production of this building\r\n    /// @dev InitialResourceBlock.perTick is value how much of resource is spend/produced by 1 worker in 1 second of production\r\n    /// @return initialResourceBlocks Production config for current building\r\n    function getConfig() external view returns (InitialResourceBlock[] memory initialResourceBlocks);\r\n\r\n    /// @notice Transfers workers from current building to specified address\r\n    /// @dev Currently workers can be transferred from building only to its settlement\r\n    /// @param to An address transfer workers to\r\n    /// @param amount Amount of workers to transfer\r\n    function transferWorkers(\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Transfer specified resource from current building\r\n    /// @dev Used for withdrawing resources from production or overcapped treasury resources\r\n    /// @param resourceName Name of resource to transfer\r\n    /// @param to An address transfer resources to\r\n    /// @param amount Amount of resources to transfer\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Batch resource transfer\r\n    /// @dev Same as #transferResources but for many resources at once\r\n    /// @param resourcesNames Names of resources to transfer\r\n    /// @param to An address transfer resources to\r\n    /// @param amounts Amounts of resources to transfer\r\n    function batchTransferResources(\r\n        string[] calldata resourcesNames,\r\n        address to,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n    /// @notice Calculates maximum amount of treasury by provided level\r\n    /// @dev Can be used to determine maximum amount of treasury by any level\r\n    /// @param level Building level\r\n    /// @param maxTreasury Maximum amount of treasury\r\n    function getMaxTreasuryByLevel(uint256 level) external view returns (uint256 maxTreasury);\r\n\r\n    /// @notice Steals resources from treasury\r\n    /// @dev Called by siege or building owner, in either case part of resources will be burned according to #registry.getRobberyFee\r\n    /// @param to An address which will get resources\r\n    /// @param amount Amount of resources to steal, 'to' will get only part of specified 'amount', some percent of specified 'amount' will be burned\r\n    /// @return realAmount Real amount of resources from which stealing occurred (min(amount, treasury))\r\n    function stealTreasury(\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (uint256 realAmount);\r\n\r\n    /// @notice Burns building treasury\r\n    /// @dev Can be called by world asset or building owner\r\n    /// @param amount Amount of resources to burn from treasury\r\n    function burnTreasury(\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Calculates maximum amount of workers\r\n    /// @dev Useful to determinate maximum amount of workers\r\n    /// @return workersAmount Maximum amount of workers\r\n    function getMaxWorkers() external view returns (uint256 workersAmount);\r\n\r\n    /// @notice Calculates producing resource name for this building\r\n    /// @dev Return value is value from #getConfig where 'isProduced'=true\r\n    /// @return resourceName Name of producing resource\r\n    function getProducingResourceName() external view returns (string memory resourceName);\r\n\r\n    /// @notice Calculates treasury amount at specified time\r\n    /// @dev Useful for determination how much treasury will be at specific time\r\n    /// @param timestamp Time at which calculate amount of treasury in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return treasury Treasury amount at specified time\r\n    function getTreasury(uint256 timestamp) external view returns (uint256 treasury);\r\n\r\n    /// @notice Calculates if building is capable to accept resource\r\n    /// @dev Return value based on #getConfig\r\n    /// @param resourceName Name of resource\r\n    /// @return isResourceAcceptable Is building can accept resource\r\n    function isResourceAcceptable(string memory resourceName) external view returns (bool isResourceAcceptable);\r\n\r\n    /// @notice Returns building name\r\n    /// @dev Same value as #assetName\r\n    /// @return buildingName Building name\r\n    function buildingName() external view returns (string memory buildingName);\r\n}\r\n"
    },
    "contracts/core/assets/zone/IZone.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../workersPool/IWorkersPool.sol\";\r\nimport \"../epoch/IEpoch.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../settlementsMarket/ISettlementMarket.sol\";\r\n\r\n/// @title Zone interface\r\n/// @notice Functions to read state/modify state in order to get current zone parameters and/or interact with it\r\ninterface IZone {\r\n    /// @notice Emitted when zone initialized\r\n    /// @param workersPoolAddress Workers pool address\r\n    event WorkersPoolCreated(address workersPoolAddress);\r\n\r\n    /// @notice Emitted when zone initialized\r\n    /// @param settlementsMarketAddress Settlements market address\r\n    event SettlementsMarketCreated(address settlementsMarketAddress);\r\n\r\n    /// @notice Emitted when zone initialized\r\n    /// @param unitsPoolAddress Units pool address\r\n    /// @param unitType Unit type\r\n    event UnitsPoolCreated(address unitsPoolAddress, string unitType);\r\n\r\n    /// @notice Emitted when #increaseToxicity is called\r\n    /// @param settlementAddress An address of settlement which triggered toxicity increase\r\n    /// @param value Amount of added toxicity\r\n    event ToxicityIncreased(address settlementAddress, uint256 value);\r\n\r\n    /// @notice Emitted when #decreaseToxicity is called\r\n    /// @param settlementAddress An address of settlement which triggered toxicity decrease\r\n    /// @param value Amount of subtracted toxicity\r\n    event ToxicityDecreased(address settlementAddress, uint256 value);\r\n\r\n    /// @notice Emitted when #updateState is called\r\n    /// @param lastUpdateStateTime Time at which zone time changed\r\n    /// @param lastUpdateStateZoneTime Current zone time\r\n    event ZoneTimeChanged(uint256 lastUpdateStateTime, uint256 lastUpdateStateZoneTime);\r\n\r\n    // State variables\r\n\r\n    /// @notice Workers pool\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function workersPool() external view returns (IWorkersPool);\r\n\r\n    /// @notice Mapping containing units pool for provided unit type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function unitsPools(string memory unitName) external view returns (IUnitsPool);\r\n\r\n    /// @notice Mapping containing units market for provided unit type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function settlementsMarket() external view returns (ISettlementsMarket);\r\n\r\n    /// @notice Cultists settlement of this zone\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function cultistsSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Last time cultists were summoned in this zone\r\n    /// @dev Updated when #summonCultists is called\r\n    function cultistsSummonTime() external view returns (uint256);\r\n\r\n    /// @notice Amount of toxicity in this zone\r\n    /// @dev Updated when #increaseToxicity or #decreaseToxicity is called\r\n    function toxicity() external view returns (int256);\r\n\r\n    /// @notice Zone index\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function zoneIndex() external view returns (uint256);\r\n\r\n    /// @notice Last apply state time\r\n    /// @dev Updated when #updateState is called\r\n    function lastUpdateStateTime() external view returns (uint256);\r\n\r\n    /// @notice Last apply state zone time\r\n    /// @dev Updated when #updateState is called\r\n    function lastUpdateStateZoneTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneIndex Zone index\r\n    function init(uint256 zoneIndex) external;\r\n\r\n    /// @notice Creates cultists settlement\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsPosition Cultists position\r\n    function createCultists(uint32 cultistsPosition) external;\r\n\r\n    /// @notice Buys specified units for specified amount of weapons in current zone\r\n    /// @dev msg.sender will be used as weapons payer\r\n    /// @param settlementAddress Settlement's address army of which will receive units\r\n    /// @param unitNames Unit types\r\n    /// @param unitsCounts Units counts\r\n    /// @param maxWeaponsToSell Maximum amounts of weapons to sell for each unit types\r\n    function buyUnitsBatch(\r\n        address settlementAddress,\r\n        string[] memory unitNames,\r\n        uint256[] memory unitsCounts,\r\n        uint256[] memory maxWeaponsToSell\r\n    ) external;\r\n\r\n    /// @notice Summons cultists if conditions are met\r\n    /// @dev Anyone can call this function\r\n    function summonCultists() external;\r\n\r\n    /// @notice Increases toxicity relative to specified resources amount\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered toxicity increase\r\n    /// @param resourceName Resource name\r\n    /// @param value Amount of resource\r\n    function increaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases toxicity relative to specified resources amount\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered toxicity decrease\r\n    /// @param resourceName Resource name\r\n    /// @param value Amount of resource\r\n    function decreaseToxicity(\r\n        address settlementAddress,\r\n        string memory resourceName,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Zone cultists summon handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists minted\r\n    function handleCultistsSummoned(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Zone cultists defeat handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsArmyAddress Cultists army address\r\n    /// @param value Amount of cultists burned\r\n    function handleCultistsDefeated(\r\n        address cultistsArmyAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Calculates penalty according to current cultists count\r\n    /// @dev Uses unit.balanceOf to determine penalty\r\n    /// @return penalty Penalty from cultists\r\n    function getPenaltyFromCultists() external view returns (uint256 penalty);\r\n\r\n    /// @notice Updates zone state\r\n    /// @dev This function is called every time when production should be modified\r\n    function updateState() external;\r\n\r\n    /// @notice Calculates zone time with provided timestamp\r\n    /// @dev Takes into an account previous value and current cultists penalty and extrapolates to value at provided timestamp\r\n    /// @param timestamp Timestamp\r\n    /// @return zoneTime Extrapolated zone time\r\n    function getZoneTime(uint256 timestamp) external view returns (uint256 zoneTime);\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/IWorkersPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../zone/IZone.sol\";\r\nimport \"../../tokens/workers/IWorkers.sol\";\r\nimport \"../../tokens/prosperity/IProsperity.sol\";\r\n\r\n/// @title Zone workers pool interface\r\n/// @notice Functions to read state/modify state in order to mint workers/swap prosperity for workers\r\ninterface IWorkersPool {\r\n    /// @notice Emitted when #swapProsperityForExactWorkers or #swapExactProsperityForWorkers is called\r\n    /// @param buyer The address of settlement which bought workers\r\n    /// @param workersBought Amount of workers bought\r\n    /// @param prosperitySpent Amount of prosperity spent\r\n    event WorkersBought(\r\n        address buyer,\r\n        uint256 workersBought,\r\n        uint256 prosperitySpent\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this pool belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Starting unit price\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function startingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    function init(\r\n        address zoneAddress\r\n    ) external;\r\n\r\n    /// @notice Swaps prosperity() for exact workers()\r\n    /// @dev Even though function is opened, it can be executed only by ISettlement because only ISettlement can have prosperity\r\n    /// @param workersToBuy Exact amount of workers\r\n    /// @param maxProsperityToSell Maximum amount of prosperity to be taken for exact amount of workers\r\n    /// @return workersCount Amount of workers bought by prosperity\r\n    function swapProsperityForExactWorkers(uint256 workersToBuy, uint256 maxProsperityToSell) external returns (uint256 workersCount);\r\n\r\n    /// @notice Calculates input of prosperity based on output whole amount of workers\r\n    /// @dev Returns valid output only for integer workersToBuy value\r\n    /// @param workersToBuy Amount of workers to buy\r\n    /// @return prosperityToSell Amount of prosperity needed for workersToBuy\r\n    /// @return newStartingPrice New starting price\r\n    function getAmountIn(uint256 workersToBuy) external returns (uint256 prosperityToSell, uint256 newStartingPrice);\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/IUnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../tokens/units/IUnits.sol\";\r\nimport \"../../tokens/resources/IResource.sol\";\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Zone units pool interface\r\n/// @notice Functions to read state/modify state in order to mint units/swap weapons for units\r\ninterface IUnitsPool {\r\n    /// @notice Emitted when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    /// @param buyer The address which payed weapons\r\n    /// @param armyAddress The address of the army which received units\r\n    /// @param unitsBought Amount of units bought\r\n    /// @param weaponsSpent Amount of weapons spent\r\n    event UnitsBought(\r\n        address buyer,\r\n        address armyAddress,\r\n        uint256 unitsBought,\r\n        uint256 weaponsSpent\r\n    );\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this pool belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Units type\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function unitsType() external view returns (string memory);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Starting unit price\r\n    /// @dev Updated every time when #swapWeaponsForExactUnits or #swapWeaponsForExactUnitsByZone is called\r\n    function startingPrice() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    /// @param unitsType Units type\r\n    function init(\r\n        address zoneAddress,\r\n        string memory unitsType\r\n    ) external;\r\n\r\n    /// @notice Swaps weapons() for exact units()\r\n    /// @dev msg.sender will be used as weapons payer\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxWeaponsToSell Maximum amount of weapons to be taken for exact amount of units\r\n    /// @return unitsCount Amount of units bought by weapons\r\n    function swapWeaponsForExactUnits(\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) external returns (uint256 unitsCount);\r\n\r\n    /// @notice Swaps weapons() for exact units()\r\n    /// @dev Even though function is opened it can be called only by zone\r\n    /// @param weaponsPayer Address from which weapons will be taken\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxWeaponsToSell Maximum amount of weapons to be taken for exact amount of units\r\n    /// @return unitsCount Amount of units bought by weapons\r\n    function swapWeaponsForExactUnitsByZone(\r\n        address weaponsPayer,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWeaponsToSell\r\n    ) external returns (uint256 unitsCount);\r\n\r\n    /// @notice Calculates input of weapons based on output whole amount of units\r\n    /// @dev Returns valid output only for integer unitsToBuy value (not in 1e18 precision)\r\n    /// @param unitsToBuy Amount of workers to buy\r\n    /// @return weaponsToSell Amount of weapons needed for unitsToBuy\r\n    /// @return newStartingPrice New starting price\r\n    function getAmountIn(uint256 unitsToBuy) external returns (uint256 weaponsToSell, uint256 newStartingPrice);\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/ISettlementMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../zone/IZone.sol\";\r\n\r\n/// @title Zone settlements market interface\r\n/// @notice Functions to read state/modify state in order to buy settlement\r\ninterface ISettlementsMarket {\r\n    /// @notice Emitted when #buySettlement is called\r\n    /// @param settlementAddress Settlement address\r\n    /// @param settlementCost Settlement cost\r\n    event SettlementBought(address settlementAddress, uint256 settlementCost);\r\n\r\n    // State variables\r\n\r\n    /// @notice Zone to which this market belongs\r\n    /// @dev Immutable, initialized on the zone creation\r\n    function currentZone() external view returns (IZone);\r\n\r\n    /// @notice Time at which last purchase occurred\r\n    /// @dev Updated when #buySettlement is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by factory contract which creates current instance\r\n    /// @param zoneAddress Zone address\r\n    function init(\r\n        address zoneAddress\r\n    ) external;\r\n\r\n    /// @notice Buys settlement in zone\r\n    /// @dev Tokens will be deducted from msg.sender\r\n    /// @param position Position\r\n    /// @param ownerTokenId MithraeumBanners token id which will represent to which settlement will be attached to\r\n    /// @param maxTokensToUse Maximum amount of tokens to be withdrawn for settlement\r\n    function buySettlement(\r\n        uint32 position,\r\n        uint256 ownerTokenId,\r\n        uint256 maxTokensToUse\r\n    ) external payable;\r\n\r\n    /// @notice Returns amount of tokens new settlement will cost\r\n    /// @dev Calculates cost of placing new settlement in tokens\r\n    /// @return cost Amount of tokens new settlement will cost\r\n    function getNewSettlementCost() external view returns (uint256 cost);\r\n}\r\n"
    },
    "contracts/token/IERC20Int.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC20Int is IERC20 {\r\n    function realBalanceOf(address account) external view returns (int256);\r\n\r\n    function realTotalSupply() external view returns (int256);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/core/assets/building/impl/Fort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../Building.sol\";\r\nimport \"./IFort.sol\";\r\n\r\ncontract Fort is Building, IFort {\r\n    /// @inheritdoc IFort\r\n    uint256 public override health;\r\n\r\n    /// @inheritdoc IFort\r\n    function updateHealth(uint256 value) public onlyWorldAssetFromSameEpoch {\r\n        uint256 maxHealth = getMaxHealthOnLevel(getBuildingLevel());\r\n        health = Math.min(value, maxHealth);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceName() public view override(Building, IBuilding) returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override(Building, IBuilding) {\r\n        revert(\"resetDistribution is disabled\");\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function init(address settlementAddress)\r\n        public\r\n        override(Building, IBuilding)\r\n        initializer\r\n    {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        production.lastUpdateStateTime = block.timestamp;\r\n        health = 4e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig()\r\n        public\r\n        view\r\n        override(Building, IBuilding)\r\n        returns (InitialResourceBlock[] memory initialResourceBlocks)\r\n    {\r\n        initialResourceBlocks = new InitialResourceBlock[](3);\r\n\r\n        initialResourceBlocks[0] = InitialResourceBlock({\r\n            resourceName: \"FOOD\",\r\n            perTick: uint256(3e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[1] = InitialResourceBlock({\r\n            resourceName: \"WOOD\",\r\n            perTick: uint256(2e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        initialResourceBlocks[2] = InitialResourceBlock({\r\n            resourceName: \"HEALTH\",\r\n            perTick: uint256(1e18) / (1 days),\r\n            isProducing: true\r\n        });\r\n\r\n        return initialResourceBlocks;\r\n    }\r\n\r\n    /// @inheritdoc IFort\r\n    function getMaxHealthOnLevel(uint256 level) public view override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 2) * 2 * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc Building\r\n    function recalculateProduction() internal override {}\r\n\r\n    /// @inheritdoc Building\r\n    function updateProsperity() internal override {}\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasury(uint256 _timestamp) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 _level) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public override(Building, IBuilding) {\r\n        if (production.lastUpdateStateTime == block.timestamp) {\r\n            return;\r\n        }\r\n\r\n        uint256 currentTime = getCurrentTime();\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n        production.lastUpdateStateTime = currentTime;\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (keccak256(bytes(productionResult[i].resourceName)) == keccak256(bytes(\"HEALTH\"))) {\r\n                //health\r\n                currentSettlement.updateFortHealth(\r\n                    productionResult[i].balanceChanges,\r\n                    productionResult[i].isProducing\r\n                );\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].balanceChanges == 0) {\r\n                continue;\r\n            }\r\n\r\n            epoch().resources(productionResult[i].resourceName).burn(productionResult[i].balanceChanges);\r\n        }\r\n    }\r\n\r\n    struct FortData {\r\n        uint256 fullHealthProductionSeconds;\r\n        uint256 partialHealthProductionSeconds;\r\n    }\r\n\r\n    /// @dev Calculates fort advanced production\r\n    function calculateFortAdvancedProduction(\r\n        uint256 currentHealth,\r\n        uint256 maxHealth,\r\n        uint256 basicRegenIncome,\r\n        uint256 advancedRegenIncome,\r\n        uint256 degenIncome,\r\n        uint256 toBeProducedValue\r\n    ) public pure returns (FortData memory) {\r\n        // If advanced regen = 0, no advanced production is taking place\r\n        if (advancedRegenIncome == 0) {\r\n            return FortData({fullHealthProductionSeconds: 0, partialHealthProductionSeconds: 0});\r\n        }\r\n\r\n        uint256 missingHealth = maxHealth - currentHealth;\r\n        uint256 regenIncome = basicRegenIncome + advancedRegenIncome;\r\n        uint256 secondsUntilResourcesDepletionWithFullSpeed = toBeProducedValue / advancedRegenIncome;\r\n\r\n        // If degen is greater (or equal) than combined regen ->\r\n        // advanced production is working at full speed and will stop when there will be no resources\r\n        if (degenIncome >= regenIncome) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: secondsUntilResourcesDepletionWithFullSpeed,\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        uint256 netRegen = regenIncome - degenIncome;\r\n        uint256 secondsUntilFullWithCurrentSpeed = (missingHealth % netRegen) == 0\r\n            ? missingHealth / netRegen\r\n            : (missingHealth / netRegen) + 1;\r\n\r\n        // If degen is zero -> hp can only go up and will stop when its full or there will be no resources\r\n        if (degenIncome == 0) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: Math.min(\r\n                        secondsUntilResourcesDepletionWithFullSpeed,\r\n                        secondsUntilFullWithCurrentSpeed\r\n                    ),\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        // Basic regen at this point is always zero and degen is not zero\r\n\r\n        // If resources will run out faster than we will reach full hp ->\r\n        // advanced production is working at full speed and will be interrupted by empty resources\r\n        if (secondsUntilResourcesDepletionWithFullSpeed <= secondsUntilFullWithCurrentSpeed) {\r\n            return\r\n                FortData({\r\n                    fullHealthProductionSeconds: secondsUntilResourcesDepletionWithFullSpeed,\r\n                    partialHealthProductionSeconds: 0\r\n                });\r\n        }\r\n\r\n        // At this point we will reach full hp with current production speed meaning partial production will take place\r\n        // and it will last until we have resources for current degen\r\n        // or it also means\r\n        // part of production that is left after we have reached full hp is the same as\r\n        // amount of seconds until full subtracted from amount of seconds until depletion BUT multiplied by regen/degen ratio\r\n        // in order to 'extend' production seconds\r\n        // for example:\r\n        // - we have 100 seconds until resources depletion with full speed\r\n        // - we have 40 seconds until full with current speed\r\n        // - we have 20 hp/s of advanced regen\r\n        // - we have 10 hp/s of degen\r\n        // - 100 - 40 = 60 seconds -> amount of seconds of full production speed that has to be converted to lower consumption\r\n        // or 60 seconds * 20 hp/s = 1200hp -> amount of hp would have been produced with full speed\r\n        // then 1200 hp / 10hp/s = 120 seconds of lowered production\r\n        uint256 partialHealthProductionSeconds = (\r\n            (secondsUntilResourcesDepletionWithFullSpeed - secondsUntilFullWithCurrentSpeed) * regenIncome\r\n        ) / degenIncome;\r\n\r\n        return\r\n            FortData({\r\n                fullHealthProductionSeconds: secondsUntilFullWithCurrentSpeed,\r\n                partialHealthProductionSeconds: partialHealthProductionSeconds\r\n            });\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override(Building, IBuilding)\r\n        returns (ProductionResultItem[] memory res)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime != 0) {\r\n            timestamp = Math.min(timestamp, gameFinishTime);\r\n        }\r\n\r\n        InitialResourceBlock[] memory initialResourceBlocks = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](initialResourceBlocks.length);\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceName: initialResourceBlocks[i].resourceName,\r\n                isProducing: initialResourceBlocks[i].isProducing,\r\n                balanceChanges: 0\r\n            });\r\n        }\r\n\r\n        if (timestamp <= production.lastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        uint256 basicRegenIncome = (initialResourceBlocks[2].perTick * getBasicProductionMultiplier()) / 1e18;\r\n        uint256 advancedRegenIncome = (initialResourceBlocks[2].perTick * getAdvancedProductionMultiplier()) / 1e18;\r\n        uint256 degenIncome = currentSettlement.getCurrentSiegePower();\r\n\r\n        // If basic regen greater (or equal) than degen -> actual degen is zero and basic regen reduced\r\n        // else basic regen is zero and degen is reduced\r\n        if (basicRegenIncome >= degenIncome) {\r\n            basicRegenIncome = basicRegenIncome - degenIncome;\r\n            degenIncome = 0;\r\n        } else {\r\n            degenIncome = degenIncome - basicRegenIncome;\r\n            basicRegenIncome = 0;\r\n        }\r\n\r\n        FortData memory secondsUntilSpeedChanges = calculateFortAdvancedProduction(\r\n            health,\r\n            getMaxHealthOnLevel(getBuildingLevel()),\r\n            basicRegenIncome,\r\n            advancedRegenIncome,\r\n            degenIncome,\r\n            initialResourceBlocks[2].perTick * calculateProductionTicksAmount()\r\n        );\r\n\r\n        uint256 elapsedSeconds = timestamp - production.lastUpdateStateTime;\r\n\r\n        uint256 fullIncomeSecondsElapsed = Math.min(\r\n            secondsUntilSpeedChanges.fullHealthProductionSeconds,\r\n            elapsedSeconds\r\n        );\r\n        uint256 partialIncomeSecondsElapsed = Math.min(\r\n            elapsedSeconds - fullIncomeSecondsElapsed,\r\n            secondsUntilSpeedChanges.partialHealthProductionSeconds\r\n        );\r\n\r\n        uint256 advancedHealthProduced = fullIncomeSecondsElapsed * advancedRegenIncome + partialIncomeSecondsElapsed * degenIncome;\r\n        uint256 healthProduced = advancedHealthProduced + elapsedSeconds * basicRegenIncome;\r\n        uint256 healthLost = elapsedSeconds * degenIncome;\r\n        uint256 advancedTicksProduced = advancedHealthProduced / initialResourceBlocks[2].perTick;\r\n\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            if (initialResourceBlocks[i].isProducing) {\r\n                bool isHealthProduced = healthProduced >= healthLost;\r\n                uint256 healthChanges = isHealthProduced\r\n                    ? healthProduced - healthLost\r\n                    : healthLost - healthProduced;\r\n\r\n                productionResult[i].isProducing = isHealthProduced;\r\n                productionResult[i].balanceChanges = healthChanges;\r\n            } else {\r\n                productionResult[i].balanceChanges = initialResourceBlocks[i].perTick * advancedTicksProduced;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/Building.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"./IBuilding.sol\";\r\nimport \"../WorldAsset.sol\";\r\n\r\nabstract contract Building is WorldAsset, IBuilding {\r\n    /// @inheritdoc IBuilding\r\n    ISettlement public override currentSettlement;\r\n    /// @inheritdoc IBuilding\r\n    BasicProduction public override basicProduction;\r\n    /// @inheritdoc IBuilding\r\n    AdvancedProduction public override advancedProduction;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override upgradeCooldownFinishTime;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override prosperity;\r\n    /// @inheritdoc IBuilding\r\n    Production public override production;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override distributionId;\r\n    /// @inheritdoc IBuilding\r\n    mapping(address => uint256) public override producedResourceDebt;\r\n\r\n    modifier onlyDistributions() {\r\n        require(\r\n            address(world().distributions()) == msg.sender,\r\n            \"onlyDistributions\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only settlement owner\r\n    modifier onlySettlementOwner() {\r\n        require(\r\n            currentSettlement.getSettlementOwner() == msg.sender,\r\n            \"onlySettlementOwner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be ruler or world or world asset\r\n    modifier onlyRulerOrWorldAssetFromSameEpoch() {\r\n        require(\r\n            currentSettlement.isRuler(msg.sender) ||\r\n                msg.sender == address(world()) ||\r\n                world().worldAssets(epochNumber(), msg.sender) != bytes32(0),\r\n            \"onlyRulerOrWorldAssetFromSameEpoch\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Calculates building coefficient\r\n    function getBuildingCoefficient(uint256 level) internal view returns (uint256) {\r\n        uint256 increaseByEveryNLevels = 5;\r\n        uint256 b = level / increaseByEveryNLevels;\r\n        uint256 c = level - b * increaseByEveryNLevels;\r\n        uint256 d = (((b + 1) * b) / 2) * increaseByEveryNLevels;\r\n        uint256 e = d + c * (b + 1);\r\n        return e;\r\n    }\r\n\r\n    /// @dev Creates default distribution (all possible tokens will be minted to current settlement owner)\r\n    function setDefaultDistribution() internal {\r\n        // Previous distributors is required for thegraph purposes\r\n        address[] memory previousReceivers = world().distributions().getDistributionReceivers(distributionId);\r\n        distributionId = world().distributions().mint(currentSettlement.getSettlementOwner());\r\n        emit NewDistribution(distributionId, previousReceivers);\r\n    }\r\n\r\n    /// @dev Saves produced amount of resource between treasury and production.readyToBeDistributed\r\n    function saveProducedResource(string memory resourceName, uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        //N% of resources moves to treasury pool\r\n        uint256 amountOfResourceGoingToTreasury = (amount * registry().getToTreasuryPercent()) / 1e18;\r\n\r\n        uint256 currentTreasury = epoch().resources(resourceName).stateBalanceOf(address(this));\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n\r\n        if (currentTreasury >= maxTreasury) {\r\n            amountOfResourceGoingToTreasury = 0;\r\n        } else if (amountOfResourceGoingToTreasury > maxTreasury - currentTreasury) {\r\n            amountOfResourceGoingToTreasury = maxTreasury - currentTreasury;\r\n        }\r\n\r\n        if (amountOfResourceGoingToTreasury > 0) {\r\n            epoch().resources(resourceName).mint(address(this), amountOfResourceGoingToTreasury);\r\n            amount = amount - amountOfResourceGoingToTreasury;\r\n        }\r\n\r\n        if (amount > 0) {\r\n            currentSettlement.currentZone().increaseToxicity(\r\n                address(currentSettlement),\r\n                getProducingResourceName(),\r\n                amount\r\n            );\r\n\r\n            production.readyToBeDistributed += amount;\r\n        }\r\n    }\r\n\r\n    /// @dev Updates building prosperity according to changed amount of resources in building\r\n    function updateProsperity() internal virtual {\r\n        uint256 buildingLevel = getBuildingLevel();\r\n        uint256 levelCoefficient = getBuildingCoefficient(buildingLevel);\r\n\r\n        uint256 currentProductionResourceBalance = epoch().resources(getProducingResourceName()).stateBalanceOf(\r\n            address(this)\r\n        );\r\n\r\n        uint256 prosperityBefore = prosperity;\r\n\r\n        uint256 resourceWeight = registry().getResourceWeight(getProducingResourceName());\r\n        uint256 potentialNewProsperity = currentProductionResourceBalance * resourceWeight / levelCoefficient;\r\n        uint256 maxProsperity = getMaxTreasuryByLevel(buildingLevel) * resourceWeight / levelCoefficient;\r\n\r\n        uint256 prosperityAfter = Math.min(maxProsperity, potentialNewProsperity);\r\n        prosperity = prosperityAfter;\r\n\r\n        if (prosperityBefore > prosperityAfter) {\r\n            epoch().prosperity().burnFrom(address(currentSettlement), prosperityBefore - prosperityAfter);\r\n        } else if (prosperityBefore < prosperityAfter) {\r\n            epoch().prosperity().mint(address(currentSettlement), prosperityAfter - prosperityBefore);\r\n        }\r\n    }\r\n\r\n    /// @dev Recalculates production structure according to new resource balances\r\n    function recalculateProduction() internal virtual {\r\n        uint256 productionMultiplier = getAdvancedProductionMultiplier() / 1e18;\r\n        uint256 productionZoneTimeLeftUntilStop = 0;\r\n        uint256 extraTicksAfterFinish = 0;\r\n\r\n        if (productionMultiplier > 0) {\r\n            uint256 productionTicksLeftUntilStop = calculateProductionTicksAmount();\r\n\r\n            if (productionTicksLeftUntilStop == type(uint256).max) {\r\n                productionZoneTimeLeftUntilStop = type(uint256).max;\r\n            } else {\r\n                productionZoneTimeLeftUntilStop = (productionTicksLeftUntilStop * (1e18 / registry().getProductionTicksInSecond())) / productionMultiplier;\r\n\r\n                if (productionTicksLeftUntilStop % productionMultiplier > 0) {\r\n                    extraTicksAfterFinish = productionTicksLeftUntilStop % productionMultiplier;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (productionZoneTimeLeftUntilStop == type(uint256).max) {\r\n            production.productionFinishZoneTime = type(uint256).max;\r\n        } else {\r\n            production.productionFinishZoneTime = currentSettlement.currentZone().getZoneTime(getCurrentTime()) + productionZoneTimeLeftUntilStop;\r\n        }\r\n\r\n        production.extraTicksAfterFinish = extraTicksAfterFinish;\r\n    }\r\n\r\n    /// @dev Calculates current game time, taking into an account game finish time\r\n    function getCurrentTime() internal view returns (uint256) {\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime == 0) {\r\n            return block.timestamp;\r\n        }\r\n\r\n        return Math.min(block.timestamp, gameFinishTime);\r\n    }\r\n\r\n    /// @dev Calculates basic production multiplier\r\n    function getBasicProductionMultiplier() internal view returns (uint256) {\r\n        string memory currentBuildingName = buildingName();\r\n\r\n        return (\r\n            basicProduction.coefficient\r\n            * registry().getBasicProductionBuildingCoefficient(currentBuildingName)\r\n            * registry().getWorkerCapacityCoefficient(currentBuildingName)\r\n            * registry().getGlobalMultiplier()\r\n        ) / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates advanced production multiplier\r\n    function getAdvancedProductionMultiplier() internal view returns (uint256) {\r\n        return (Math.min(getWorkers(), getMaxWorkers())) * registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates amount of production ticks for current building according to its resources balances\r\n    function calculateProductionTicksAmount() internal view returns (uint256) {\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        uint256 productionTicksAmountUntilStop = type(uint256).max;\r\n\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (config[i].isProducing) {\r\n                continue;\r\n            }\r\n\r\n            uint256 balance = epoch().resources(config[i].resourceName).stateBalanceOf(address(this));\r\n            if (balance == 0) {\r\n                return 0;\r\n            }\r\n\r\n            productionTicksAmountUntilStop = Math.min(\r\n                balance / config[i].perTick,\r\n                productionTicksAmountUntilStop\r\n            );\r\n        }\r\n\r\n        return productionTicksAmountUntilStop;\r\n    }\r\n\r\n    /// @dev Calculates is building token recall allowed according to building token transfer threshold\r\n    function isBuildingTokenRecallAllowed() internal returns (bool) {\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n        string memory producingResourceName = getProducingResourceName();\r\n        if (bytes(producingResourceName).length == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 currentTreasuryThreshold = (maxTreasury * registry().getBuildingTokenTransferThresholdPercent()) / 1e18;\r\n        uint256 currentTreasury = epoch().resources(producingResourceName).balanceOf(address(this));\r\n\r\n        return currentTreasury <= currentTreasuryThreshold;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function init(address settlementAddress) public virtual override initializer {\r\n        currentSettlement = ISettlement(settlementAddress);\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        uint256 timestamp = getCurrentTime();\r\n        production.lastUpdateStateTime = timestamp;\r\n        production.lastUpdateStateZoneTime = currentSettlement.currentZone().getZoneTime(timestamp);\r\n\r\n        if (registry().hasStartingTreasury(buildingName())) {\r\n            epoch().resources(getProducingResourceName()).mint(address(this), getMaxTreasuryByLevel(getBuildingLevel()));\r\n            updateProsperity();\r\n        }\r\n\r\n        setDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function productionChanged() public virtual override {\r\n        updateProsperity();\r\n        updateState();\r\n        recalculateProduction();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public virtual override {\r\n        currentSettlement.currentZone().updateState();\r\n\r\n        uint256 currentTime = getCurrentTime();\r\n        if (production.lastUpdateStateTime == currentTime) {\r\n            return;\r\n        }\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n        production.lastUpdateStateTime = currentTime;\r\n        production.lastUpdateStateZoneTime = currentSettlement.currentZone().getZoneTime(currentTime);\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (productionResult[i].balanceChanges == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].isProducing) {\r\n                saveProducedResource(productionResult[i].resourceName, productionResult[i].balanceChanges);\r\n            } else {\r\n                epoch().resources(productionResult[i].resourceName).burn(productionResult[i].balanceChanges);\r\n            }\r\n        }\r\n\r\n        updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function fixDebtAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyDistributions {\r\n        uint256 debtAmount = amount * production.readyToBeDistributed;\r\n        if (debtAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        producedResourceDebt[from] -= debtAmount;\r\n        producedResourceDebt[to] += debtAmount;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToSingleShareholder(address holder) public override {\r\n        updateState();\r\n\r\n        IDistributions distributions = world().distributions();\r\n        uint256 nftBalance = distributions.balanceOf(holder, distributionId);\r\n        if (nftBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 partOfProduction = production.readyToBeDistributed * nftBalance / distributions.getItemsPerNft() - producedResourceDebt[holder];\r\n        if (partOfProduction == 0) {\r\n            return;\r\n        }\r\n\r\n        producedResourceDebt[holder] += partOfProduction;\r\n        string memory productionResourceType = getProducingResourceName();\r\n        epoch().resources(productionResourceType).mint(holder, partOfProduction);\r\n        emit DistributedToShareHolder(productionResourceType, holder, partOfProduction);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToAllShareholders() public override {\r\n        updateState();\r\n\r\n        uint256 readyToBeDistributed = production.readyToBeDistributed;\r\n        string memory productionResourceType = getProducingResourceName();\r\n        IResource producingResource = epoch().resources(productionResourceType);\r\n        IDistributions distributions = world().distributions();\r\n        uint256 itemsPerNft = distributions.getItemsPerNft();\r\n\r\n        address[] memory topHolders = world().distributions().getDistributionReceivers(distributionId);\r\n        for (uint256 i = 0; i < topHolders.length; i++) {\r\n            address holder = topHolders[i];\r\n            uint256 holderDebt = producedResourceDebt[holder];\r\n            uint256 partOfProduction = ((readyToBeDistributed * distributions.balanceOf(holder, distributionId)) / itemsPerNft) - holderDebt;\r\n            if (holderDebt > 0) {\r\n                producedResourceDebt[holder] = 0;\r\n            }\r\n\r\n            if (partOfProduction > 0) {\r\n                producingResource.mint(holder, partOfProduction);\r\n                emit DistributedToShareHolder(productionResourceType, holder, partOfProduction);\r\n            }\r\n        }\r\n\r\n        production.readyToBeDistributed = 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getResourcesAmount(string memory _resourceName, uint256 _timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        ProductionResultItem[] memory result = getProductionResult(_timestamp);\r\n\r\n        bytes32 resourceNameBytes = keccak256(bytes(_resourceName));\r\n\r\n        for (uint256 i = 0; i < result.length; i++) {\r\n            if (keccak256(bytes(result[i].resourceName)) == resourceNameBytes) {\r\n                if (result[i].isProducing) {\r\n                    uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n                    if (maxTreasury == 0) {\r\n                        return 0;\r\n                    }\r\n\r\n                    uint256 amountOfResourcePotentiallyGoingToTreasury = (result[i].balanceChanges * registry().getToTreasuryPercent()) / 1e18;\r\n                    uint256 currentTreasuryResourcesAmount = epoch().resources(getProducingResourceName()).stateBalanceOf(address(this));\r\n\r\n                    // In case if building has more resources than max in treasury -> none of production resources will go to the treasury\r\n                    // therefore building doesnt produced anything to the building\r\n                    if (currentTreasuryResourcesAmount >= maxTreasury) {\r\n                        return currentTreasuryResourcesAmount;\r\n                    }\r\n\r\n                    return Math.min(\r\n                        amountOfResourcePotentiallyGoingToTreasury + currentTreasuryResourcesAmount,\r\n                        maxTreasury\r\n                    );\r\n                } else {\r\n                    return epoch().resources(_resourceName).stateBalanceOf(address(this)) - result[i].balanceChanges;\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (ProductionResultItem[] memory)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        if (gameFinishTime != 0) {\r\n            timestamp = Math.min(timestamp, gameFinishTime);\r\n        }\r\n\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](config.length);\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceName: config[i].resourceName,\r\n                isProducing: config[i].isProducing,\r\n                balanceChanges: 0\r\n            });\r\n        }\r\n\r\n        if (timestamp <= production.lastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        uint256 zoneTime = currentSettlement.currentZone().getZoneTime(timestamp);\r\n        uint256 advancedProductionFinishTime = zoneTime;\r\n\r\n        bool isProductionSurpassedFinishTime = false;\r\n        if (advancedProductionFinishTime > production.productionFinishZoneTime) {\r\n            advancedProductionFinishTime = production.productionFinishZoneTime;\r\n            isProductionSurpassedFinishTime = true;\r\n        }\r\n\r\n        uint256 producedTicksByBasicProduction = getProducedTicksByBasicProduction(\r\n            production.lastUpdateStateZoneTime,\r\n            zoneTime\r\n        );\r\n\r\n        uint256 producedTicksByAdvancedProduction = getProducedTicksByAdvancedProduction(\r\n            production.lastUpdateStateZoneTime,\r\n            advancedProductionFinishTime,\r\n            isProductionSurpassedFinishTime\r\n        );\r\n\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            productionResult[i].balanceChanges = config[i].perTick * producedTicksByAdvancedProduction;\r\n\r\n            // Is producing value increased here because basic production does not stop and building upgrades through time\r\n            if (productionResult[i].isProducing) {\r\n                productionResult[i].balanceChanges += config[i].perTick * producedTicksByBasicProduction;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by advanced production for provided start, finish time and is production surpassed finish time\r\n    function getProducedTicksByAdvancedProduction(\r\n        uint256 advancedProductionStartTime,\r\n        uint256 advancedProductionFinishTime,\r\n        bool isProductionSurpassedFinishTime\r\n    ) internal view returns (uint256) {\r\n        if (advancedProductionFinishTime <= advancedProductionStartTime) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 advancedProductionDuration = advancedProductionFinishTime - advancedProductionStartTime;\r\n\r\n        uint256 productionMultiplier = getAdvancedProductionMultiplier();\r\n        uint256 fullTicksPassed = advancedProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return isProductionSurpassedFinishTime\r\n            ? (productionMultiplier * fullTicksPassed) / 1e18 + production.extraTicksAfterFinish\r\n            : (productionMultiplier * fullTicksPassed) / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by basic production for provided start, finish time and basic production coefficient\r\n    function getProducedTicksByBasicProduction(\r\n        uint256 basicProductionStartTime,\r\n        uint256 basicProductionFinishTime\r\n    ) internal view returns (uint256) {\r\n        uint256 basicProductionDuration = basicProductionFinishTime - basicProductionStartTime;\r\n        uint256 ticksPassed = basicProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return getBasicProductionMultiplier() * ticksPassed / 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override virtual onlySettlementOwner {\r\n        require(isBuildingTokenRecallAllowed(), \"Token recall not allowed\");\r\n        distributeToAllShareholders();\r\n        setDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function isResourceAcceptable(string memory _resourceName) public view override returns (bool) {\r\n        InitialResourceBlock[] memory config = getConfig();\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (keccak256(bytes(config[i].resourceName)) == keccak256(bytes(_resourceName))) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function batchTransferResources(\r\n        string[] calldata resourcesNames,\r\n        address to,\r\n        uint256[] calldata amounts\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        for (uint256 i = 0; i < resourcesNames.length; i++) {\r\n            transferResources(resourcesNames[i], to, amounts[i]);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function transferWorkers(address to, uint256 amount) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        epoch().workers().transfer(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function transferResources(\r\n        string memory resourceName,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        IResource resource = epoch().resources(resourceName);\r\n        uint256 balance = resource.balanceOf(address(this));\r\n        if (balance == 0) {\r\n            return;\r\n        }\r\n\r\n        if (amount > balance) {\r\n            amount = balance;\r\n        }\r\n\r\n        if (keccak256(bytes(resourceName)) == keccak256(bytes(getProducingResourceName()))) {\r\n            uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n            uint256 availableToTransfer = 0;\r\n\r\n            if (balance > maxTreasury) {\r\n                availableToTransfer = balance - maxTreasury;\r\n            }\r\n\r\n            if (amount > availableToTransfer) {\r\n                amount = availableToTransfer;\r\n            }\r\n        }\r\n\r\n        if (amount > 0) {\r\n            resource.transfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getUpgradePrice(uint256 level)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTreasuryByLevel = getMaxTreasuryByLevel(level);\r\n        uint256 maxTreasuryByNextLevel = getMaxTreasuryByLevel(level + 1);\r\n        uint256 maxTreasuryByLevelWithCoefficient = (maxTreasuryByLevel * 75) / 100;\r\n        uint256 treasuryDifference = maxTreasuryByNextLevel - maxTreasuryByLevelWithCoefficient;\r\n        return treasuryDifference;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBuildingLevel() public view override returns (uint256) {\r\n        return basicProduction.level + advancedProduction.level;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getWorkers() public view virtual override returns (uint256) {\r\n        return epoch().workers().balanceOf(address(this));\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function startBasicUpgrade() public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        require(getCurrentTime() >= upgradeCooldownFinishTime, \"already upgrading\");\r\n\r\n        uint256 upgradePrice = getUpgradePrice(getBuildingLevel());\r\n\r\n        epoch().resources(\"WOOD\").burnFrom(msg.sender, upgradePrice);\r\n        currentSettlement.currentZone().decreaseToxicity(address(currentSettlement), \"WOOD\", upgradePrice);\r\n\r\n        upgradeCooldownFinishTime = block.timestamp + getBasicUpgradeCooldownDuration(getBuildingLevel());\r\n\r\n        uint256 oldLevel = basicProduction.level;\r\n        uint256 newLevel = oldLevel + 1;\r\n        basicProduction.level = newLevel;\r\n\r\n        uint256 coefficientDelta = getBuildingCoefficient(newLevel) - getBuildingCoefficient(oldLevel);\r\n        basicProduction.coefficient = basicProduction.coefficient + coefficientDelta;\r\n\r\n        updateProsperity();\r\n\r\n        emit UpgradeFinish(getBuildingLevel());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function startAdvancedUpgrade() public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEpoch {\r\n        updateState();\r\n\r\n        require(getCurrentTime() >= upgradeCooldownFinishTime, \"already upgrading\");\r\n\r\n        uint256 upgradePrice = getUpgradePrice(getBuildingLevel());\r\n\r\n        epoch().resources(\"ORE\").burnFrom(msg.sender, upgradePrice);\r\n        currentSettlement.currentZone().decreaseToxicity(address(currentSettlement), \"ORE\", upgradePrice);\r\n\r\n        upgradeCooldownFinishTime = block.timestamp + getAdvancedUpgradeCooldownDuration(getBuildingLevel());\r\n\r\n        uint256 oldLevel = advancedProduction.level;\r\n        uint256 newLevel = oldLevel + 1;\r\n        advancedProduction.level = newLevel;\r\n\r\n        uint256 coefficientDelta = getBuildingCoefficient(newLevel) - getBuildingCoefficient(oldLevel);\r\n        advancedProduction.coefficient = advancedProduction.coefficient + coefficientDelta;\r\n\r\n        updateProsperity();\r\n\r\n        emit UpgradeFinish(getBuildingLevel());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBasicUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return level * 6 hours;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceName() public view virtual override returns (string memory) {\r\n        InitialResourceBlock[] memory initialResourceBlocks = getConfig();\r\n        for (uint256 i = 0; i < initialResourceBlocks.length; i++) {\r\n            if (initialResourceBlocks[i].isProducing) {\r\n                return initialResourceBlocks[i].resourceName;\r\n            }\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxWorkers() public view override returns (uint256) {\r\n        return advancedProduction.coefficient * registry().getWorkerCapacityCoefficient(buildingName());\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasury(uint256 timestamp) public view virtual override returns (uint256) {\r\n        return getResourcesAmount(getProducingResourceName(), timestamp);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 level) public view virtual override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 2) * 10 * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function stealTreasury(address to, uint256 amountToSteal)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyWorldAssetFromSameEpoch\r\n        returns (uint256)\r\n    {\r\n        updateState();\r\n\r\n        uint256 currentTreasuryResourcesAmount = epoch().resources(getProducingResourceName()).stateBalanceOf(address(this));\r\n        uint256 currentTreasuryAmount = Math.min(getMaxTreasuryByLevel(getBuildingLevel()), currentTreasuryResourcesAmount);\r\n        if (currentTreasuryAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        amountToSteal = Math.min(currentTreasuryAmount, amountToSteal);\r\n\r\n        uint256 amountToBurn = (amountToSteal * registry().getRobberyFee()) / 1e18;\r\n\r\n        IResource resource = epoch().resources(getProducingResourceName());\r\n        resource.transfer(to, amountToSteal - amountToBurn);\r\n        burnTreasury(amountToBurn);\r\n\r\n        return amountToSteal;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function burnTreasury(uint256 burnAmount) public override onlyActiveGame onlyWorldAssetFromSameEpoch {\r\n        IResource resource = epoch().resources(getProducingResourceName());\r\n        resource.burn(burnAmount);\r\n        updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view virtual override returns (InitialResourceBlock[] memory initialResourceBlocks);\r\n\r\n    /// @inheritdoc IBuilding\r\n    function buildingName() public view virtual override returns (string memory) {\r\n        return assetType();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/IFort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IBuilding.sol\";\r\n\r\n/// @title Fort interface\r\n/// @notice Functions to read state/modify state in order to get current fort parameters and/or interact with it\r\ninterface IFort is IBuilding {\r\n    // State variables\r\n\r\n    /// @notice Fort health\r\n    /// @dev Updated when #updateHealth is called\r\n    function health() external view returns (uint256);\r\n\r\n    // Functions\r\n\r\n    /// @notice Updates fort health\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param value New fort health\r\n    function updateHealth(uint256 value) external;\r\n\r\n    /// @notice Calculates maximum amount of health for provided level\r\n    /// @dev Useful to determine maximum amount of health will be available at provided level\r\n    /// @param level Level at which calculate maximum amount of health\r\n    /// @return maxHealth Maximum amount of health for provided level\r\n    function getMaxHealthOnLevel(uint256 level) external view returns (uint256 maxHealth);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/core/assets/WorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\nimport \"./IWorldAsset.sol\";\r\nimport \"./WorldAssetStorageAccessor.sol\";\r\n\r\n/// @title Abstract world asset\r\n/// @notice World asset must inherit this basic contract\r\nabstract contract WorldAsset is IWorldAsset, WorldAssetStorageAccessor, Initializable {\r\n    /// Allows caller to be only mighty creator\r\n    modifier onlyMightyCreator() {\r\n        require(msg.sender == registry().mightyCreator(), \"onlyMightyCreator\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows caller to be only world or world asset\r\n    modifier onlyWorldAssetFromSameEpoch() {\r\n        require(\r\n            msg.sender == address(world()) ||\r\n                world().worldAssets(WorldAssetStorageAccessor.epochNumber(), msg.sender) != bytes32(0),\r\n            \"onlyWorldAssetFromSameEpoch\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    modifier onlyActiveGame() {\r\n        uint256 gameFinishTime = world().gameFinishTime();\r\n        require(gameFinishTime == 0 || block.timestamp < gameFinishTime, \"game closed\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function world() public view override(IWorldAsset, WorldAssetStorageAccessor) returns (IWorld) {\r\n        return WorldAssetStorageAccessor.world();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function registry() public view override returns (IRegistry) {\r\n        return world().registry();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function epoch() public view override returns (IEpoch) {\r\n        return world().epochs(WorldAssetStorageAccessor.epochNumber());\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/core/assets/WorldAssetStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nstruct WorldAssetStorage {\r\n    address worldAddress;\r\n    uint256 epochNumber;\r\n    bytes32 assetId;\r\n    string assetGroup;\r\n    string assetType;\r\n}\r\n\r\nfunction getWorldAssetStorage() pure returns (WorldAssetStorage storage ds) {\r\n    //keccak256(\"mithraeum.worldassetproxy\") is 6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6\r\n    bytes32 position = 0x6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6;\r\n    assembly {\r\n        ds.slot := position\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorageAccessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorldAssetStorageAccessor.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\n\r\n/// @title World asset storage accessor\r\n/// @notice Any world asset which requires to identify itself as a specific type should inherit this contract\r\nabstract contract WorldAssetStorageAccessor is IWorldAssetStorageAccessor {\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function world() public view virtual override returns (IWorld) {\r\n        return IWorld(getWorldAssetStorage().worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function epochNumber() public view override returns (uint256) {\r\n        return getWorldAssetStorage().epochNumber;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetGroup() public view override returns (string memory) {\r\n        return getWorldAssetStorage().assetGroup;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetType() public view override returns (string memory) {\r\n        return getWorldAssetStorage().assetType;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/core/assets/IWorldAssetStorageAccessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\n\r\n/// @title World asset storage accessor interface\r\n/// @notice Contains function to identify world asset group and type\r\ninterface IWorldAssetStorageAccessor {\r\n    // Functions\r\n\r\n    /// @notice Returns world\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return world World\r\n    function world() external view returns (IWorld world);\r\n\r\n    /// @notice Returns epoch number\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return epochNumber Epoch number\r\n    function epochNumber() external view returns (uint256 epochNumber);\r\n\r\n    /// @notice Returns world asset group\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetGroup World asset group\r\n    function assetGroup() external view returns (string memory assetGroup);\r\n\r\n    /// @notice Returns world asset type\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetType World asset type\r\n    function assetType() external view returns (string memory assetType);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 300
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}